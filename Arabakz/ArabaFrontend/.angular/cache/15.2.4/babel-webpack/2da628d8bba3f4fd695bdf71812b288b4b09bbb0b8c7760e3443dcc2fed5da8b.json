{"ast":null,"code":"'use strict';\n\nvar sourcemapCodec = require('@jridgewell/sourcemap-codec');\nclass BitSet {\n  constructor(arg) {\n    this.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n  }\n  add(n) {\n    this.bits[n >> 5] |= 1 << (n & 31);\n  }\n  has(n) {\n    return !!(this.bits[n >> 5] & 1 << (n & 31));\n  }\n}\nclass Chunk {\n  constructor(start, end, content) {\n    this.start = start;\n    this.end = end;\n    this.original = content;\n    this.intro = '';\n    this.outro = '';\n    this.content = content;\n    this.storeName = false;\n    this.edited = false;\n    {\n      this.previous = null;\n      this.next = null;\n    }\n  }\n  appendLeft(content) {\n    this.outro += content;\n  }\n  appendRight(content) {\n    this.intro = this.intro + content;\n  }\n  clone() {\n    const chunk = new Chunk(this.start, this.end, this.original);\n    chunk.intro = this.intro;\n    chunk.outro = this.outro;\n    chunk.content = this.content;\n    chunk.storeName = this.storeName;\n    chunk.edited = this.edited;\n    return chunk;\n  }\n  contains(index) {\n    return this.start < index && index < this.end;\n  }\n  eachNext(fn) {\n    let chunk = this;\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.next;\n    }\n  }\n  eachPrevious(fn) {\n    let chunk = this;\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.previous;\n    }\n  }\n  edit(content, storeName, contentOnly) {\n    this.content = content;\n    if (!contentOnly) {\n      this.intro = '';\n      this.outro = '';\n    }\n    this.storeName = storeName;\n    this.edited = true;\n    return this;\n  }\n  prependLeft(content) {\n    this.outro = content + this.outro;\n  }\n  prependRight(content) {\n    this.intro = content + this.intro;\n  }\n  split(index) {\n    const sliceIndex = index - this.start;\n    const originalBefore = this.original.slice(0, sliceIndex);\n    const originalAfter = this.original.slice(sliceIndex);\n    this.original = originalBefore;\n    const newChunk = new Chunk(index, this.end, originalAfter);\n    newChunk.outro = this.outro;\n    this.outro = '';\n    this.end = index;\n    if (this.edited) {\n      // TODO is this block necessary?...\n      newChunk.edit('', false);\n      this.content = '';\n    } else {\n      this.content = originalBefore;\n    }\n    newChunk.next = this.next;\n    if (newChunk.next) newChunk.next.previous = newChunk;\n    newChunk.previous = this;\n    this.next = newChunk;\n    return newChunk;\n  }\n  toString() {\n    return this.intro + this.content + this.outro;\n  }\n  trimEnd(rx) {\n    this.outro = this.outro.replace(rx, '');\n    if (this.outro.length) return true;\n    const trimmed = this.content.replace(rx, '');\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        this.split(this.start + trimmed.length).edit('', undefined, true);\n      }\n      return true;\n    } else {\n      this.edit('', undefined, true);\n      this.intro = this.intro.replace(rx, '');\n      if (this.intro.length) return true;\n    }\n  }\n  trimStart(rx) {\n    this.intro = this.intro.replace(rx, '');\n    if (this.intro.length) return true;\n    const trimmed = this.content.replace(rx, '');\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        this.split(this.end - trimmed.length);\n        this.edit('', undefined, true);\n      }\n      return true;\n    } else {\n      this.edit('', undefined, true);\n      this.outro = this.outro.replace(rx, '');\n      if (this.outro.length) return true;\n    }\n  }\n}\nfunction getBtoa() {\n  if (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n    return str => window.btoa(unescape(encodeURIComponent(str)));\n  } else if (typeof Buffer === 'function') {\n    return str => Buffer.from(str, 'utf-8').toString('base64');\n  } else {\n    return () => {\n      throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n    };\n  }\n}\nconst btoa = /*#__PURE__*/getBtoa();\nclass SourceMap {\n  constructor(properties) {\n    this.version = 3;\n    this.file = properties.file;\n    this.sources = properties.sources;\n    this.sourcesContent = properties.sourcesContent;\n    this.names = properties.names;\n    this.mappings = sourcemapCodec.encode(properties.mappings);\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n  toUrl() {\n    return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n  }\n}\nfunction guessIndent(code) {\n  const lines = code.split('\\n');\n  const tabbed = lines.filter(line => /^\\t+/.test(line));\n  const spaced = lines.filter(line => /^ {2,}/.test(line));\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  }\n\n  // More lines tabbed than spaced? Assume tabs, and\n  // default to tabs in the case of a tie (or nothing\n  // to go on)\n  if (tabbed.length >= spaced.length) {\n    return '\\t';\n  }\n\n  // Otherwise, we need to guess the multiple\n  const min = spaced.reduce((previous, current) => {\n    const numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(' ');\n}\nfunction getRelativePath(from, to) {\n  const fromParts = from.split(/[/\\\\]/);\n  const toParts = to.split(/[/\\\\]/);\n  fromParts.pop(); // get dirname\n\n  while (fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n  if (fromParts.length) {\n    let i = fromParts.length;\n    while (i--) fromParts[i] = '..';\n  }\n  return fromParts.concat(toParts).join('/');\n}\nconst toString = Object.prototype.toString;\nfunction isObject(thing) {\n  return toString.call(thing) === '[object Object]';\n}\nfunction getLocator(source) {\n  const originalLines = source.split('\\n');\n  const lineOffsets = [];\n  for (let i = 0, pos = 0; i < originalLines.length; i++) {\n    lineOffsets.push(pos);\n    pos += originalLines[i].length + 1;\n  }\n  return function locate(index) {\n    let i = 0;\n    let j = lineOffsets.length;\n    while (i < j) {\n      const m = i + j >> 1;\n      if (index < lineOffsets[m]) {\n        j = m;\n      } else {\n        i = m + 1;\n      }\n    }\n    const line = i - 1;\n    const column = index - lineOffsets[line];\n    return {\n      line,\n      column\n    };\n  };\n}\nclass Mappings {\n  constructor(hires) {\n    this.hires = hires;\n    this.generatedCodeLine = 0;\n    this.generatedCodeColumn = 0;\n    this.raw = [];\n    this.rawSegments = this.raw[this.generatedCodeLine] = [];\n    this.pending = null;\n  }\n  addEdit(sourceIndex, content, loc, nameIndex) {\n    if (content.length) {\n      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n      if (nameIndex >= 0) {\n        segment.push(nameIndex);\n      }\n      this.rawSegments.push(segment);\n    } else if (this.pending) {\n      this.rawSegments.push(this.pending);\n    }\n    this.advance(content);\n    this.pending = null;\n  }\n  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n    let originalCharIndex = chunk.start;\n    let first = true;\n    while (originalCharIndex < chunk.end) {\n      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n        this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n      }\n      if (original[originalCharIndex] === '\\n') {\n        loc.line += 1;\n        loc.column = 0;\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        first = true;\n      } else {\n        loc.column += 1;\n        this.generatedCodeColumn += 1;\n        first = false;\n      }\n      originalCharIndex += 1;\n    }\n    this.pending = null;\n  }\n  advance(str) {\n    if (!str) return;\n    const lines = str.split('\\n');\n    if (lines.length > 1) {\n      for (let i = 0; i < lines.length - 1; i++) {\n        this.generatedCodeLine++;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      }\n      this.generatedCodeColumn = 0;\n    }\n    this.generatedCodeColumn += lines[lines.length - 1].length;\n  }\n}\nconst n = '\\n';\nconst warned = {\n  insertLeft: false,\n  insertRight: false,\n  storeName: false\n};\nclass MagicString {\n  constructor(string, options = {}) {\n    const chunk = new Chunk(0, string.length, string);\n    Object.defineProperties(this, {\n      original: {\n        writable: true,\n        value: string\n      },\n      outro: {\n        writable: true,\n        value: ''\n      },\n      intro: {\n        writable: true,\n        value: ''\n      },\n      firstChunk: {\n        writable: true,\n        value: chunk\n      },\n      lastChunk: {\n        writable: true,\n        value: chunk\n      },\n      lastSearchedChunk: {\n        writable: true,\n        value: chunk\n      },\n      byStart: {\n        writable: true,\n        value: {}\n      },\n      byEnd: {\n        writable: true,\n        value: {}\n      },\n      filename: {\n        writable: true,\n        value: options.filename\n      },\n      indentExclusionRanges: {\n        writable: true,\n        value: options.indentExclusionRanges\n      },\n      sourcemapLocations: {\n        writable: true,\n        value: new BitSet()\n      },\n      storedNames: {\n        writable: true,\n        value: {}\n      },\n      indentStr: {\n        writable: true,\n        value: undefined\n      }\n    });\n    this.byStart[0] = chunk;\n    this.byEnd[string.length] = chunk;\n  }\n  addSourcemapLocation(char) {\n    this.sourcemapLocations.add(char);\n  }\n  append(content) {\n    if (typeof content !== 'string') throw new TypeError('outro content must be a string');\n    this.outro += content;\n    return this;\n  }\n  appendLeft(index, content) {\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n    this._split(index);\n    const chunk = this.byEnd[index];\n    if (chunk) {\n      chunk.appendLeft(content);\n    } else {\n      this.intro += content;\n    }\n    return this;\n  }\n  appendRight(index, content) {\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n    this._split(index);\n    const chunk = this.byStart[index];\n    if (chunk) {\n      chunk.appendRight(content);\n    } else {\n      this.outro += content;\n    }\n    return this;\n  }\n  clone() {\n    const cloned = new MagicString(this.original, {\n      filename: this.filename\n    });\n    let originalChunk = this.firstChunk;\n    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n    while (originalChunk) {\n      cloned.byStart[clonedChunk.start] = clonedChunk;\n      cloned.byEnd[clonedChunk.end] = clonedChunk;\n      const nextOriginalChunk = originalChunk.next;\n      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n      if (nextClonedChunk) {\n        clonedChunk.next = nextClonedChunk;\n        nextClonedChunk.previous = clonedChunk;\n        clonedChunk = nextClonedChunk;\n      }\n      originalChunk = nextOriginalChunk;\n    }\n    cloned.lastChunk = clonedChunk;\n    if (this.indentExclusionRanges) {\n      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n    }\n    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n    cloned.intro = this.intro;\n    cloned.outro = this.outro;\n    return cloned;\n  }\n  generateDecodedMap(options) {\n    options = options || {};\n    const sourceIndex = 0;\n    const names = Object.keys(this.storedNames);\n    const mappings = new Mappings(options.hires);\n    const locate = getLocator(this.original);\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n    this.firstChunk.eachNext(chunk => {\n      const loc = locate(chunk.start);\n      if (chunk.intro.length) mappings.advance(chunk.intro);\n      if (chunk.edited) {\n        mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n      } else {\n        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n      }\n      if (chunk.outro.length) mappings.advance(chunk.outro);\n    });\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n      sources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n      sourcesContent: options.includeContent ? [this.original] : [null],\n      names,\n      mappings: mappings.raw\n    };\n  }\n  generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  }\n  _ensureindentStr() {\n    if (this.indentStr === undefined) {\n      this.indentStr = guessIndent(this.original);\n    }\n  }\n  _getRawIndentString() {\n    this._ensureindentStr();\n    return this.indentStr;\n  }\n  getIndentString() {\n    this._ensureindentStr();\n    return this.indentStr === null ? '\\t' : this.indentStr;\n  }\n  indent(indentStr, options) {\n    const pattern = /^[^\\r\\n]/gm;\n    if (isObject(indentStr)) {\n      options = indentStr;\n      indentStr = undefined;\n    }\n    if (indentStr === undefined) {\n      this._ensureindentStr();\n      indentStr = this.indentStr || '\\t';\n    }\n    if (indentStr === '') return this; // noop\n\n    options = options || {};\n\n    // Process exclusion ranges\n    const isExcluded = {};\n    if (options.exclude) {\n      const exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n      exclusions.forEach(exclusion => {\n        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n          isExcluded[i] = true;\n        }\n      });\n    }\n    let shouldIndentNextCharacter = options.indentStart !== false;\n    const replacer = match => {\n      if (shouldIndentNextCharacter) return `${indentStr}${match}`;\n      shouldIndentNextCharacter = true;\n      return match;\n    };\n    this.intro = this.intro.replace(pattern, replacer);\n    let charIndex = 0;\n    let chunk = this.firstChunk;\n    while (chunk) {\n      const end = chunk.end;\n      if (chunk.edited) {\n        if (!isExcluded[charIndex]) {\n          chunk.content = chunk.content.replace(pattern, replacer);\n          if (chunk.content.length) {\n            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n          }\n        }\n      } else {\n        charIndex = chunk.start;\n        while (charIndex < end) {\n          if (!isExcluded[charIndex]) {\n            const char = this.original[charIndex];\n            if (char === '\\n') {\n              shouldIndentNextCharacter = true;\n            } else if (char !== '\\r' && shouldIndentNextCharacter) {\n              shouldIndentNextCharacter = false;\n              if (charIndex === chunk.start) {\n                chunk.prependRight(indentStr);\n              } else {\n                this._splitChunk(chunk, charIndex);\n                chunk = chunk.next;\n                chunk.prependRight(indentStr);\n              }\n            }\n          }\n          charIndex += 1;\n        }\n      }\n      charIndex = chunk.end;\n      chunk = chunk.next;\n    }\n    this.outro = this.outro.replace(pattern, replacer);\n    return this;\n  }\n  insert() {\n    throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n  }\n  insertLeft(index, content) {\n    if (!warned.insertLeft) {\n      console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n      warned.insertLeft = true;\n    }\n    return this.appendLeft(index, content);\n  }\n  insertRight(index, content) {\n    if (!warned.insertRight) {\n      console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n      warned.insertRight = true;\n    }\n    return this.prependRight(index, content);\n  }\n  move(start, end, index) {\n    if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n    this._split(start);\n    this._split(end);\n    this._split(index);\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    const oldLeft = first.previous;\n    const oldRight = last.next;\n    const newRight = this.byStart[index];\n    if (!newRight && last === this.lastChunk) return this;\n    const newLeft = newRight ? newRight.previous : this.lastChunk;\n    if (oldLeft) oldLeft.next = oldRight;\n    if (oldRight) oldRight.previous = oldLeft;\n    if (newLeft) newLeft.next = first;\n    if (newRight) newRight.previous = last;\n    if (!first.previous) this.firstChunk = last.next;\n    if (!last.next) {\n      this.lastChunk = first.previous;\n      this.lastChunk.next = null;\n    }\n    first.previous = newLeft;\n    last.next = newRight || null;\n    if (!newLeft) this.firstChunk = first;\n    if (!newRight) this.lastChunk = last;\n    return this;\n  }\n  overwrite(start, end, content, options) {\n    options = options || {};\n    return this.update(start, end, content, {\n      ...options,\n      overwrite: !options.contentOnly\n    });\n  }\n  update(start, end, content, options) {\n    if (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n    while (start < 0) start += this.original.length;\n    while (end < 0) end += this.original.length;\n    if (end > this.original.length) throw new Error('end is out of bounds');\n    if (start === end) throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');\n    this._split(start);\n    this._split(end);\n    if (options === true) {\n      if (!warned.storeName) {\n        console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n        warned.storeName = true;\n      }\n      options = {\n        storeName: true\n      };\n    }\n    const storeName = options !== undefined ? options.storeName : false;\n    const overwrite = options !== undefined ? options.overwrite : false;\n    if (storeName) {\n      const original = this.original.slice(start, end);\n      Object.defineProperty(this.storedNames, original, {\n        writable: true,\n        value: true,\n        enumerable: true\n      });\n    }\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    if (first) {\n      let chunk = first;\n      while (chunk !== last) {\n        if (chunk.next !== this.byStart[chunk.end]) {\n          throw new Error('Cannot overwrite across a split point');\n        }\n        chunk = chunk.next;\n        chunk.edit('', false);\n      }\n      first.edit(content, storeName, !overwrite);\n    } else {\n      // must be inserting at the end\n      const newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n      // TODO last chunk in the array may not be the last chunk, if it's moved...\n      last.next = newChunk;\n      newChunk.previous = last;\n    }\n    return this;\n  }\n  prepend(content) {\n    if (typeof content !== 'string') throw new TypeError('outro content must be a string');\n    this.intro = content + this.intro;\n    return this;\n  }\n  prependLeft(index, content) {\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n    this._split(index);\n    const chunk = this.byEnd[index];\n    if (chunk) {\n      chunk.prependLeft(content);\n    } else {\n      this.intro = content + this.intro;\n    }\n    return this;\n  }\n  prependRight(index, content) {\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n    this._split(index);\n    const chunk = this.byStart[index];\n    if (chunk) {\n      chunk.prependRight(content);\n    } else {\n      this.outro = content + this.outro;\n    }\n    return this;\n  }\n  remove(start, end) {\n    while (start < 0) start += this.original.length;\n    while (end < 0) end += this.original.length;\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n    if (start > end) throw new Error('end must be greater than start');\n    this._split(start);\n    this._split(end);\n    let chunk = this.byStart[start];\n    while (chunk) {\n      chunk.intro = '';\n      chunk.outro = '';\n      chunk.edit('');\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n    return this;\n  }\n  lastChar() {\n    if (this.outro.length) return this.outro[this.outro.length - 1];\n    let chunk = this.lastChunk;\n    do {\n      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n      if (chunk.content.length) return chunk.content[chunk.content.length - 1];\n      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n    } while (chunk = chunk.previous);\n    if (this.intro.length) return this.intro[this.intro.length - 1];\n    return '';\n  }\n  lastLine() {\n    let lineIndex = this.outro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n    let lineStr = this.outro;\n    let chunk = this.lastChunk;\n    do {\n      if (chunk.outro.length > 0) {\n        lineIndex = chunk.outro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.outro + lineStr;\n      }\n      if (chunk.content.length > 0) {\n        lineIndex = chunk.content.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.content + lineStr;\n      }\n      if (chunk.intro.length > 0) {\n        lineIndex = chunk.intro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.intro + lineStr;\n      }\n    } while (chunk = chunk.previous);\n    lineIndex = this.intro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n    return this.intro + lineStr;\n  }\n  slice(start = 0, end = this.original.length) {\n    while (start < 0) start += this.original.length;\n    while (end < 0) end += this.original.length;\n    let result = '';\n\n    // find start chunk\n    let chunk = this.firstChunk;\n    while (chunk && (chunk.start > start || chunk.end <= start)) {\n      // found end chunk before start\n      if (chunk.start < end && chunk.end >= end) {\n        return result;\n      }\n      chunk = chunk.next;\n    }\n    if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n    const startChunk = chunk;\n    while (chunk) {\n      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n        result += chunk.intro;\n      }\n      const containsEnd = chunk.start < end && chunk.end >= end;\n      if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n      const sliceStart = startChunk === chunk ? start - chunk.start : 0;\n      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n      result += chunk.content.slice(sliceStart, sliceEnd);\n      if (chunk.outro && (!containsEnd || chunk.end === end)) {\n        result += chunk.outro;\n      }\n      if (containsEnd) {\n        break;\n      }\n      chunk = chunk.next;\n    }\n    return result;\n  }\n\n  // TODO deprecate this? not really very useful\n  snip(start, end) {\n    const clone = this.clone();\n    clone.remove(0, start);\n    clone.remove(end, clone.original.length);\n    return clone;\n  }\n  _split(index) {\n    if (this.byStart[index] || this.byEnd[index]) return;\n    let chunk = this.lastSearchedChunk;\n    const searchForward = index > chunk.end;\n    while (chunk) {\n      if (chunk.contains(index)) return this._splitChunk(chunk, index);\n      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n    }\n  }\n  _splitChunk(chunk, index) {\n    if (chunk.edited && chunk.content.length) {\n      // zero-length edited chunks are a special case (overlapping replacements)\n      const loc = getLocator(this.original)(index);\n      throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`);\n    }\n    const newChunk = chunk.split(index);\n    this.byEnd[index] = chunk;\n    this.byStart[index] = newChunk;\n    this.byEnd[newChunk.end] = newChunk;\n    if (chunk === this.lastChunk) this.lastChunk = newChunk;\n    this.lastSearchedChunk = chunk;\n    return true;\n  }\n  toString() {\n    let str = this.intro;\n    let chunk = this.firstChunk;\n    while (chunk) {\n      str += chunk.toString();\n      chunk = chunk.next;\n    }\n    return str + this.outro;\n  }\n  isEmpty() {\n    let chunk = this.firstChunk;\n    do {\n      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;\n    } while (chunk = chunk.next);\n    return true;\n  }\n  length() {\n    let chunk = this.firstChunk;\n    let length = 0;\n    do {\n      length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n    } while (chunk = chunk.next);\n    return length;\n  }\n  trimLines() {\n    return this.trim('[\\\\r\\\\n]');\n  }\n  trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  }\n  trimEndAborted(charType) {\n    const rx = new RegExp((charType || '\\\\s') + '+$');\n    this.outro = this.outro.replace(rx, '');\n    if (this.outro.length) return true;\n    let chunk = this.lastChunk;\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimEnd(rx);\n\n      // if chunk was trimmed, we have a new lastChunk\n      if (chunk.end !== end) {\n        if (this.lastChunk === chunk) {\n          this.lastChunk = chunk.next;\n        }\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n      if (aborted) return true;\n      chunk = chunk.previous;\n    } while (chunk);\n    return false;\n  }\n  trimEnd(charType) {\n    this.trimEndAborted(charType);\n    return this;\n  }\n  trimStartAborted(charType) {\n    const rx = new RegExp('^' + (charType || '\\\\s') + '+');\n    this.intro = this.intro.replace(rx, '');\n    if (this.intro.length) return true;\n    let chunk = this.firstChunk;\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimStart(rx);\n      if (chunk.end !== end) {\n        // special case...\n        if (chunk === this.lastChunk) this.lastChunk = chunk.next;\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n      if (aborted) return true;\n      chunk = chunk.next;\n    } while (chunk);\n    return false;\n  }\n  trimStart(charType) {\n    this.trimStartAborted(charType);\n    return this;\n  }\n  hasChanged() {\n    return this.original !== this.toString();\n  }\n  _replaceRegexp(searchValue, replacement) {\n    function getReplacement(match, str) {\n      if (typeof replacement === 'string') {\n        return replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n          if (i === '$') return '$';\n          if (i === '&') return match[0];\n          const num = +i;\n          if (num < match.length) return match[+i];\n          return `$${i}`;\n        });\n      } else {\n        return replacement(...match, match.index, str, match.groups);\n      }\n    }\n    function matchAll(re, str) {\n      let match;\n      const matches = [];\n      while (match = re.exec(str)) {\n        matches.push(match);\n      }\n      return matches;\n    }\n    if (searchValue.global) {\n      const matches = matchAll(searchValue, this.original);\n      matches.forEach(match => {\n        if (match.index != null) this.overwrite(match.index, match.index + match[0].length, getReplacement(match, this.original));\n      });\n    } else {\n      const match = this.original.match(searchValue);\n      if (match && match.index != null) this.overwrite(match.index, match.index + match[0].length, getReplacement(match, this.original));\n    }\n    return this;\n  }\n  _replaceString(string, replacement) {\n    const {\n      original\n    } = this;\n    const index = original.indexOf(string);\n    if (index !== -1) {\n      this.overwrite(index, index + string.length, replacement);\n    }\n    return this;\n  }\n  replace(searchValue, replacement) {\n    if (typeof searchValue === 'string') {\n      return this._replaceString(searchValue, replacement);\n    }\n    return this._replaceRegexp(searchValue, replacement);\n  }\n  _replaceAllString(string, replacement) {\n    const {\n      original\n    } = this;\n    const stringLength = string.length;\n    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {\n      this.overwrite(index, index + stringLength, replacement);\n    }\n    return this;\n  }\n  replaceAll(searchValue, replacement) {\n    if (typeof searchValue === 'string') {\n      return this._replaceAllString(searchValue, replacement);\n    }\n    if (!searchValue.global) {\n      throw new TypeError('MagicString.prototype.replaceAll called with a non-global RegExp argument');\n    }\n    return this._replaceRegexp(searchValue, replacement);\n  }\n}\nconst hasOwnProp = Object.prototype.hasOwnProperty;\nclass Bundle {\n  constructor(options = {}) {\n    this.intro = options.intro || '';\n    this.separator = options.separator !== undefined ? options.separator : '\\n';\n    this.sources = [];\n    this.uniqueSources = [];\n    this.uniqueSourceIndexByFilename = {};\n  }\n  addSource(source) {\n    if (source instanceof MagicString) {\n      return this.addSource({\n        content: source,\n        filename: source.filename,\n        separator: this.separator\n      });\n    }\n    if (!isObject(source) || !source.content) {\n      throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n    }\n    ['filename', 'indentExclusionRanges', 'separator'].forEach(option => {\n      if (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n    });\n    if (source.separator === undefined) {\n      // TODO there's a bunch of this sort of thing, needs cleaning up\n      source.separator = this.separator;\n    }\n    if (source.filename) {\n      if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n        this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n        this.uniqueSources.push({\n          filename: source.filename,\n          content: source.content.original\n        });\n      } else {\n        const uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n        if (source.content.original !== uniqueSource.content) {\n          throw new Error(`Illegal source: same filename (${source.filename}), different contents`);\n        }\n      }\n    }\n    this.sources.push(source);\n    return this;\n  }\n  append(str, options) {\n    this.addSource({\n      content: new MagicString(str),\n      separator: options && options.separator || ''\n    });\n    return this;\n  }\n  clone() {\n    const bundle = new Bundle({\n      intro: this.intro,\n      separator: this.separator\n    });\n    this.sources.forEach(source => {\n      bundle.addSource({\n        filename: source.filename,\n        content: source.content.clone(),\n        separator: source.separator\n      });\n    });\n    return bundle;\n  }\n  generateDecodedMap(options = {}) {\n    const names = [];\n    this.sources.forEach(source => {\n      Object.keys(source.content.storedNames).forEach(name => {\n        if (!~names.indexOf(name)) names.push(name);\n      });\n    });\n    const mappings = new Mappings(options.hires);\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n    this.sources.forEach((source, i) => {\n      if (i > 0) {\n        mappings.advance(this.separator);\n      }\n      const sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n      const magicString = source.content;\n      const locate = getLocator(magicString.original);\n      if (magicString.intro) {\n        mappings.advance(magicString.intro);\n      }\n      magicString.firstChunk.eachNext(chunk => {\n        const loc = locate(chunk.start);\n        if (chunk.intro.length) mappings.advance(chunk.intro);\n        if (source.filename) {\n          if (chunk.edited) {\n            mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n          } else {\n            mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);\n          }\n        } else {\n          mappings.advance(chunk.content);\n        }\n        if (chunk.outro.length) mappings.advance(chunk.outro);\n      });\n      if (magicString.outro) {\n        mappings.advance(magicString.outro);\n      }\n    });\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n      sources: this.uniqueSources.map(source => {\n        return options.file ? getRelativePath(options.file, source.filename) : source.filename;\n      }),\n      sourcesContent: this.uniqueSources.map(source => {\n        return options.includeContent ? source.content : null;\n      }),\n      names,\n      mappings: mappings.raw\n    };\n  }\n  generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  }\n  getIndentString() {\n    const indentStringCounts = {};\n    this.sources.forEach(source => {\n      const indentStr = source.content._getRawIndentString();\n      if (indentStr === null) return;\n      if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n      indentStringCounts[indentStr] += 1;\n    });\n    return Object.keys(indentStringCounts).sort((a, b) => {\n      return indentStringCounts[a] - indentStringCounts[b];\n    })[0] || '\\t';\n  }\n  indent(indentStr) {\n    if (!arguments.length) {\n      indentStr = this.getIndentString();\n    }\n    if (indentStr === '') return this; // noop\n\n    let trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n    this.sources.forEach((source, i) => {\n      const separator = source.separator !== undefined ? source.separator : this.separator;\n      const indentStart = trailingNewline || i > 0 && /\\r?\\n$/.test(separator);\n      source.content.indent(indentStr, {\n        exclude: source.indentExclusionRanges,\n        indentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n      });\n\n      trailingNewline = source.content.lastChar() === '\\n';\n    });\n    if (this.intro) {\n      this.intro = indentStr + this.intro.replace(/^[^\\n]/gm, (match, index) => {\n        return index > 0 ? indentStr + match : match;\n      });\n    }\n    return this;\n  }\n  prepend(str) {\n    this.intro = str + this.intro;\n    return this;\n  }\n  toString() {\n    const body = this.sources.map((source, i) => {\n      const separator = source.separator !== undefined ? source.separator : this.separator;\n      const str = (i > 0 ? separator : '') + source.content.toString();\n      return str;\n    }).join('');\n    return this.intro + body;\n  }\n  isEmpty() {\n    if (this.intro.length && this.intro.trim()) return false;\n    if (this.sources.some(source => !source.content.isEmpty())) return false;\n    return true;\n  }\n  length() {\n    return this.sources.reduce((length, source) => length + source.content.length(), this.intro.length);\n  }\n  trimLines() {\n    return this.trim('[\\\\r\\\\n]');\n  }\n  trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  }\n  trimStart(charType) {\n    const rx = new RegExp('^' + (charType || '\\\\s') + '+');\n    this.intro = this.intro.replace(rx, '');\n    if (!this.intro) {\n      let source;\n      let i = 0;\n      do {\n        source = this.sources[i++];\n        if (!source) {\n          break;\n        }\n      } while (!source.content.trimStartAborted(charType));\n    }\n    return this;\n  }\n  trimEnd(charType) {\n    const rx = new RegExp((charType || '\\\\s') + '+$');\n    let source;\n    let i = this.sources.length - 1;\n    do {\n      source = this.sources[i--];\n      if (!source) {\n        this.intro = this.intro.replace(rx, '');\n        break;\n      }\n    } while (!source.content.trimEndAborted(charType));\n    return this;\n  }\n}\nMagicString.Bundle = Bundle;\nMagicString.SourceMap = SourceMap;\nMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\n\nmodule.exports = MagicString;","map":{"version":3,"names":["sourcemapCodec","require","BitSet","constructor","arg","bits","slice","add","n","has","Chunk","start","end","content","original","intro","outro","storeName","edited","previous","next","appendLeft","appendRight","clone","chunk","contains","index","eachNext","fn","eachPrevious","edit","contentOnly","prependLeft","prependRight","split","sliceIndex","originalBefore","originalAfter","newChunk","toString","trimEnd","rx","replace","length","trimmed","undefined","trimStart","getBtoa","window","btoa","str","unescape","encodeURIComponent","Buffer","from","Error","SourceMap","properties","version","file","sources","sourcesContent","names","mappings","encode","JSON","stringify","toUrl","guessIndent","code","lines","tabbed","filter","line","test","spaced","min","reduce","current","numSpaces","exec","Math","Infinity","Array","join","getRelativePath","to","fromParts","toParts","pop","shift","i","concat","Object","prototype","isObject","thing","call","getLocator","source","originalLines","lineOffsets","pos","push","locate","j","m","column","Mappings","hires","generatedCodeLine","generatedCodeColumn","raw","rawSegments","pending","addEdit","sourceIndex","loc","nameIndex","segment","advance","addUneditedChunk","sourcemapLocations","originalCharIndex","first","warned","insertLeft","insertRight","MagicString","string","options","defineProperties","writable","value","firstChunk","lastChunk","lastSearchedChunk","byStart","byEnd","filename","indentExclusionRanges","storedNames","indentStr","addSourcemapLocation","char","append","TypeError","_split","cloned","originalChunk","clonedChunk","nextOriginalChunk","nextClonedChunk","generateDecodedMap","keys","indexOf","includeContent","generateMap","_ensureindentStr","_getRawIndentString","getIndentString","indent","pattern","isExcluded","exclude","exclusions","forEach","exclusion","shouldIndentNextCharacter","indentStart","replacer","match","charIndex","_splitChunk","insert","console","warn","move","last","oldLeft","oldRight","newRight","newLeft","overwrite","update","defineProperty","enumerable","prepend","remove","lastChar","lastLine","lineIndex","lastIndexOf","substr","lineStr","result","startChunk","containsEnd","sliceStart","sliceEnd","snip","searchForward","isEmpty","trim","trimLines","charType","trimEndAborted","RegExp","aborted","trimStartAborted","hasChanged","_replaceRegexp","searchValue","replacement","getReplacement","_","num","groups","matchAll","re","matches","global","_replaceString","_replaceAllString","stringLength","replaceAll","hasOwnProp","hasOwnProperty","Bundle","separator","uniqueSources","uniqueSourceIndexByFilename","addSource","option","uniqueSource","bundle","name","magicString","map","indentStringCounts","sort","a","b","arguments","trailingNewline","body","some","default","module","exports"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular-devkit/schematics/node_modules/magic-string/dist/magic-string.cjs.js"],"sourcesContent":["'use strict';\n\nvar sourcemapCodec = require('@jridgewell/sourcemap-codec');\n\nclass BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n\nclass Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t{\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n\nfunction getBtoa () {\n\tif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\t\treturn (str) => window.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nclass SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = sourcemapCodec.encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n\nfunction guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n\nclass Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nclass MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t});\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'\n\t\t\t);\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null)\n\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t\t);\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null)\n\t\t\t\tthis.overwrite(\n\t\t\t\t\tmatch.index,\n\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\tgetReplacement(match, this.original)\n\t\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tthis.overwrite(index, index + stringLength, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument'\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nclass Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n\nMagicString.Bundle = Bundle;\nMagicString.SourceMap = SourceMap;\nMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\n\nmodule.exports = MagicString;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}