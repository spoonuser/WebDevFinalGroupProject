{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readJsonWorkspace = void 0;\nconst jsonc_parser_1 = require(\"jsonc-parser\");\nconst utils_1 = require(\"../../json/utils\");\nconst definitions_1 = require(\"../definitions\");\nconst metadata_1 = require(\"./metadata\");\nconst utilities_1 = require(\"./utilities\");\nconst ANGULAR_WORKSPACE_EXTENSIONS = Object.freeze(['cli', 'defaultProject', 'newProjectRoot', 'schematics']);\nconst ANGULAR_PROJECT_EXTENSIONS = Object.freeze(['cli', 'schematics', 'projectType', 'i18n']);\nfunction readJsonWorkspace(_x, _x2) {\n  return _readJsonWorkspace.apply(this, arguments);\n}\nfunction _readJsonWorkspace() {\n  _readJsonWorkspace = _asyncToGenerator(function* (path, host, options = {}) {\n    var _a, _b;\n    const raw = yield host.readFile(path);\n    if (raw === undefined) {\n      throw new Error('Unable to read workspace file.');\n    }\n    const ast = (0, jsonc_parser_1.parseTree)(raw, undefined, {\n      allowTrailingComma: true,\n      disallowComments: false\n    });\n    if ((ast === null || ast === void 0 ? void 0 : ast.type) !== 'object' || !ast.children) {\n      throw new Error('Invalid workspace file - expected JSON object.');\n    }\n    // Version check\n    const versionNode = (0, jsonc_parser_1.findNodeAtLocation)(ast, ['version']);\n    if (!versionNode) {\n      throw new Error('Unknown format - version specifier not found.');\n    }\n    const version = versionNode.value;\n    if (version !== 1) {\n      throw new Error(`Invalid format version detected - Expected:[ 1 ] Found: [ ${version} ]`);\n    }\n    const context = {\n      host,\n      metadata: new metadata_1.JsonWorkspaceMetadata(path, ast, raw),\n      trackChanges: true,\n      unprefixedWorkspaceExtensions: new Set([...ANGULAR_WORKSPACE_EXTENSIONS, ...((_a = options.allowedWorkspaceExtensions) !== null && _a !== void 0 ? _a : [])]),\n      unprefixedProjectExtensions: new Set([...ANGULAR_PROJECT_EXTENSIONS, ...((_b = options.allowedProjectExtensions) !== null && _b !== void 0 ? _b : [])]),\n      error(message, _node) {\n        // TODO: Diagnostic reporting support\n        throw new Error(message);\n      },\n      warn(message, _node) {\n        // TODO: Diagnostic reporting support\n        // eslint-disable-next-line no-console\n        console.warn(message);\n      }\n    };\n    const workspace = parseWorkspace(ast, context);\n    return workspace;\n  });\n  return _readJsonWorkspace.apply(this, arguments);\n}\nexports.readJsonWorkspace = readJsonWorkspace;\nfunction parseWorkspace(workspaceNode, context) {\n  const jsonMetadata = context.metadata;\n  let projects;\n  let extensions;\n  if (!context.trackChanges) {\n    extensions = Object.create(null);\n  }\n  // TODO: `getNodeValue` - looks potentially expensive since it walks the whole tree and instantiates the full object structure each time.\n  // Might be something to look at moving forward to optimize.\n  const workspaceNodeValue = (0, jsonc_parser_1.getNodeValue)(workspaceNode);\n  for (const [name, value] of Object.entries(workspaceNodeValue)) {\n    if (name === '$schema' || name === 'version') {\n      // skip\n    } else if (name === 'projects') {\n      const nodes = (0, jsonc_parser_1.findNodeAtLocation)(workspaceNode, ['projects']);\n      if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n        context.error('Invalid \"projects\" field found; expected an object.', value);\n        continue;\n      }\n      projects = parseProjectsObject(nodes, context);\n    } else {\n      if (!context.unprefixedWorkspaceExtensions.has(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n        context.warn(`Workspace extension with invalid name (${name}) found.`, name);\n      }\n      if (extensions) {\n        extensions[name] = value;\n      }\n    }\n  }\n  let collectionListener;\n  if (context.trackChanges) {\n    collectionListener = (name, newValue) => {\n      jsonMetadata.addChange(['projects', name], newValue, 'project');\n    };\n  }\n  const projectCollection = new definitions_1.ProjectDefinitionCollection(projects, collectionListener);\n  return {\n    [metadata_1.JsonWorkspaceSymbol]: jsonMetadata,\n    projects: projectCollection,\n    // If not tracking changes the `extensions` variable will contain the parsed\n    // values.  Otherwise the extensions are tracked via a virtual AST object.\n    extensions: extensions !== null && extensions !== void 0 ? extensions : (0, utilities_1.createVirtualAstObject)(workspaceNodeValue, {\n      exclude: ['$schema', 'version', 'projects'],\n      listener(path, value) {\n        jsonMetadata.addChange(path, value);\n      }\n    })\n  };\n}\nfunction parseProjectsObject(projectsNode, context) {\n  const projects = Object.create(null);\n  for (const [name, value] of Object.entries((0, jsonc_parser_1.getNodeValue)(projectsNode))) {\n    const nodes = (0, jsonc_parser_1.findNodeAtLocation)(projectsNode, [name]);\n    if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n      context.warn('Skipping invalid project value; expected an object.', value);\n      continue;\n    }\n    projects[name] = parseProject(name, nodes, context);\n  }\n  return projects;\n}\nfunction parseProject(projectName, projectNode, context) {\n  const jsonMetadata = context.metadata;\n  let targets;\n  let hasTargets = false;\n  let extensions;\n  let properties;\n  if (!context.trackChanges) {\n    // If not tracking changes, the parser will store the values directly in standard objects\n    extensions = Object.create(null);\n    properties = Object.create(null);\n  }\n  const projectNodeValue = (0, jsonc_parser_1.getNodeValue)(projectNode);\n  if (!('root' in projectNodeValue)) {\n    throw new Error(`Project \"${projectName}\" is missing a required property \"root\".`);\n  }\n  for (const [name, value] of Object.entries(projectNodeValue)) {\n    switch (name) {\n      case 'targets':\n      case 'architect':\n        const nodes = (0, jsonc_parser_1.findNodeAtLocation)(projectNode, [name]);\n        if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n          context.error(`Invalid \"${name}\" field found; expected an object.`, value);\n          break;\n        }\n        hasTargets = true;\n        targets = parseTargetsObject(projectName, nodes, context);\n        jsonMetadata.hasLegacyTargetsName = name === 'architect';\n        break;\n      case 'prefix':\n      case 'root':\n      case 'sourceRoot':\n        if (typeof value !== 'string') {\n          context.warn(`Project property \"${name}\" should be a string.`, value);\n        }\n        if (properties) {\n          properties[name] = value;\n        }\n        break;\n      default:\n        if (!context.unprefixedProjectExtensions.has(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n          context.warn(`Project '${projectName}' contains extension with invalid name (${name}).`, name);\n        }\n        if (extensions) {\n          extensions[name] = value;\n        }\n        break;\n    }\n  }\n  let collectionListener;\n  if (context.trackChanges) {\n    collectionListener = (name, newValue, collection) => {\n      if (hasTargets) {\n        jsonMetadata.addChange(['projects', projectName, 'targets', name], newValue, 'target');\n      } else {\n        jsonMetadata.addChange(['projects', projectName, 'targets'], collection, 'targetcollection');\n      }\n    };\n  }\n  const base = {\n    targets: new definitions_1.TargetDefinitionCollection(targets, collectionListener),\n    // If not tracking changes the `extensions` variable will contain the parsed\n    // values.  Otherwise the extensions are tracked via a virtual AST object.\n    extensions: extensions !== null && extensions !== void 0 ? extensions : (0, utilities_1.createVirtualAstObject)(projectNodeValue, {\n      exclude: ['architect', 'prefix', 'root', 'sourceRoot', 'targets'],\n      listener(path, value) {\n        jsonMetadata.addChange(['projects', projectName, ...path], value);\n      }\n    })\n  };\n  const baseKeys = new Set(Object.keys(base));\n  const project = properties !== null && properties !== void 0 ? properties : (0, utilities_1.createVirtualAstObject)(projectNodeValue, {\n    include: ['prefix', 'root', 'sourceRoot', ...baseKeys],\n    listener(path, value) {\n      if (!baseKeys.has(path[0])) {\n        jsonMetadata.addChange(['projects', projectName, ...path], value);\n      }\n    }\n  });\n  return Object.assign(project, base);\n}\nfunction parseTargetsObject(projectName, targetsNode, context) {\n  const jsonMetadata = context.metadata;\n  const targets = Object.create(null);\n  for (const [name, value] of Object.entries((0, jsonc_parser_1.getNodeValue)(targetsNode))) {\n    if (!(0, utils_1.isJsonObject)(value)) {\n      context.warn('Skipping invalid target value; expected an object.', value);\n      continue;\n    }\n    if (context.trackChanges) {\n      targets[name] = (0, utilities_1.createVirtualAstObject)(value, {\n        include: ['builder', 'options', 'configurations', 'defaultConfiguration'],\n        listener(path, value) {\n          jsonMetadata.addChange(['projects', projectName, 'targets', name, ...path], value);\n        }\n      });\n    } else {\n      targets[name] = value;\n    }\n  }\n  return targets;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","readJsonWorkspace","jsonc_parser_1","require","utils_1","definitions_1","metadata_1","utilities_1","ANGULAR_WORKSPACE_EXTENSIONS","freeze","ANGULAR_PROJECT_EXTENSIONS","path","host","options","_a","_b","raw","readFile","undefined","Error","ast","parseTree","allowTrailingComma","disallowComments","type","children","versionNode","findNodeAtLocation","version","context","metadata","JsonWorkspaceMetadata","trackChanges","unprefixedWorkspaceExtensions","Set","allowedWorkspaceExtensions","unprefixedProjectExtensions","allowedProjectExtensions","error","message","_node","warn","console","workspace","parseWorkspace","workspaceNode","jsonMetadata","projects","extensions","create","workspaceNodeValue","getNodeValue","name","entries","nodes","isJsonObject","parseProjectsObject","has","test","collectionListener","newValue","addChange","projectCollection","ProjectDefinitionCollection","JsonWorkspaceSymbol","createVirtualAstObject","exclude","listener","projectsNode","parseProject","projectName","projectNode","targets","hasTargets","properties","projectNodeValue","parseTargetsObject","hasLegacyTargetsName","collection","base","TargetDefinitionCollection","baseKeys","keys","project","include","assign","targetsNode"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/node_modules/@angular-devkit/core/src/workspace/json/reader.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readJsonWorkspace = void 0;\nconst jsonc_parser_1 = require(\"jsonc-parser\");\nconst utils_1 = require(\"../../json/utils\");\nconst definitions_1 = require(\"../definitions\");\nconst metadata_1 = require(\"./metadata\");\nconst utilities_1 = require(\"./utilities\");\nconst ANGULAR_WORKSPACE_EXTENSIONS = Object.freeze([\n    'cli',\n    'defaultProject',\n    'newProjectRoot',\n    'schematics',\n]);\nconst ANGULAR_PROJECT_EXTENSIONS = Object.freeze(['cli', 'schematics', 'projectType', 'i18n']);\nasync function readJsonWorkspace(path, host, options = {}) {\n    var _a, _b;\n    const raw = await host.readFile(path);\n    if (raw === undefined) {\n        throw new Error('Unable to read workspace file.');\n    }\n    const ast = (0, jsonc_parser_1.parseTree)(raw, undefined, { allowTrailingComma: true, disallowComments: false });\n    if ((ast === null || ast === void 0 ? void 0 : ast.type) !== 'object' || !ast.children) {\n        throw new Error('Invalid workspace file - expected JSON object.');\n    }\n    // Version check\n    const versionNode = (0, jsonc_parser_1.findNodeAtLocation)(ast, ['version']);\n    if (!versionNode) {\n        throw new Error('Unknown format - version specifier not found.');\n    }\n    const version = versionNode.value;\n    if (version !== 1) {\n        throw new Error(`Invalid format version detected - Expected:[ 1 ] Found: [ ${version} ]`);\n    }\n    const context = {\n        host,\n        metadata: new metadata_1.JsonWorkspaceMetadata(path, ast, raw),\n        trackChanges: true,\n        unprefixedWorkspaceExtensions: new Set([\n            ...ANGULAR_WORKSPACE_EXTENSIONS,\n            ...((_a = options.allowedWorkspaceExtensions) !== null && _a !== void 0 ? _a : []),\n        ]),\n        unprefixedProjectExtensions: new Set([\n            ...ANGULAR_PROJECT_EXTENSIONS,\n            ...((_b = options.allowedProjectExtensions) !== null && _b !== void 0 ? _b : []),\n        ]),\n        error(message, _node) {\n            // TODO: Diagnostic reporting support\n            throw new Error(message);\n        },\n        warn(message, _node) {\n            // TODO: Diagnostic reporting support\n            // eslint-disable-next-line no-console\n            console.warn(message);\n        },\n    };\n    const workspace = parseWorkspace(ast, context);\n    return workspace;\n}\nexports.readJsonWorkspace = readJsonWorkspace;\nfunction parseWorkspace(workspaceNode, context) {\n    const jsonMetadata = context.metadata;\n    let projects;\n    let extensions;\n    if (!context.trackChanges) {\n        extensions = Object.create(null);\n    }\n    // TODO: `getNodeValue` - looks potentially expensive since it walks the whole tree and instantiates the full object structure each time.\n    // Might be something to look at moving forward to optimize.\n    const workspaceNodeValue = (0, jsonc_parser_1.getNodeValue)(workspaceNode);\n    for (const [name, value] of Object.entries(workspaceNodeValue)) {\n        if (name === '$schema' || name === 'version') {\n            // skip\n        }\n        else if (name === 'projects') {\n            const nodes = (0, jsonc_parser_1.findNodeAtLocation)(workspaceNode, ['projects']);\n            if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n                context.error('Invalid \"projects\" field found; expected an object.', value);\n                continue;\n            }\n            projects = parseProjectsObject(nodes, context);\n        }\n        else {\n            if (!context.unprefixedWorkspaceExtensions.has(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n                context.warn(`Workspace extension with invalid name (${name}) found.`, name);\n            }\n            if (extensions) {\n                extensions[name] = value;\n            }\n        }\n    }\n    let collectionListener;\n    if (context.trackChanges) {\n        collectionListener = (name, newValue) => {\n            jsonMetadata.addChange(['projects', name], newValue, 'project');\n        };\n    }\n    const projectCollection = new definitions_1.ProjectDefinitionCollection(projects, collectionListener);\n    return {\n        [metadata_1.JsonWorkspaceSymbol]: jsonMetadata,\n        projects: projectCollection,\n        // If not tracking changes the `extensions` variable will contain the parsed\n        // values.  Otherwise the extensions are tracked via a virtual AST object.\n        extensions: extensions !== null && extensions !== void 0 ? extensions : (0, utilities_1.createVirtualAstObject)(workspaceNodeValue, {\n            exclude: ['$schema', 'version', 'projects'],\n            listener(path, value) {\n                jsonMetadata.addChange(path, value);\n            },\n        }),\n    };\n}\nfunction parseProjectsObject(projectsNode, context) {\n    const projects = Object.create(null);\n    for (const [name, value] of Object.entries((0, jsonc_parser_1.getNodeValue)(projectsNode))) {\n        const nodes = (0, jsonc_parser_1.findNodeAtLocation)(projectsNode, [name]);\n        if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n            context.warn('Skipping invalid project value; expected an object.', value);\n            continue;\n        }\n        projects[name] = parseProject(name, nodes, context);\n    }\n    return projects;\n}\nfunction parseProject(projectName, projectNode, context) {\n    const jsonMetadata = context.metadata;\n    let targets;\n    let hasTargets = false;\n    let extensions;\n    let properties;\n    if (!context.trackChanges) {\n        // If not tracking changes, the parser will store the values directly in standard objects\n        extensions = Object.create(null);\n        properties = Object.create(null);\n    }\n    const projectNodeValue = (0, jsonc_parser_1.getNodeValue)(projectNode);\n    if (!('root' in projectNodeValue)) {\n        throw new Error(`Project \"${projectName}\" is missing a required property \"root\".`);\n    }\n    for (const [name, value] of Object.entries(projectNodeValue)) {\n        switch (name) {\n            case 'targets':\n            case 'architect':\n                const nodes = (0, jsonc_parser_1.findNodeAtLocation)(projectNode, [name]);\n                if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n                    context.error(`Invalid \"${name}\" field found; expected an object.`, value);\n                    break;\n                }\n                hasTargets = true;\n                targets = parseTargetsObject(projectName, nodes, context);\n                jsonMetadata.hasLegacyTargetsName = name === 'architect';\n                break;\n            case 'prefix':\n            case 'root':\n            case 'sourceRoot':\n                if (typeof value !== 'string') {\n                    context.warn(`Project property \"${name}\" should be a string.`, value);\n                }\n                if (properties) {\n                    properties[name] = value;\n                }\n                break;\n            default:\n                if (!context.unprefixedProjectExtensions.has(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n                    context.warn(`Project '${projectName}' contains extension with invalid name (${name}).`, name);\n                }\n                if (extensions) {\n                    extensions[name] = value;\n                }\n                break;\n        }\n    }\n    let collectionListener;\n    if (context.trackChanges) {\n        collectionListener = (name, newValue, collection) => {\n            if (hasTargets) {\n                jsonMetadata.addChange(['projects', projectName, 'targets', name], newValue, 'target');\n            }\n            else {\n                jsonMetadata.addChange(['projects', projectName, 'targets'], collection, 'targetcollection');\n            }\n        };\n    }\n    const base = {\n        targets: new definitions_1.TargetDefinitionCollection(targets, collectionListener),\n        // If not tracking changes the `extensions` variable will contain the parsed\n        // values.  Otherwise the extensions are tracked via a virtual AST object.\n        extensions: extensions !== null && extensions !== void 0 ? extensions : (0, utilities_1.createVirtualAstObject)(projectNodeValue, {\n            exclude: ['architect', 'prefix', 'root', 'sourceRoot', 'targets'],\n            listener(path, value) {\n                jsonMetadata.addChange(['projects', projectName, ...path], value);\n            },\n        }),\n    };\n    const baseKeys = new Set(Object.keys(base));\n    const project = properties !== null && properties !== void 0 ? properties : (0, utilities_1.createVirtualAstObject)(projectNodeValue, {\n        include: ['prefix', 'root', 'sourceRoot', ...baseKeys],\n        listener(path, value) {\n            if (!baseKeys.has(path[0])) {\n                jsonMetadata.addChange(['projects', projectName, ...path], value);\n            }\n        },\n    });\n    return Object.assign(project, base);\n}\nfunction parseTargetsObject(projectName, targetsNode, context) {\n    const jsonMetadata = context.metadata;\n    const targets = Object.create(null);\n    for (const [name, value] of Object.entries((0, jsonc_parser_1.getNodeValue)(targetsNode))) {\n        if (!(0, utils_1.isJsonObject)(value)) {\n            context.warn('Skipping invalid target value; expected an object.', value);\n            continue;\n        }\n        if (context.trackChanges) {\n            targets[name] = (0, utilities_1.createVirtualAstObject)(value, {\n                include: ['builder', 'options', 'configurations', 'defaultConfiguration'],\n                listener(path, value) {\n                    jsonMetadata.addChange(['projects', projectName, 'targets', name, ...path], value);\n                },\n            });\n        }\n        else {\n            targets[name] = value;\n        }\n    }\n    return targets;\n}\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAOAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,iBAAiB,GAAG,KAAK,CAAC;AAClC,MAAMC,cAAc,GAAGC,OAAO,CAAC,cAAc,CAAC;AAC9C,MAAMC,OAAO,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AAC3C,MAAME,aAAa,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AAC/C,MAAMG,UAAU,GAAGH,OAAO,CAAC,YAAY,CAAC;AACxC,MAAMI,WAAW,GAAGJ,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMK,4BAA4B,GAAGX,MAAM,CAACY,MAAM,CAAC,CAC/C,KAAK,EACL,gBAAgB,EAChB,gBAAgB,EAChB,YAAY,CACf,CAAC;AACF,MAAMC,0BAA0B,GAAGb,MAAM,CAACY,MAAM,CAAC,CAAC,KAAK,EAAE,YAAY,EAAE,aAAa,EAAE,MAAM,CAAC,CAAC;AAAC,SAChFR,iBAAiB;EAAA;AAAA;AAAA;EAAA,uCAAhC,WAAiCU,IAAI,EAAEC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IACvD,IAAIC,EAAE,EAAEC,EAAE;IACV,MAAMC,GAAG,SAASJ,IAAI,CAACK,QAAQ,CAACN,IAAI,CAAC;IACrC,IAAIK,GAAG,KAAKE,SAAS,EAAE;MACnB,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;IACrD;IACA,MAAMC,GAAG,GAAG,CAAC,CAAC,EAAElB,cAAc,CAACmB,SAAS,EAAEL,GAAG,EAAEE,SAAS,EAAE;MAAEI,kBAAkB,EAAE,IAAI;MAAEC,gBAAgB,EAAE;IAAM,CAAC,CAAC;IAChH,IAAI,CAACH,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,GAAG,CAACI,IAAI,MAAM,QAAQ,IAAI,CAACJ,GAAG,CAACK,QAAQ,EAAE;MACpF,MAAM,IAAIN,KAAK,CAAC,gDAAgD,CAAC;IACrE;IACA;IACA,MAAMO,WAAW,GAAG,CAAC,CAAC,EAAExB,cAAc,CAACyB,kBAAkB,EAAEP,GAAG,EAAE,CAAC,SAAS,CAAC,CAAC;IAC5E,IAAI,CAACM,WAAW,EAAE;MACd,MAAM,IAAIP,KAAK,CAAC,+CAA+C,CAAC;IACpE;IACA,MAAMS,OAAO,GAAGF,WAAW,CAAC1B,KAAK;IACjC,IAAI4B,OAAO,KAAK,CAAC,EAAE;MACf,MAAM,IAAIT,KAAK,CAAE,6DAA4DS,OAAQ,IAAG,CAAC;IAC7F;IACA,MAAMC,OAAO,GAAG;MACZjB,IAAI;MACJkB,QAAQ,EAAE,IAAIxB,UAAU,CAACyB,qBAAqB,CAACpB,IAAI,EAAES,GAAG,EAAEJ,GAAG,CAAC;MAC9DgB,YAAY,EAAE,IAAI;MAClBC,6BAA6B,EAAE,IAAIC,GAAG,CAAC,CACnC,GAAG1B,4BAA4B,EAC/B,IAAI,CAACM,EAAE,GAAGD,OAAO,CAACsB,0BAA0B,MAAM,IAAI,IAAIrB,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,EAAE,CAAC,CACrF,CAAC;MACFsB,2BAA2B,EAAE,IAAIF,GAAG,CAAC,CACjC,GAAGxB,0BAA0B,EAC7B,IAAI,CAACK,EAAE,GAAGF,OAAO,CAACwB,wBAAwB,MAAM,IAAI,IAAItB,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,EAAE,CAAC,CACnF,CAAC;MACFuB,KAAK,CAACC,OAAO,EAAEC,KAAK,EAAE;QAClB;QACA,MAAM,IAAIrB,KAAK,CAACoB,OAAO,CAAC;MAC5B,CAAC;MACDE,IAAI,CAACF,OAAO,EAAEC,KAAK,EAAE;QACjB;QACA;QACAE,OAAO,CAACD,IAAI,CAACF,OAAO,CAAC;MACzB;IACJ,CAAC;IACD,MAAMI,SAAS,GAAGC,cAAc,CAACxB,GAAG,EAAES,OAAO,CAAC;IAC9C,OAAOc,SAAS;EACpB,CAAC;EAAA;AAAA;AACD5C,OAAO,CAACE,iBAAiB,GAAGA,iBAAiB;AAC7C,SAAS2C,cAAc,CAACC,aAAa,EAAEhB,OAAO,EAAE;EAC5C,MAAMiB,YAAY,GAAGjB,OAAO,CAACC,QAAQ;EACrC,IAAIiB,QAAQ;EACZ,IAAIC,UAAU;EACd,IAAI,CAACnB,OAAO,CAACG,YAAY,EAAE;IACvBgB,UAAU,GAAGnD,MAAM,CAACoD,MAAM,CAAC,IAAI,CAAC;EACpC;EACA;EACA;EACA,MAAMC,kBAAkB,GAAG,CAAC,CAAC,EAAEhD,cAAc,CAACiD,YAAY,EAAEN,aAAa,CAAC;EAC1E,KAAK,MAAM,CAACO,IAAI,EAAEpD,KAAK,CAAC,IAAIH,MAAM,CAACwD,OAAO,CAACH,kBAAkB,CAAC,EAAE;IAC5D,IAAIE,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,SAAS,EAAE;MAC1C;IAAA,CACH,MACI,IAAIA,IAAI,KAAK,UAAU,EAAE;MAC1B,MAAME,KAAK,GAAG,CAAC,CAAC,EAAEpD,cAAc,CAACyB,kBAAkB,EAAEkB,aAAa,EAAE,CAAC,UAAU,CAAC,CAAC;MACjF,IAAI,CAAC,CAAC,CAAC,EAAEzC,OAAO,CAACmD,YAAY,EAAEvD,KAAK,CAAC,IAAI,CAACsD,KAAK,EAAE;QAC7CzB,OAAO,CAACS,KAAK,CAAC,qDAAqD,EAAEtC,KAAK,CAAC;QAC3E;MACJ;MACA+C,QAAQ,GAAGS,mBAAmB,CAACF,KAAK,EAAEzB,OAAO,CAAC;IAClD,CAAC,MACI;MACD,IAAI,CAACA,OAAO,CAACI,6BAA6B,CAACwB,GAAG,CAACL,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAACM,IAAI,CAACN,IAAI,CAAC,EAAE;QAClFvB,OAAO,CAACY,IAAI,CAAE,0CAAyCW,IAAK,UAAS,EAAEA,IAAI,CAAC;MAChF;MACA,IAAIJ,UAAU,EAAE;QACZA,UAAU,CAACI,IAAI,CAAC,GAAGpD,KAAK;MAC5B;IACJ;EACJ;EACA,IAAI2D,kBAAkB;EACtB,IAAI9B,OAAO,CAACG,YAAY,EAAE;IACtB2B,kBAAkB,GAAG,CAACP,IAAI,EAAEQ,QAAQ,KAAK;MACrCd,YAAY,CAACe,SAAS,CAAC,CAAC,UAAU,EAAET,IAAI,CAAC,EAAEQ,QAAQ,EAAE,SAAS,CAAC;IACnE,CAAC;EACL;EACA,MAAME,iBAAiB,GAAG,IAAIzD,aAAa,CAAC0D,2BAA2B,CAAChB,QAAQ,EAAEY,kBAAkB,CAAC;EACrG,OAAO;IACH,CAACrD,UAAU,CAAC0D,mBAAmB,GAAGlB,YAAY;IAC9CC,QAAQ,EAAEe,iBAAiB;IAC3B;IACA;IACAd,UAAU,EAAEA,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAGA,UAAU,GAAG,CAAC,CAAC,EAAEzC,WAAW,CAAC0D,sBAAsB,EAAEf,kBAAkB,EAAE;MAChIgB,OAAO,EAAE,CAAC,SAAS,EAAE,SAAS,EAAE,UAAU,CAAC;MAC3CC,QAAQ,CAACxD,IAAI,EAAEX,KAAK,EAAE;QAClB8C,YAAY,CAACe,SAAS,CAAClD,IAAI,EAAEX,KAAK,CAAC;MACvC;IACJ,CAAC;EACL,CAAC;AACL;AACA,SAASwD,mBAAmB,CAACY,YAAY,EAAEvC,OAAO,EAAE;EAChD,MAAMkB,QAAQ,GAAGlD,MAAM,CAACoD,MAAM,CAAC,IAAI,CAAC;EACpC,KAAK,MAAM,CAACG,IAAI,EAAEpD,KAAK,CAAC,IAAIH,MAAM,CAACwD,OAAO,CAAC,CAAC,CAAC,EAAEnD,cAAc,CAACiD,YAAY,EAAEiB,YAAY,CAAC,CAAC,EAAE;IACxF,MAAMd,KAAK,GAAG,CAAC,CAAC,EAAEpD,cAAc,CAACyB,kBAAkB,EAAEyC,YAAY,EAAE,CAAChB,IAAI,CAAC,CAAC;IAC1E,IAAI,CAAC,CAAC,CAAC,EAAEhD,OAAO,CAACmD,YAAY,EAAEvD,KAAK,CAAC,IAAI,CAACsD,KAAK,EAAE;MAC7CzB,OAAO,CAACY,IAAI,CAAC,qDAAqD,EAAEzC,KAAK,CAAC;MAC1E;IACJ;IACA+C,QAAQ,CAACK,IAAI,CAAC,GAAGiB,YAAY,CAACjB,IAAI,EAAEE,KAAK,EAAEzB,OAAO,CAAC;EACvD;EACA,OAAOkB,QAAQ;AACnB;AACA,SAASsB,YAAY,CAACC,WAAW,EAAEC,WAAW,EAAE1C,OAAO,EAAE;EACrD,MAAMiB,YAAY,GAAGjB,OAAO,CAACC,QAAQ;EACrC,IAAI0C,OAAO;EACX,IAAIC,UAAU,GAAG,KAAK;EACtB,IAAIzB,UAAU;EACd,IAAI0B,UAAU;EACd,IAAI,CAAC7C,OAAO,CAACG,YAAY,EAAE;IACvB;IACAgB,UAAU,GAAGnD,MAAM,CAACoD,MAAM,CAAC,IAAI,CAAC;IAChCyB,UAAU,GAAG7E,MAAM,CAACoD,MAAM,CAAC,IAAI,CAAC;EACpC;EACA,MAAM0B,gBAAgB,GAAG,CAAC,CAAC,EAAEzE,cAAc,CAACiD,YAAY,EAAEoB,WAAW,CAAC;EACtE,IAAI,EAAE,MAAM,IAAII,gBAAgB,CAAC,EAAE;IAC/B,MAAM,IAAIxD,KAAK,CAAE,YAAWmD,WAAY,0CAAyC,CAAC;EACtF;EACA,KAAK,MAAM,CAAClB,IAAI,EAAEpD,KAAK,CAAC,IAAIH,MAAM,CAACwD,OAAO,CAACsB,gBAAgB,CAAC,EAAE;IAC1D,QAAQvB,IAAI;MACR,KAAK,SAAS;MACd,KAAK,WAAW;QACZ,MAAME,KAAK,GAAG,CAAC,CAAC,EAAEpD,cAAc,CAACyB,kBAAkB,EAAE4C,WAAW,EAAE,CAACnB,IAAI,CAAC,CAAC;QACzE,IAAI,CAAC,CAAC,CAAC,EAAEhD,OAAO,CAACmD,YAAY,EAAEvD,KAAK,CAAC,IAAI,CAACsD,KAAK,EAAE;UAC7CzB,OAAO,CAACS,KAAK,CAAE,YAAWc,IAAK,oCAAmC,EAAEpD,KAAK,CAAC;UAC1E;QACJ;QACAyE,UAAU,GAAG,IAAI;QACjBD,OAAO,GAAGI,kBAAkB,CAACN,WAAW,EAAEhB,KAAK,EAAEzB,OAAO,CAAC;QACzDiB,YAAY,CAAC+B,oBAAoB,GAAGzB,IAAI,KAAK,WAAW;QACxD;MACJ,KAAK,QAAQ;MACb,KAAK,MAAM;MACX,KAAK,YAAY;QACb,IAAI,OAAOpD,KAAK,KAAK,QAAQ,EAAE;UAC3B6B,OAAO,CAACY,IAAI,CAAE,qBAAoBW,IAAK,uBAAsB,EAAEpD,KAAK,CAAC;QACzE;QACA,IAAI0E,UAAU,EAAE;UACZA,UAAU,CAACtB,IAAI,CAAC,GAAGpD,KAAK;QAC5B;QACA;MACJ;QACI,IAAI,CAAC6B,OAAO,CAACO,2BAA2B,CAACqB,GAAG,CAACL,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAACM,IAAI,CAACN,IAAI,CAAC,EAAE;UAChFvB,OAAO,CAACY,IAAI,CAAE,YAAW6B,WAAY,2CAA0ClB,IAAK,IAAG,EAAEA,IAAI,CAAC;QAClG;QACA,IAAIJ,UAAU,EAAE;UACZA,UAAU,CAACI,IAAI,CAAC,GAAGpD,KAAK;QAC5B;QACA;IAAM;EAElB;EACA,IAAI2D,kBAAkB;EACtB,IAAI9B,OAAO,CAACG,YAAY,EAAE;IACtB2B,kBAAkB,GAAG,CAACP,IAAI,EAAEQ,QAAQ,EAAEkB,UAAU,KAAK;MACjD,IAAIL,UAAU,EAAE;QACZ3B,YAAY,CAACe,SAAS,CAAC,CAAC,UAAU,EAAES,WAAW,EAAE,SAAS,EAAElB,IAAI,CAAC,EAAEQ,QAAQ,EAAE,QAAQ,CAAC;MAC1F,CAAC,MACI;QACDd,YAAY,CAACe,SAAS,CAAC,CAAC,UAAU,EAAES,WAAW,EAAE,SAAS,CAAC,EAAEQ,UAAU,EAAE,kBAAkB,CAAC;MAChG;IACJ,CAAC;EACL;EACA,MAAMC,IAAI,GAAG;IACTP,OAAO,EAAE,IAAInE,aAAa,CAAC2E,0BAA0B,CAACR,OAAO,EAAEb,kBAAkB,CAAC;IAClF;IACA;IACAX,UAAU,EAAEA,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAGA,UAAU,GAAG,CAAC,CAAC,EAAEzC,WAAW,CAAC0D,sBAAsB,EAAEU,gBAAgB,EAAE;MAC9HT,OAAO,EAAE,CAAC,WAAW,EAAE,QAAQ,EAAE,MAAM,EAAE,YAAY,EAAE,SAAS,CAAC;MACjEC,QAAQ,CAACxD,IAAI,EAAEX,KAAK,EAAE;QAClB8C,YAAY,CAACe,SAAS,CAAC,CAAC,UAAU,EAAES,WAAW,EAAE,GAAG3D,IAAI,CAAC,EAAEX,KAAK,CAAC;MACrE;IACJ,CAAC;EACL,CAAC;EACD,MAAMiF,QAAQ,GAAG,IAAI/C,GAAG,CAACrC,MAAM,CAACqF,IAAI,CAACH,IAAI,CAAC,CAAC;EAC3C,MAAMI,OAAO,GAAGT,UAAU,KAAK,IAAI,IAAIA,UAAU,KAAK,KAAK,CAAC,GAAGA,UAAU,GAAG,CAAC,CAAC,EAAEnE,WAAW,CAAC0D,sBAAsB,EAAEU,gBAAgB,EAAE;IAClIS,OAAO,EAAE,CAAC,QAAQ,EAAE,MAAM,EAAE,YAAY,EAAE,GAAGH,QAAQ,CAAC;IACtDd,QAAQ,CAACxD,IAAI,EAAEX,KAAK,EAAE;MAClB,IAAI,CAACiF,QAAQ,CAACxB,GAAG,CAAC9C,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;QACxBmC,YAAY,CAACe,SAAS,CAAC,CAAC,UAAU,EAAES,WAAW,EAAE,GAAG3D,IAAI,CAAC,EAAEX,KAAK,CAAC;MACrE;IACJ;EACJ,CAAC,CAAC;EACF,OAAOH,MAAM,CAACwF,MAAM,CAACF,OAAO,EAAEJ,IAAI,CAAC;AACvC;AACA,SAASH,kBAAkB,CAACN,WAAW,EAAEgB,WAAW,EAAEzD,OAAO,EAAE;EAC3D,MAAMiB,YAAY,GAAGjB,OAAO,CAACC,QAAQ;EACrC,MAAM0C,OAAO,GAAG3E,MAAM,CAACoD,MAAM,CAAC,IAAI,CAAC;EACnC,KAAK,MAAM,CAACG,IAAI,EAAEpD,KAAK,CAAC,IAAIH,MAAM,CAACwD,OAAO,CAAC,CAAC,CAAC,EAAEnD,cAAc,CAACiD,YAAY,EAAEmC,WAAW,CAAC,CAAC,EAAE;IACvF,IAAI,CAAC,CAAC,CAAC,EAAElF,OAAO,CAACmD,YAAY,EAAEvD,KAAK,CAAC,EAAE;MACnC6B,OAAO,CAACY,IAAI,CAAC,oDAAoD,EAAEzC,KAAK,CAAC;MACzE;IACJ;IACA,IAAI6B,OAAO,CAACG,YAAY,EAAE;MACtBwC,OAAO,CAACpB,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE7C,WAAW,CAAC0D,sBAAsB,EAAEjE,KAAK,EAAE;QAC3DoF,OAAO,EAAE,CAAC,SAAS,EAAE,SAAS,EAAE,gBAAgB,EAAE,sBAAsB,CAAC;QACzEjB,QAAQ,CAACxD,IAAI,EAAEX,KAAK,EAAE;UAClB8C,YAAY,CAACe,SAAS,CAAC,CAAC,UAAU,EAAES,WAAW,EAAE,SAAS,EAAElB,IAAI,EAAE,GAAGzC,IAAI,CAAC,EAAEX,KAAK,CAAC;QACtF;MACJ,CAAC,CAAC;IACN,CAAC,MACI;MACDwE,OAAO,CAACpB,IAAI,CAAC,GAAGpD,KAAK;IACzB;EACJ;EACA,OAAOwE,OAAO;AAClB"},"metadata":{},"sourceType":"script","externalDependencies":[]}