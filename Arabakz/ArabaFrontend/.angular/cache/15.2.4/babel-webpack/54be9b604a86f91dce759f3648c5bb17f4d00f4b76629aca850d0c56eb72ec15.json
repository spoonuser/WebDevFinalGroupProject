{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { createScanner } from './scanner';\nvar ParseOptions;\n(function (ParseOptions) {\n  ParseOptions.DEFAULT = {\n    allowTrailingComma: false\n  };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text, position) {\n  const segments = []; // strings or numbers\n  const earlyReturnException = new Object();\n  let previousNode = undefined;\n  const previousNodeInst = {\n    value: {},\n    offset: 0,\n    length: 0,\n    type: 'object',\n    parent: undefined\n  };\n  let isAtPropertyKey = false;\n  function setPreviousNode(value, offset, length, type) {\n    previousNodeInst.value = value;\n    previousNodeInst.offset = offset;\n    previousNodeInst.length = length;\n    previousNodeInst.type = type;\n    previousNodeInst.colonOffset = undefined;\n    previousNode = previousNodeInst;\n  }\n  try {\n    visit(text, {\n      onObjectBegin: (offset, length) => {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n        previousNode = undefined;\n        isAtPropertyKey = position > offset;\n        segments.push(''); // push a placeholder (will be replaced)\n      },\n\n      onObjectProperty: (name, offset, length) => {\n        if (position < offset) {\n          throw earlyReturnException;\n        }\n        setPreviousNode(name, offset, length, 'property');\n        segments[segments.length - 1] = name;\n        if (position <= offset + length) {\n          throw earlyReturnException;\n        }\n      },\n      onObjectEnd: (offset, length) => {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n        previousNode = undefined;\n        segments.pop();\n      },\n      onArrayBegin: (offset, length) => {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n        previousNode = undefined;\n        segments.push(0);\n      },\n      onArrayEnd: (offset, length) => {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n        previousNode = undefined;\n        segments.pop();\n      },\n      onLiteralValue: (value, offset, length) => {\n        if (position < offset) {\n          throw earlyReturnException;\n        }\n        setPreviousNode(value, offset, length, getNodeType(value));\n        if (position <= offset + length) {\n          throw earlyReturnException;\n        }\n      },\n      onSeparator: (sep, offset, length) => {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n        if (sep === ':' && previousNode && previousNode.type === 'property') {\n          previousNode.colonOffset = offset;\n          isAtPropertyKey = false;\n          previousNode = undefined;\n        } else if (sep === ',') {\n          const last = segments[segments.length - 1];\n          if (typeof last === 'number') {\n            segments[segments.length - 1] = last + 1;\n          } else {\n            isAtPropertyKey = true;\n            segments[segments.length - 1] = '';\n          }\n          previousNode = undefined;\n        }\n      }\n    });\n  } catch (e) {\n    if (e !== earlyReturnException) {\n      throw e;\n    }\n  }\n  return {\n    path: segments,\n    previousNode,\n    isAtPropertyKey,\n    matches: pattern => {\n      let k = 0;\n      for (let i = 0; k < pattern.length && i < segments.length; i++) {\n        if (pattern[k] === segments[i] || pattern[k] === '*') {\n          k++;\n        } else if (pattern[k] !== '**') {\n          return false;\n        }\n      }\n      return k === pattern.length;\n    }\n  };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text, errors = [], options = ParseOptions.DEFAULT) {\n  let currentProperty = null;\n  let currentParent = [];\n  const previousParents = [];\n  function onValue(value) {\n    if (Array.isArray(currentParent)) {\n      currentParent.push(value);\n    } else if (currentProperty !== null) {\n      currentParent[currentProperty] = value;\n    }\n  }\n  const visitor = {\n    onObjectBegin: () => {\n      const object = {};\n      onValue(object);\n      previousParents.push(currentParent);\n      currentParent = object;\n      currentProperty = null;\n    },\n    onObjectProperty: name => {\n      currentProperty = name;\n    },\n    onObjectEnd: () => {\n      currentParent = previousParents.pop();\n    },\n    onArrayBegin: () => {\n      const array = [];\n      onValue(array);\n      previousParents.push(currentParent);\n      currentParent = array;\n      currentProperty = null;\n    },\n    onArrayEnd: () => {\n      currentParent = previousParents.pop();\n    },\n    onLiteralValue: onValue,\n    onError: (error, offset, length) => {\n      errors.push({\n        error,\n        offset,\n        length\n      });\n    }\n  };\n  visit(text, visitor, options);\n  return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text, errors = [], options = ParseOptions.DEFAULT) {\n  let currentParent = {\n    type: 'array',\n    offset: -1,\n    length: -1,\n    children: [],\n    parent: undefined\n  }; // artificial root\n  function ensurePropertyComplete(endOffset) {\n    if (currentParent.type === 'property') {\n      currentParent.length = endOffset - currentParent.offset;\n      currentParent = currentParent.parent;\n    }\n  }\n  function onValue(valueNode) {\n    currentParent.children.push(valueNode);\n    return valueNode;\n  }\n  const visitor = {\n    onObjectBegin: offset => {\n      currentParent = onValue({\n        type: 'object',\n        offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n    },\n    onObjectProperty: (name, offset, length) => {\n      currentParent = onValue({\n        type: 'property',\n        offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n      currentParent.children.push({\n        type: 'string',\n        value: name,\n        offset,\n        length,\n        parent: currentParent\n      });\n    },\n    onObjectEnd: (offset, length) => {\n      ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete\n      currentParent.length = offset + length - currentParent.offset;\n      currentParent = currentParent.parent;\n      ensurePropertyComplete(offset + length);\n    },\n    onArrayBegin: (offset, length) => {\n      currentParent = onValue({\n        type: 'array',\n        offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n    },\n    onArrayEnd: (offset, length) => {\n      currentParent.length = offset + length - currentParent.offset;\n      currentParent = currentParent.parent;\n      ensurePropertyComplete(offset + length);\n    },\n    onLiteralValue: (value, offset, length) => {\n      onValue({\n        type: getNodeType(value),\n        offset,\n        length,\n        parent: currentParent,\n        value\n      });\n      ensurePropertyComplete(offset + length);\n    },\n    onSeparator: (sep, offset, length) => {\n      if (currentParent.type === 'property') {\n        if (sep === ':') {\n          currentParent.colonOffset = offset;\n        } else if (sep === ',') {\n          ensurePropertyComplete(offset);\n        }\n      }\n    },\n    onError: (error, offset, length) => {\n      errors.push({\n        error,\n        offset,\n        length\n      });\n    }\n  };\n  visit(text, visitor, options);\n  const result = currentParent.children[0];\n  if (result) {\n    delete result.parent;\n  }\n  return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root, path) {\n  if (!root) {\n    return undefined;\n  }\n  let node = root;\n  for (let segment of path) {\n    if (typeof segment === 'string') {\n      if (node.type !== 'object' || !Array.isArray(node.children)) {\n        return undefined;\n      }\n      let found = false;\n      for (const propertyNode of node.children) {\n        if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {\n          node = propertyNode.children[1];\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        return undefined;\n      }\n    } else {\n      const index = segment;\n      if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n        return undefined;\n      }\n      node = node.children[index];\n    }\n  }\n  return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node) {\n  if (!node.parent || !node.parent.children) {\n    return [];\n  }\n  const path = getNodePath(node.parent);\n  if (node.parent.type === 'property') {\n    const key = node.parent.children[0].value;\n    path.push(key);\n  } else if (node.parent.type === 'array') {\n    const index = node.parent.children.indexOf(node);\n    if (index !== -1) {\n      path.push(index);\n    }\n  }\n  return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node) {\n  switch (node.type) {\n    case 'array':\n      return node.children.map(getNodeValue);\n    case 'object':\n      const obj = Object.create(null);\n      for (let prop of node.children) {\n        const valueNode = prop.children[1];\n        if (valueNode) {\n          obj[prop.children[0].value] = getNodeValue(valueNode);\n        }\n      }\n      return obj;\n    case 'null':\n    case 'string':\n    case 'number':\n    case 'boolean':\n      return node.value;\n    default:\n      return undefined;\n  }\n}\nexport function contains(node, offset, includeRightBound = false) {\n  return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node, offset, includeRightBound = false) {\n  if (contains(node, offset, includeRightBound)) {\n    const children = node.children;\n    if (Array.isArray(children)) {\n      for (let i = 0; i < children.length && children[i].offset <= offset; i++) {\n        const item = findNodeAtOffset(children[i], offset, includeRightBound);\n        if (item) {\n          return item;\n        }\n      }\n    }\n    return node;\n  }\n  return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text, visitor, options = ParseOptions.DEFAULT) {\n  const _scanner = createScanner(text, false);\n  // Important: Only pass copies of this to visitor functions to prevent accidental modification, and\n  // to not affect visitor functions which stored a reference to a previous JSONPath\n  const _jsonPath = [];\n  function toNoArgVisit(visitFunction) {\n    return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;\n  }\n  function toNoArgVisitWithPath(visitFunction) {\n    return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;\n  }\n  function toOneArgVisit(visitFunction) {\n    return visitFunction ? arg => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;\n  }\n  function toOneArgVisitWithPath(visitFunction) {\n    return visitFunction ? arg => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;\n  }\n  const onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin),\n    onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty),\n    onObjectEnd = toNoArgVisit(visitor.onObjectEnd),\n    onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin),\n    onArrayEnd = toNoArgVisit(visitor.onArrayEnd),\n    onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue),\n    onSeparator = toOneArgVisit(visitor.onSeparator),\n    onComment = toNoArgVisit(visitor.onComment),\n    onError = toOneArgVisit(visitor.onError);\n  const disallowComments = options && options.disallowComments;\n  const allowTrailingComma = options && options.allowTrailingComma;\n  function scanNext() {\n    while (true) {\n      const token = _scanner.scan();\n      switch (_scanner.getTokenError()) {\n        case 4 /* ScanError.InvalidUnicode */:\n          handleError(14 /* ParseErrorCode.InvalidUnicode */);\n          break;\n        case 5 /* ScanError.InvalidEscapeCharacter */:\n          handleError(15 /* ParseErrorCode.InvalidEscapeCharacter */);\n          break;\n        case 3 /* ScanError.UnexpectedEndOfNumber */:\n          handleError(13 /* ParseErrorCode.UnexpectedEndOfNumber */);\n          break;\n        case 1 /* ScanError.UnexpectedEndOfComment */:\n          if (!disallowComments) {\n            handleError(11 /* ParseErrorCode.UnexpectedEndOfComment */);\n          }\n\n          break;\n        case 2 /* ScanError.UnexpectedEndOfString */:\n          handleError(12 /* ParseErrorCode.UnexpectedEndOfString */);\n          break;\n        case 6 /* ScanError.InvalidCharacter */:\n          handleError(16 /* ParseErrorCode.InvalidCharacter */);\n          break;\n      }\n      switch (token) {\n        case 12 /* SyntaxKind.LineCommentTrivia */:\n        case 13 /* SyntaxKind.BlockCommentTrivia */:\n          if (disallowComments) {\n            handleError(10 /* ParseErrorCode.InvalidCommentToken */);\n          } else {\n            onComment();\n          }\n          break;\n        case 16 /* SyntaxKind.Unknown */:\n          handleError(1 /* ParseErrorCode.InvalidSymbol */);\n          break;\n        case 15 /* SyntaxKind.Trivia */:\n        case 14 /* SyntaxKind.LineBreakTrivia */:\n          break;\n        default:\n          return token;\n      }\n    }\n  }\n  function handleError(error, skipUntilAfter = [], skipUntil = []) {\n    onError(error);\n    if (skipUntilAfter.length + skipUntil.length > 0) {\n      let token = _scanner.getToken();\n      while (token !== 17 /* SyntaxKind.EOF */) {\n        if (skipUntilAfter.indexOf(token) !== -1) {\n          scanNext();\n          break;\n        } else if (skipUntil.indexOf(token) !== -1) {\n          break;\n        }\n        token = scanNext();\n      }\n    }\n  }\n  function parseString(isValue) {\n    const value = _scanner.getTokenValue();\n    if (isValue) {\n      onLiteralValue(value);\n    } else {\n      onObjectProperty(value);\n      // add property name afterwards\n      _jsonPath.push(value);\n    }\n    scanNext();\n    return true;\n  }\n  function parseLiteral() {\n    switch (_scanner.getToken()) {\n      case 11 /* SyntaxKind.NumericLiteral */:\n        const tokenValue = _scanner.getTokenValue();\n        let value = Number(tokenValue);\n        if (isNaN(value)) {\n          handleError(2 /* ParseErrorCode.InvalidNumberFormat */);\n          value = 0;\n        }\n        onLiteralValue(value);\n        break;\n      case 7 /* SyntaxKind.NullKeyword */:\n        onLiteralValue(null);\n        break;\n      case 8 /* SyntaxKind.TrueKeyword */:\n        onLiteralValue(true);\n        break;\n      case 9 /* SyntaxKind.FalseKeyword */:\n        onLiteralValue(false);\n        break;\n      default:\n        return false;\n    }\n    scanNext();\n    return true;\n  }\n  function parseProperty() {\n    if (_scanner.getToken() !== 10 /* SyntaxKind.StringLiteral */) {\n      handleError(3 /* ParseErrorCode.PropertyNameExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n      return false;\n    }\n    parseString(false);\n    if (_scanner.getToken() === 6 /* SyntaxKind.ColonToken */) {\n      onSeparator(':');\n      scanNext(); // consume colon\n      if (!parseValue()) {\n        handleError(4 /* ParseErrorCode.ValueExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n      }\n    } else {\n      handleError(5 /* ParseErrorCode.ColonExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n    }\n\n    _jsonPath.pop(); // remove processed property name\n    return true;\n  }\n  function parseObject() {\n    onObjectBegin();\n    scanNext(); // consume open brace\n    let needsComma = false;\n    while (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */ && _scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n      if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */) {\n        if (!needsComma) {\n          handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n        }\n        onSeparator(',');\n        scanNext(); // consume comma\n        if (_scanner.getToken() === 2 /* SyntaxKind.CloseBraceToken */ && allowTrailingComma) {\n          break;\n        }\n      } else if (needsComma) {\n        handleError(6 /* ParseErrorCode.CommaExpected */, [], []);\n      }\n      if (!parseProperty()) {\n        handleError(4 /* ParseErrorCode.ValueExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n      }\n\n      needsComma = true;\n    }\n    onObjectEnd();\n    if (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */) {\n      handleError(7 /* ParseErrorCode.CloseBraceExpected */, [2 /* SyntaxKind.CloseBraceToken */], []);\n    } else {\n      scanNext(); // consume close brace\n    }\n\n    return true;\n  }\n  function parseArray() {\n    onArrayBegin();\n    scanNext(); // consume open bracket\n    let isFirstElement = true;\n    let needsComma = false;\n    while (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */ && _scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n      if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */) {\n        if (!needsComma) {\n          handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n        }\n        onSeparator(',');\n        scanNext(); // consume comma\n        if (_scanner.getToken() === 4 /* SyntaxKind.CloseBracketToken */ && allowTrailingComma) {\n          break;\n        }\n      } else if (needsComma) {\n        handleError(6 /* ParseErrorCode.CommaExpected */, [], []);\n      }\n      if (isFirstElement) {\n        _jsonPath.push(0);\n        isFirstElement = false;\n      } else {\n        _jsonPath[_jsonPath.length - 1]++;\n      }\n      if (!parseValue()) {\n        handleError(4 /* ParseErrorCode.ValueExpected */, [], [4 /* SyntaxKind.CloseBracketToken */, 5 /* SyntaxKind.CommaToken */]);\n      }\n\n      needsComma = true;\n    }\n    onArrayEnd();\n    if (!isFirstElement) {\n      _jsonPath.pop(); // remove array index\n    }\n\n    if (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */) {\n      handleError(8 /* ParseErrorCode.CloseBracketExpected */, [4 /* SyntaxKind.CloseBracketToken */], []);\n    } else {\n      scanNext(); // consume close bracket\n    }\n\n    return true;\n  }\n  function parseValue() {\n    switch (_scanner.getToken()) {\n      case 3 /* SyntaxKind.OpenBracketToken */:\n        return parseArray();\n      case 1 /* SyntaxKind.OpenBraceToken */:\n        return parseObject();\n      case 10 /* SyntaxKind.StringLiteral */:\n        return parseString(true);\n      default:\n        return parseLiteral();\n    }\n  }\n  scanNext();\n  if (_scanner.getToken() === 17 /* SyntaxKind.EOF */) {\n    if (options.allowEmptyContent) {\n      return true;\n    }\n    handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n    return false;\n  }\n  if (!parseValue()) {\n    handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n    return false;\n  }\n  if (_scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n    handleError(9 /* ParseErrorCode.EndOfFileExpected */, [], []);\n  }\n  return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text, replaceCh) {\n  let _scanner = createScanner(text),\n    parts = [],\n    kind,\n    offset = 0,\n    pos;\n  do {\n    pos = _scanner.getPosition();\n    kind = _scanner.scan();\n    switch (kind) {\n      case 12 /* SyntaxKind.LineCommentTrivia */:\n      case 13 /* SyntaxKind.BlockCommentTrivia */:\n      case 17 /* SyntaxKind.EOF */:\n        if (offset !== pos) {\n          parts.push(text.substring(offset, pos));\n        }\n        if (replaceCh !== undefined) {\n          parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n        }\n        offset = _scanner.getPosition();\n        break;\n    }\n  } while (kind !== 17 /* SyntaxKind.EOF */);\n  return parts.join('');\n}\nexport function getNodeType(value) {\n  switch (typeof value) {\n    case 'boolean':\n      return 'boolean';\n    case 'number':\n      return 'number';\n    case 'string':\n      return 'string';\n    case 'object':\n      {\n        if (!value) {\n          return 'null';\n        } else if (Array.isArray(value)) {\n          return 'array';\n        }\n        return 'object';\n      }\n    default:\n      return 'null';\n  }\n}","map":{"version":3,"names":["createScanner","ParseOptions","DEFAULT","allowTrailingComma","getLocation","text","position","segments","earlyReturnException","Object","previousNode","undefined","previousNodeInst","value","offset","length","type","parent","isAtPropertyKey","setPreviousNode","colonOffset","visit","onObjectBegin","push","onObjectProperty","name","onObjectEnd","pop","onArrayBegin","onArrayEnd","onLiteralValue","getNodeType","onSeparator","sep","last","e","path","matches","pattern","k","i","parse","errors","options","currentProperty","currentParent","previousParents","onValue","Array","isArray","visitor","object","array","onError","error","parseTree","children","ensurePropertyComplete","endOffset","valueNode","result","findNodeAtLocation","root","node","segment","found","propertyNode","index","getNodePath","key","indexOf","getNodeValue","map","obj","create","prop","contains","includeRightBound","findNodeAtOffset","item","_scanner","_jsonPath","toNoArgVisit","visitFunction","getTokenOffset","getTokenLength","getTokenStartLine","getTokenStartCharacter","toNoArgVisitWithPath","slice","toOneArgVisit","arg","toOneArgVisitWithPath","onComment","disallowComments","scanNext","token","scan","getTokenError","handleError","skipUntilAfter","skipUntil","getToken","parseString","isValue","getTokenValue","parseLiteral","tokenValue","Number","isNaN","parseProperty","parseValue","parseObject","needsComma","parseArray","isFirstElement","allowEmptyContent","stripComments","replaceCh","parts","kind","pos","getPosition","substring","replace","join"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/jsonc-parser/lib/esm/impl/parser.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { createScanner } from './scanner';\nvar ParseOptions;\n(function (ParseOptions) {\n    ParseOptions.DEFAULT = {\n        allowTrailingComma: false\n    };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text, position) {\n    const segments = []; // strings or numbers\n    const earlyReturnException = new Object();\n    let previousNode = undefined;\n    const previousNodeInst = {\n        value: {},\n        offset: 0,\n        length: 0,\n        type: 'object',\n        parent: undefined\n    };\n    let isAtPropertyKey = false;\n    function setPreviousNode(value, offset, length, type) {\n        previousNodeInst.value = value;\n        previousNodeInst.offset = offset;\n        previousNodeInst.length = length;\n        previousNodeInst.type = type;\n        previousNodeInst.colonOffset = undefined;\n        previousNode = previousNodeInst;\n    }\n    try {\n        visit(text, {\n            onObjectBegin: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                isAtPropertyKey = position > offset;\n                segments.push(''); // push a placeholder (will be replaced)\n            },\n            onObjectProperty: (name, offset, length) => {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(name, offset, length, 'property');\n                segments[segments.length - 1] = name;\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onObjectEnd: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onArrayBegin: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.push(0);\n            },\n            onArrayEnd: (offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                previousNode = undefined;\n                segments.pop();\n            },\n            onLiteralValue: (value, offset, length) => {\n                if (position < offset) {\n                    throw earlyReturnException;\n                }\n                setPreviousNode(value, offset, length, getNodeType(value));\n                if (position <= offset + length) {\n                    throw earlyReturnException;\n                }\n            },\n            onSeparator: (sep, offset, length) => {\n                if (position <= offset) {\n                    throw earlyReturnException;\n                }\n                if (sep === ':' && previousNode && previousNode.type === 'property') {\n                    previousNode.colonOffset = offset;\n                    isAtPropertyKey = false;\n                    previousNode = undefined;\n                }\n                else if (sep === ',') {\n                    const last = segments[segments.length - 1];\n                    if (typeof last === 'number') {\n                        segments[segments.length - 1] = last + 1;\n                    }\n                    else {\n                        isAtPropertyKey = true;\n                        segments[segments.length - 1] = '';\n                    }\n                    previousNode = undefined;\n                }\n            }\n        });\n    }\n    catch (e) {\n        if (e !== earlyReturnException) {\n            throw e;\n        }\n    }\n    return {\n        path: segments,\n        previousNode,\n        isAtPropertyKey,\n        matches: (pattern) => {\n            let k = 0;\n            for (let i = 0; k < pattern.length && i < segments.length; i++) {\n                if (pattern[k] === segments[i] || pattern[k] === '*') {\n                    k++;\n                }\n                else if (pattern[k] !== '**') {\n                    return false;\n                }\n            }\n            return k === pattern.length;\n        }\n    };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text, errors = [], options = ParseOptions.DEFAULT) {\n    let currentProperty = null;\n    let currentParent = [];\n    const previousParents = [];\n    function onValue(value) {\n        if (Array.isArray(currentParent)) {\n            currentParent.push(value);\n        }\n        else if (currentProperty !== null) {\n            currentParent[currentProperty] = value;\n        }\n    }\n    const visitor = {\n        onObjectBegin: () => {\n            const object = {};\n            onValue(object);\n            previousParents.push(currentParent);\n            currentParent = object;\n            currentProperty = null;\n        },\n        onObjectProperty: (name) => {\n            currentProperty = name;\n        },\n        onObjectEnd: () => {\n            currentParent = previousParents.pop();\n        },\n        onArrayBegin: () => {\n            const array = [];\n            onValue(array);\n            previousParents.push(currentParent);\n            currentParent = array;\n            currentProperty = null;\n        },\n        onArrayEnd: () => {\n            currentParent = previousParents.pop();\n        },\n        onLiteralValue: onValue,\n        onError: (error, offset, length) => {\n            errors.push({ error, offset, length });\n        }\n    };\n    visit(text, visitor, options);\n    return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text, errors = [], options = ParseOptions.DEFAULT) {\n    let currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root\n    function ensurePropertyComplete(endOffset) {\n        if (currentParent.type === 'property') {\n            currentParent.length = endOffset - currentParent.offset;\n            currentParent = currentParent.parent;\n        }\n    }\n    function onValue(valueNode) {\n        currentParent.children.push(valueNode);\n        return valueNode;\n    }\n    const visitor = {\n        onObjectBegin: (offset) => {\n            currentParent = onValue({ type: 'object', offset, length: -1, parent: currentParent, children: [] });\n        },\n        onObjectProperty: (name, offset, length) => {\n            currentParent = onValue({ type: 'property', offset, length: -1, parent: currentParent, children: [] });\n            currentParent.children.push({ type: 'string', value: name, offset, length, parent: currentParent });\n        },\n        onObjectEnd: (offset, length) => {\n            ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onArrayBegin: (offset, length) => {\n            currentParent = onValue({ type: 'array', offset, length: -1, parent: currentParent, children: [] });\n        },\n        onArrayEnd: (offset, length) => {\n            currentParent.length = offset + length - currentParent.offset;\n            currentParent = currentParent.parent;\n            ensurePropertyComplete(offset + length);\n        },\n        onLiteralValue: (value, offset, length) => {\n            onValue({ type: getNodeType(value), offset, length, parent: currentParent, value });\n            ensurePropertyComplete(offset + length);\n        },\n        onSeparator: (sep, offset, length) => {\n            if (currentParent.type === 'property') {\n                if (sep === ':') {\n                    currentParent.colonOffset = offset;\n                }\n                else if (sep === ',') {\n                    ensurePropertyComplete(offset);\n                }\n            }\n        },\n        onError: (error, offset, length) => {\n            errors.push({ error, offset, length });\n        }\n    };\n    visit(text, visitor, options);\n    const result = currentParent.children[0];\n    if (result) {\n        delete result.parent;\n    }\n    return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root, path) {\n    if (!root) {\n        return undefined;\n    }\n    let node = root;\n    for (let segment of path) {\n        if (typeof segment === 'string') {\n            if (node.type !== 'object' || !Array.isArray(node.children)) {\n                return undefined;\n            }\n            let found = false;\n            for (const propertyNode of node.children) {\n                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {\n                    node = propertyNode.children[1];\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return undefined;\n            }\n        }\n        else {\n            const index = segment;\n            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n                return undefined;\n            }\n            node = node.children[index];\n        }\n    }\n    return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node) {\n    if (!node.parent || !node.parent.children) {\n        return [];\n    }\n    const path = getNodePath(node.parent);\n    if (node.parent.type === 'property') {\n        const key = node.parent.children[0].value;\n        path.push(key);\n    }\n    else if (node.parent.type === 'array') {\n        const index = node.parent.children.indexOf(node);\n        if (index !== -1) {\n            path.push(index);\n        }\n    }\n    return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport function getNodeValue(node) {\n    switch (node.type) {\n        case 'array':\n            return node.children.map(getNodeValue);\n        case 'object':\n            const obj = Object.create(null);\n            for (let prop of node.children) {\n                const valueNode = prop.children[1];\n                if (valueNode) {\n                    obj[prop.children[0].value] = getNodeValue(valueNode);\n                }\n            }\n            return obj;\n        case 'null':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return node.value;\n        default:\n            return undefined;\n    }\n}\nexport function contains(node, offset, includeRightBound = false) {\n    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(node, offset, includeRightBound = false) {\n    if (contains(node, offset, includeRightBound)) {\n        const children = node.children;\n        if (Array.isArray(children)) {\n            for (let i = 0; i < children.length && children[i].offset <= offset; i++) {\n                const item = findNodeAtOffset(children[i], offset, includeRightBound);\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return node;\n    }\n    return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text, visitor, options = ParseOptions.DEFAULT) {\n    const _scanner = createScanner(text, false);\n    // Important: Only pass copies of this to visitor functions to prevent accidental modification, and\n    // to not affect visitor functions which stored a reference to a previous JSONPath\n    const _jsonPath = [];\n    function toNoArgVisit(visitFunction) {\n        return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;\n    }\n    function toNoArgVisitWithPath(visitFunction) {\n        return visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;\n    }\n    function toOneArgVisit(visitFunction) {\n        return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;\n    }\n    function toOneArgVisitWithPath(visitFunction) {\n        return visitFunction ? (arg) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;\n    }\n    const onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);\n    const disallowComments = options && options.disallowComments;\n    const allowTrailingComma = options && options.allowTrailingComma;\n    function scanNext() {\n        while (true) {\n            const token = _scanner.scan();\n            switch (_scanner.getTokenError()) {\n                case 4 /* ScanError.InvalidUnicode */:\n                    handleError(14 /* ParseErrorCode.InvalidUnicode */);\n                    break;\n                case 5 /* ScanError.InvalidEscapeCharacter */:\n                    handleError(15 /* ParseErrorCode.InvalidEscapeCharacter */);\n                    break;\n                case 3 /* ScanError.UnexpectedEndOfNumber */:\n                    handleError(13 /* ParseErrorCode.UnexpectedEndOfNumber */);\n                    break;\n                case 1 /* ScanError.UnexpectedEndOfComment */:\n                    if (!disallowComments) {\n                        handleError(11 /* ParseErrorCode.UnexpectedEndOfComment */);\n                    }\n                    break;\n                case 2 /* ScanError.UnexpectedEndOfString */:\n                    handleError(12 /* ParseErrorCode.UnexpectedEndOfString */);\n                    break;\n                case 6 /* ScanError.InvalidCharacter */:\n                    handleError(16 /* ParseErrorCode.InvalidCharacter */);\n                    break;\n            }\n            switch (token) {\n                case 12 /* SyntaxKind.LineCommentTrivia */:\n                case 13 /* SyntaxKind.BlockCommentTrivia */:\n                    if (disallowComments) {\n                        handleError(10 /* ParseErrorCode.InvalidCommentToken */);\n                    }\n                    else {\n                        onComment();\n                    }\n                    break;\n                case 16 /* SyntaxKind.Unknown */:\n                    handleError(1 /* ParseErrorCode.InvalidSymbol */);\n                    break;\n                case 15 /* SyntaxKind.Trivia */:\n                case 14 /* SyntaxKind.LineBreakTrivia */:\n                    break;\n                default:\n                    return token;\n            }\n        }\n    }\n    function handleError(error, skipUntilAfter = [], skipUntil = []) {\n        onError(error);\n        if (skipUntilAfter.length + skipUntil.length > 0) {\n            let token = _scanner.getToken();\n            while (token !== 17 /* SyntaxKind.EOF */) {\n                if (skipUntilAfter.indexOf(token) !== -1) {\n                    scanNext();\n                    break;\n                }\n                else if (skipUntil.indexOf(token) !== -1) {\n                    break;\n                }\n                token = scanNext();\n            }\n        }\n    }\n    function parseString(isValue) {\n        const value = _scanner.getTokenValue();\n        if (isValue) {\n            onLiteralValue(value);\n        }\n        else {\n            onObjectProperty(value);\n            // add property name afterwards\n            _jsonPath.push(value);\n        }\n        scanNext();\n        return true;\n    }\n    function parseLiteral() {\n        switch (_scanner.getToken()) {\n            case 11 /* SyntaxKind.NumericLiteral */:\n                const tokenValue = _scanner.getTokenValue();\n                let value = Number(tokenValue);\n                if (isNaN(value)) {\n                    handleError(2 /* ParseErrorCode.InvalidNumberFormat */);\n                    value = 0;\n                }\n                onLiteralValue(value);\n                break;\n            case 7 /* SyntaxKind.NullKeyword */:\n                onLiteralValue(null);\n                break;\n            case 8 /* SyntaxKind.TrueKeyword */:\n                onLiteralValue(true);\n                break;\n            case 9 /* SyntaxKind.FalseKeyword */:\n                onLiteralValue(false);\n                break;\n            default:\n                return false;\n        }\n        scanNext();\n        return true;\n    }\n    function parseProperty() {\n        if (_scanner.getToken() !== 10 /* SyntaxKind.StringLiteral */) {\n            handleError(3 /* ParseErrorCode.PropertyNameExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n            return false;\n        }\n        parseString(false);\n        if (_scanner.getToken() === 6 /* SyntaxKind.ColonToken */) {\n            onSeparator(':');\n            scanNext(); // consume colon\n            if (!parseValue()) {\n                handleError(4 /* ParseErrorCode.ValueExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n            }\n        }\n        else {\n            handleError(5 /* ParseErrorCode.ColonExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n        }\n        _jsonPath.pop(); // remove processed property name\n        return true;\n    }\n    function parseObject() {\n        onObjectBegin();\n        scanNext(); // consume open brace\n        let needsComma = false;\n        while (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */ && _scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n            if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 2 /* SyntaxKind.CloseBraceToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* ParseErrorCode.CommaExpected */, [], []);\n            }\n            if (!parseProperty()) {\n                handleError(4 /* ParseErrorCode.ValueExpected */, [], [2 /* SyntaxKind.CloseBraceToken */, 5 /* SyntaxKind.CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onObjectEnd();\n        if (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */) {\n            handleError(7 /* ParseErrorCode.CloseBraceExpected */, [2 /* SyntaxKind.CloseBraceToken */], []);\n        }\n        else {\n            scanNext(); // consume close brace\n        }\n        return true;\n    }\n    function parseArray() {\n        onArrayBegin();\n        scanNext(); // consume open bracket\n        let isFirstElement = true;\n        let needsComma = false;\n        while (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */ && _scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n            if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */) {\n                if (!needsComma) {\n                    handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n                }\n                onSeparator(',');\n                scanNext(); // consume comma\n                if (_scanner.getToken() === 4 /* SyntaxKind.CloseBracketToken */ && allowTrailingComma) {\n                    break;\n                }\n            }\n            else if (needsComma) {\n                handleError(6 /* ParseErrorCode.CommaExpected */, [], []);\n            }\n            if (isFirstElement) {\n                _jsonPath.push(0);\n                isFirstElement = false;\n            }\n            else {\n                _jsonPath[_jsonPath.length - 1]++;\n            }\n            if (!parseValue()) {\n                handleError(4 /* ParseErrorCode.ValueExpected */, [], [4 /* SyntaxKind.CloseBracketToken */, 5 /* SyntaxKind.CommaToken */]);\n            }\n            needsComma = true;\n        }\n        onArrayEnd();\n        if (!isFirstElement) {\n            _jsonPath.pop(); // remove array index\n        }\n        if (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */) {\n            handleError(8 /* ParseErrorCode.CloseBracketExpected */, [4 /* SyntaxKind.CloseBracketToken */], []);\n        }\n        else {\n            scanNext(); // consume close bracket\n        }\n        return true;\n    }\n    function parseValue() {\n        switch (_scanner.getToken()) {\n            case 3 /* SyntaxKind.OpenBracketToken */:\n                return parseArray();\n            case 1 /* SyntaxKind.OpenBraceToken */:\n                return parseObject();\n            case 10 /* SyntaxKind.StringLiteral */:\n                return parseString(true);\n            default:\n                return parseLiteral();\n        }\n    }\n    scanNext();\n    if (_scanner.getToken() === 17 /* SyntaxKind.EOF */) {\n        if (options.allowEmptyContent) {\n            return true;\n        }\n        handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n        return false;\n    }\n    if (!parseValue()) {\n        handleError(4 /* ParseErrorCode.ValueExpected */, [], []);\n        return false;\n    }\n    if (_scanner.getToken() !== 17 /* SyntaxKind.EOF */) {\n        handleError(9 /* ParseErrorCode.EndOfFileExpected */, [], []);\n    }\n    return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text, replaceCh) {\n    let _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\n    do {\n        pos = _scanner.getPosition();\n        kind = _scanner.scan();\n        switch (kind) {\n            case 12 /* SyntaxKind.LineCommentTrivia */:\n            case 13 /* SyntaxKind.BlockCommentTrivia */:\n            case 17 /* SyntaxKind.EOF */:\n                if (offset !== pos) {\n                    parts.push(text.substring(offset, pos));\n                }\n                if (replaceCh !== undefined) {\n                    parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n                }\n                offset = _scanner.getPosition();\n                break;\n        }\n    } while (kind !== 17 /* SyntaxKind.EOF */);\n    return parts.join('');\n}\nexport function getNodeType(value) {\n    switch (typeof value) {\n        case 'boolean': return 'boolean';\n        case 'number': return 'number';\n        case 'string': return 'string';\n        case 'object': {\n            if (!value) {\n                return 'null';\n            }\n            else if (Array.isArray(value)) {\n                return 'array';\n            }\n            return 'object';\n        }\n        default: return 'null';\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}