{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt) {\n    const {\n      gen,\n      schema: $ref,\n      it\n    } = cxt;\n    const {\n      baseId,\n      schemaEnv: env,\n      validateName,\n      opts,\n      self\n    } = it;\n    const {\n      root\n    } = env;\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef();\n    const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n    if (schOrEnv === undefined) throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n    if (schOrEnv instanceof compile_1.SchemaEnv) return callValidate(schOrEnv);\n    return inlineRefSchema(schOrEnv);\n    function callRootRef() {\n      if (env === root) return callRef(cxt, validateName, env, env.$async);\n      const rootName = gen.scopeValue(\"root\", {\n        ref: root\n      });\n      return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);\n    }\n    function callValidate(sch) {\n      const v = getValidate(cxt, sch);\n      callRef(cxt, v, sch, sch.$async);\n    }\n    function inlineRefSchema(sch) {\n      const schName = gen.scopeValue(\"schema\", opts.code.source === true ? {\n        ref: sch,\n        code: (0, codegen_1.stringify)(sch)\n      } : {\n        ref: sch\n      });\n      const valid = gen.name(\"valid\");\n      const schCxt = cxt.subschema({\n        schema: sch,\n        dataTypes: [],\n        schemaPath: codegen_1.nil,\n        topSchemaRef: schName,\n        errSchemaPath: $ref\n      }, valid);\n      cxt.mergeEvaluated(schCxt);\n      cxt.ok(valid);\n    }\n  }\n};\nfunction getValidate(cxt, sch) {\n  const {\n    gen\n  } = cxt;\n  return sch.validate ? gen.scopeValue(\"validate\", {\n    ref: sch.validate\n  }) : (0, codegen_1._)`${gen.scopeValue(\"wrapper\", {\n    ref: sch\n  })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n  const {\n    gen,\n    it\n  } = cxt;\n  const {\n    allErrors,\n    schemaEnv: env,\n    opts\n  } = it;\n  const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n  if ($async) callAsyncRef();else callSyncRef();\n  function callAsyncRef() {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\");\n    const valid = gen.let(\"valid\");\n    gen.try(() => {\n      gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n      addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n      if (!allErrors) gen.assign(valid, true);\n    }, e => {\n      gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n      addErrorsFrom(e);\n      if (!allErrors) gen.assign(valid, false);\n    });\n    cxt.ok(valid);\n  }\n  function callSyncRef() {\n    cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n  }\n  function addErrorsFrom(source) {\n    const errs = (0, codegen_1._)`${source}.errors`;\n    gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n    gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);\n  }\n  function addEvaluatedFrom(source) {\n    var _a;\n    if (!it.opts.unevaluated) return;\n    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n        }\n      } else {\n        const props = gen.var(\"props\", (0, codegen_1._)`${source}.evaluated.props`);\n        it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n        }\n      } else {\n        const items = gen.var(\"items\", (0, codegen_1._)`${source}.evaluated.items`);\n        it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n      }\n    }\n  }\n}\nexports.callRef = callRef;\nexports.default = def;","map":{"version":3,"names":["Object","defineProperty","exports","value","callRef","getValidate","ref_error_1","require","code_1","codegen_1","names_1","compile_1","util_1","def","keyword","schemaType","code","cxt","gen","schema","$ref","it","baseId","schemaEnv","env","validateName","opts","self","root","callRootRef","schOrEnv","resolveRef","call","undefined","default","uriResolver","SchemaEnv","callValidate","inlineRefSchema","$async","rootName","scopeValue","ref","_","sch","v","schName","source","stringify","valid","name","schCxt","subschema","dataTypes","schemaPath","nil","topSchemaRef","errSchemaPath","mergeEvaluated","ok","validate","allErrors","passCxt","passContext","this","callAsyncRef","callSyncRef","Error","let","try","callValidateCode","addEvaluatedFrom","assign","e","if","ValidationError","throw","addErrorsFrom","result","errs","vErrors","errors","_a","unevaluated","schEvaluated","evaluated","props","dynamicProps","var","Name","items","dynamicItems"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/ajv/dist/vocabularies/core/ref.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports.default = def;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}