{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst types_1 = require(\"../discriminator/types\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n  message: ({\n    params: {\n      discrError,\n      tagName\n    }\n  }) => discrError === types_1.DiscrError.Tag ? `tag \"${tagName}\" must be string` : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({\n    params: {\n      discrError,\n      tag,\n      tagName\n    }\n  }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`\n};\nconst def = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt) {\n    const {\n      gen,\n      data,\n      schema,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      oneOf\n    } = parentSchema;\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\");\n    }\n    const tagName = schema.propertyName;\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\");\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\");\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\");\n    const valid = gen.let(\"valid\", false);\n    const tag = gen.const(\"tag\", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);\n    gen.if((0, codegen_1._)`typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, {\n      discrError: types_1.DiscrError.Tag,\n      tag,\n      tagName\n    }));\n    cxt.ok(valid);\n    function validateMapping() {\n      const mapping = getMapping();\n      gen.if(false);\n      for (const tagValue in mapping) {\n        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);\n        gen.assign(valid, applyTagSchema(mapping[tagValue]));\n      }\n      gen.else();\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Mapping,\n        tag,\n        tagName\n      });\n      gen.endIf();\n    }\n    function applyTagSchema(schemaProp) {\n      const _valid = gen.name(\"valid\");\n      const schCxt = cxt.subschema({\n        keyword: \"oneOf\",\n        schemaProp\n      }, _valid);\n      cxt.mergeEvaluated(schCxt, codegen_1.Name);\n      return _valid;\n    }\n    function getMapping() {\n      var _a;\n      const oneOfMapping = {};\n      const topRequired = hasRequired(parentSchema);\n      let tagRequired = true;\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i];\n        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n          sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);\n          if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;\n        }\n        const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n        if (typeof propSch != \"object\") {\n          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch));\n        addMappings(propSch, i);\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`);\n      return oneOfMapping;\n      function hasRequired({\n        required\n      }) {\n        return Array.isArray(required) && required.includes(tagName);\n      }\n      function addMappings(sch, i) {\n        if (sch.const) {\n          addMapping(sch.const, i);\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i);\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n        }\n      }\n      function addMapping(tagValue, i) {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n        }\n        oneOfMapping[tagValue] = i;\n      }\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["Object","defineProperty","exports","value","codegen_1","require","types_1","compile_1","util_1","error","message","params","discrError","tagName","DiscrError","Tag","tag","_","def","keyword","type","schemaType","code","cxt","gen","data","schema","parentSchema","it","oneOf","opts","discriminator","Error","propertyName","mapping","valid","let","const","getProperty","if","validateMapping","ok","getMapping","tagValue","elseIf","assign","applyTagSchema","else","Mapping","endIf","schemaProp","_valid","name","schCxt","subschema","mergeEvaluated","Name","_a","oneOfMapping","topRequired","hasRequired","tagRequired","i","length","sch","$ref","schemaHasRulesButRef","self","RULES","resolveRef","call","schemaEnv","root","baseId","SchemaEnv","propSch","properties","addMappings","required","Array","isArray","includes","addMapping","enum","default"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/ajv/dist/vocabularies/discriminator/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst types_1 = require(\"../discriminator/types\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag \"${tagName}\" must be string`\n        : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n            throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n            throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n            throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);\n                    if (sch instanceof compile_1.SchemaEnv)\n                        sch = sch.schema;\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") {\n                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports.default = def;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}