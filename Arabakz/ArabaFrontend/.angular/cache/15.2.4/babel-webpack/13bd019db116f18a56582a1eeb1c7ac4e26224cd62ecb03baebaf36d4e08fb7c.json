{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({\n    params\n  }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`\n};\nconst def = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      it\n    } = cxt;\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n    if (it.opts.discriminator && parentSchema.discriminator) return;\n    const schArr = schema;\n    const valid = gen.let(\"valid\", false);\n    const passing = gen.let(\"passing\", null);\n    const schValid = gen.name(\"_valid\");\n    cxt.setParams({\n      passing\n    });\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n    gen.block(validateOneOf);\n    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n    function validateOneOf() {\n      schArr.forEach((sch, i) => {\n        let schCxt;\n        if ((0, util_1.alwaysValidSchema)(it, sch)) {\n          gen.var(schValid, true);\n        } else {\n          schCxt = cxt.subschema({\n            keyword: \"oneOf\",\n            schemaProp: i,\n            compositeRule: true\n          }, schValid);\n        }\n        if (i > 0) {\n          gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();\n        }\n        gen.if(schValid, () => {\n          gen.assign(valid, true);\n          gen.assign(passing, i);\n          if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name);\n        });\n      });\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["Object","defineProperty","exports","value","codegen_1","require","util_1","error","message","params","_","passing","def","keyword","schemaType","trackErrors","code","cxt","gen","schema","parentSchema","it","Array","isArray","Error","opts","discriminator","schArr","valid","let","schValid","name","setParams","block","validateOneOf","result","reset","forEach","sch","i","schCxt","alwaysValidSchema","var","subschema","schemaProp","compositeRule","if","assign","else","mergeEvaluated","Name","default"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must match exactly one schema in oneOf\",\n    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,\n};\nconst def = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n            return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i) => {\n                let schCxt;\n                if ((0, util_1.alwaysValidSchema)(it, sch)) {\n                    gen.var(schValid, true);\n                }\n                else {\n                    schCxt = cxt.subschema({\n                        keyword: \"oneOf\",\n                        schemaProp: i,\n                        compositeRule: true,\n                    }, schValid);\n                }\n                if (i > 0) {\n                    gen\n                        .if((0, codegen_1._) `${schValid} && ${valid}`)\n                        .assign(valid, false)\n                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)\n                        .else();\n                }\n                gen.if(schValid, () => {\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt)\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}