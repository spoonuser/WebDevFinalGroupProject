{"ast":null,"code":"var Match = require('../match');\n\n/**\n * Charset recognizer for UTF-8\n */\nmodule.exports = function () {\n  this.name = function () {\n    return 'UTF-8';\n  };\n  this.match = function (det) {\n    var hasBOM = false,\n      numValid = 0,\n      numInvalid = 0,\n      input = det.fRawInput,\n      trailBytes = 0,\n      confidence;\n    if (det.fRawLength >= 3 && (input[0] & 0xff) == 0xef && (input[1] & 0xff) == 0xbb && (input[2] & 0xff) == 0xbf) {\n      hasBOM = true;\n    }\n\n    // Scan for multi-byte sequences\n    for (var i = 0; i < det.fRawLength; i++) {\n      var b = input[i];\n      if ((b & 0x80) == 0) continue; // ASCII\n\n      // Hi bit on char found.  Figure out how long the sequence should be\n      if ((b & 0x0e0) == 0x0c0) {\n        trailBytes = 1;\n      } else if ((b & 0x0f0) == 0x0e0) {\n        trailBytes = 2;\n      } else if ((b & 0x0f8) == 0xf0) {\n        trailBytes = 3;\n      } else {\n        numInvalid++;\n        if (numInvalid > 5) break;\n        trailBytes = 0;\n      }\n\n      // Verify that we've got the right number of trail bytes in the sequence\n      for (;;) {\n        i++;\n        if (i >= det.fRawLength) break;\n        if ((input[i] & 0xc0) != 0x080) {\n          numInvalid++;\n          break;\n        }\n        if (--trailBytes == 0) {\n          numValid++;\n          break;\n        }\n      }\n    }\n\n    // Cook up some sort of confidence score, based on presense of a BOM\n    //    and the existence of valid and/or invalid multi-byte sequences.\n    confidence = 0;\n    if (hasBOM && numInvalid == 0) confidence = 100;else if (hasBOM && numValid > numInvalid * 10) confidence = 80;else if (numValid > 3 && numInvalid == 0) confidence = 100;else if (numValid > 0 && numInvalid == 0) confidence = 80;else if (numValid == 0 && numInvalid == 0)\n      // Plain ASCII.\n      confidence = 10;else if (numValid > numInvalid * 10)\n      // Probably corruput utf-8 data.  Valid sequences aren't likely by chance.\n      confidence = 25;else return null;\n    return new Match(det, this, confidence);\n  };\n};","map":{"version":3,"names":["Match","require","module","exports","name","match","det","hasBOM","numValid","numInvalid","input","fRawInput","trailBytes","confidence","fRawLength","i","b"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/chardet/encoding/utf8.js"],"sourcesContent":["\nvar Match = require ('../match');\n\n/**\n * Charset recognizer for UTF-8\n */\nmodule.exports = function() {\n  this.name = function() {\n    return 'UTF-8';\n  };\n  this.match = function(det) {\n\n    var hasBOM = false,\n      numValid = 0,\n      numInvalid = 0,\n      input = det.fRawInput,\n      trailBytes = 0,\n      confidence;\n\n    if (det.fRawLength >= 3 &&\n      (input[0] & 0xff) == 0xef && (input[1] & 0xff) == 0xbb && (input[2] & 0xff) == 0xbf) {\n      hasBOM = true;\n    }\n\n    // Scan for multi-byte sequences\n    for (var i = 0; i < det.fRawLength; i++) {\n      var b = input[i];\n      if ((b & 0x80) == 0)\n        continue; // ASCII\n\n      // Hi bit on char found.  Figure out how long the sequence should be\n      if ((b & 0x0e0) == 0x0c0) {\n        trailBytes = 1;\n      } else if ((b & 0x0f0) == 0x0e0) {\n        trailBytes = 2;\n      } else if ((b & 0x0f8) == 0xf0) {\n        trailBytes = 3;\n      } else {\n        numInvalid++;\n        if (numInvalid > 5)\n          break;\n        trailBytes = 0;\n      }\n\n      // Verify that we've got the right number of trail bytes in the sequence\n      for (;;) {\n        i++;\n        if (i >= det.fRawLength)\n          break;\n\n        if ((input[i] & 0xc0) != 0x080) {\n          numInvalid++;\n          break;\n        }\n        if (--trailBytes == 0) {\n          numValid++;\n          break;\n        }\n      }\n    }\n\n    // Cook up some sort of confidence score, based on presense of a BOM\n    //    and the existence of valid and/or invalid multi-byte sequences.\n    confidence = 0;\n    if (hasBOM && numInvalid == 0)\n      confidence = 100;\n    else if (hasBOM && numValid > numInvalid * 10)\n      confidence = 80;\n    else if (numValid > 3 && numInvalid == 0)\n      confidence = 100;\n    else if (numValid > 0 && numInvalid == 0)\n      confidence = 80;\n    else if (numValid == 0 && numInvalid == 0)\n      // Plain ASCII.\n      confidence = 10;\n    else if (numValid > numInvalid * 10)\n      // Probably corruput utf-8 data.  Valid sequences aren't likely by chance.\n      confidence = 25;\n    else\n      return null\n\n    return new Match(det, this, confidence);\n  };\n};\n"],"mappings":"AACA,IAAIA,KAAK,GAAGC,OAAO,CAAE,UAAU,CAAC;;AAEhC;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAG,YAAW;EAC1B,IAAI,CAACC,IAAI,GAAG,YAAW;IACrB,OAAO,OAAO;EAChB,CAAC;EACD,IAAI,CAACC,KAAK,GAAG,UAASC,GAAG,EAAE;IAEzB,IAAIC,MAAM,GAAG,KAAK;MAChBC,QAAQ,GAAG,CAAC;MACZC,UAAU,GAAG,CAAC;MACdC,KAAK,GAAGJ,GAAG,CAACK,SAAS;MACrBC,UAAU,GAAG,CAAC;MACdC,UAAU;IAEZ,IAAIP,GAAG,CAACQ,UAAU,IAAI,CAAC,IACrB,CAACJ,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,KAAK,IAAI,IAAI,CAACA,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,KAAK,IAAI,IAAI,CAACA,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,KAAK,IAAI,EAAE;MACrFH,MAAM,GAAG,IAAI;IACf;;IAEA;IACA,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,GAAG,CAACQ,UAAU,EAAEC,CAAC,EAAE,EAAE;MACvC,IAAIC,CAAC,GAAGN,KAAK,CAACK,CAAC,CAAC;MAChB,IAAI,CAACC,CAAC,GAAG,IAAI,KAAK,CAAC,EACjB,SAAS,CAAC;;MAEZ;MACA,IAAI,CAACA,CAAC,GAAG,KAAK,KAAK,KAAK,EAAE;QACxBJ,UAAU,GAAG,CAAC;MAChB,CAAC,MAAM,IAAI,CAACI,CAAC,GAAG,KAAK,KAAK,KAAK,EAAE;QAC/BJ,UAAU,GAAG,CAAC;MAChB,CAAC,MAAM,IAAI,CAACI,CAAC,GAAG,KAAK,KAAK,IAAI,EAAE;QAC9BJ,UAAU,GAAG,CAAC;MAChB,CAAC,MAAM;QACLH,UAAU,EAAE;QACZ,IAAIA,UAAU,GAAG,CAAC,EAChB;QACFG,UAAU,GAAG,CAAC;MAChB;;MAEA;MACA,SAAS;QACPG,CAAC,EAAE;QACH,IAAIA,CAAC,IAAIT,GAAG,CAACQ,UAAU,EACrB;QAEF,IAAI,CAACJ,KAAK,CAACK,CAAC,CAAC,GAAG,IAAI,KAAK,KAAK,EAAE;UAC9BN,UAAU,EAAE;UACZ;QACF;QACA,IAAI,EAAEG,UAAU,IAAI,CAAC,EAAE;UACrBJ,QAAQ,EAAE;UACV;QACF;MACF;IACF;;IAEA;IACA;IACAK,UAAU,GAAG,CAAC;IACd,IAAIN,MAAM,IAAIE,UAAU,IAAI,CAAC,EAC3BI,UAAU,GAAG,GAAG,CAAC,KACd,IAAIN,MAAM,IAAIC,QAAQ,GAAGC,UAAU,GAAG,EAAE,EAC3CI,UAAU,GAAG,EAAE,CAAC,KACb,IAAIL,QAAQ,GAAG,CAAC,IAAIC,UAAU,IAAI,CAAC,EACtCI,UAAU,GAAG,GAAG,CAAC,KACd,IAAIL,QAAQ,GAAG,CAAC,IAAIC,UAAU,IAAI,CAAC,EACtCI,UAAU,GAAG,EAAE,CAAC,KACb,IAAIL,QAAQ,IAAI,CAAC,IAAIC,UAAU,IAAI,CAAC;MACvC;MACAI,UAAU,GAAG,EAAE,CAAC,KACb,IAAIL,QAAQ,GAAGC,UAAU,GAAG,EAAE;MACjC;MACAI,UAAU,GAAG,EAAE,CAAC,KAEhB,OAAO,IAAI;IAEb,OAAO,IAAIb,KAAK,CAACM,GAAG,EAAE,IAAI,EAAEO,UAAU,CAAC;EACzC,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}