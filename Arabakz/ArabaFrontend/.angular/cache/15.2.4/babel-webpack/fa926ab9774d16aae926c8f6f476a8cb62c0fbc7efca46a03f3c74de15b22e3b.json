{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it);\n      return;\n    }\n  }\n  validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({\n  gen,\n  validateName,\n  schema,\n  schemaEnv,\n  opts\n}, body) {\n  if (opts.code.es5) {\n    gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n      gen.code((0, codegen_1._)`\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n      destructureValCxtES5(gen, opts);\n      gen.code(body);\n    });\n  } else {\n    gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n  }\n}\nfunction destructureValCxt(opts) {\n  return (0, codegen_1._)`{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n  gen.if(names_1.default.valCxt, () => {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);\n    gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n    gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n  }, () => {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)`\"\"`);\n    gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);\n    gen.var(names_1.default.rootData, names_1.default.data);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);\n  });\n}\nfunction topSchemaObjCode(it) {\n  const {\n    schema,\n    opts,\n    gen\n  } = it;\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it);\n    checkNoDefault(it);\n    gen.let(names_1.default.vErrors, null);\n    gen.let(names_1.default.errors, 0);\n    if (opts.unevaluated) resetEvaluated(it);\n    typeAndKeywords(it);\n    returnResults(it);\n  });\n  return;\n}\nfunction resetEvaluated(it) {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {\n    gen,\n    validateName\n  } = it;\n  it.evaluated = gen.const(\"evaluated\", (0, codegen_1._)`${validateName}.evaluated`);\n  gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));\n  gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId];\n  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid);\n      return;\n    }\n  }\n  (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({\n  schema,\n  self\n}) {\n  if (typeof schema == \"boolean\") return !schema;\n  for (const key in schema) if (self.RULES.all[key]) return true;\n  return false;\n}\nfunction isSchemaObj(it) {\n  return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n  const {\n    schema,\n    gen,\n    opts\n  } = it;\n  if (opts.$comment && schema.$comment) commentKeyword(it);\n  updateContext(it);\n  checkAsyncSchema(it);\n  const errsCount = gen.const(\"_errs\", names_1.default.errors);\n  typeAndKeywords(it, errsCount);\n  // TODO var\n  gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n  (0, util_1.checkUnknownRules)(it);\n  checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);\n  const types = (0, dataType_1.getSchemaTypes)(it.schema);\n  const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n  schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n  const {\n    schema,\n    errSchemaPath,\n    opts,\n    self\n  } = it;\n  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n  }\n}\nfunction checkNoDefault(it) {\n  const {\n    schema,\n    opts\n  } = it;\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n  }\n}\nfunction updateContext(it) {\n  const schId = it.schema[it.opts.schemaId];\n  if (schId) it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({\n  gen,\n  schemaEnv,\n  schema,\n  errSchemaPath,\n  opts\n}) {\n  const msg = schema.$comment;\n  if (opts.$comment === true) {\n    gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;\n    const rootName = gen.scopeValue(\"root\", {\n      ref: schemaEnv.root\n    });\n    gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n  }\n}\nfunction returnResults(it) {\n  const {\n    gen,\n    schemaEnv,\n    validateName,\n    ValidationError,\n    opts\n  } = it;\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));\n  } else {\n    gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);\n    if (opts.unevaluated) assignEvaluated(it);\n    gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);\n  }\n}\nfunction assignEvaluated({\n  gen,\n  evaluated,\n  props,\n  items\n}) {\n  if (props instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.props`, props);\n  if (items instanceof codegen_1.Name) gen.assign((0, codegen_1._)`${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n  const {\n    gen,\n    schema,\n    data,\n    allErrors,\n    opts,\n    self\n  } = it;\n  const {\n    RULES\n  } = self;\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n    return;\n  }\n  if (!opts.jtd) checkStrictTypes(it, types);\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group);\n    groupKeywords(RULES.post);\n  });\n  function groupKeywords(group) {\n    if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;\n    if (group.type) {\n      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n      iterateKeywords(it, group);\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else();\n        (0, dataType_2.reportTypeError)(it);\n      }\n      gen.endIf();\n    } else {\n      iterateKeywords(it, group);\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);\n  }\n}\nfunction iterateKeywords(it, group) {\n  const {\n    gen,\n    schema,\n    opts: {\n      useDefaults\n    }\n  } = it;\n  if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type);\n      }\n    }\n  });\n}\nfunction checkStrictTypes(it, types) {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return;\n  checkContextTypes(it, types);\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);\n  checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n  if (!types.length) return;\n  if (!it.dataTypes.length) {\n    it.dataTypes = types;\n    return;\n  }\n  types.forEach(t => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n    }\n  });\n  narrowSchemaTypes(it, types);\n}\nfunction checkMultipleTypes(it, ts) {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n  }\n}\nfunction checkKeywordTypes(it, ts) {\n  const rules = it.self.RULES.all;\n  for (const keyword in rules) {\n    const rule = rules[keyword];\n    if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n      const {\n        type\n      } = rule.definition;\n      if (type.length && !type.some(t => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n      }\n    }\n  }\n}\nfunction hasApplicableType(schTs, kwdT) {\n  return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n}\nfunction includesType(ts, t) {\n  return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n}\nfunction narrowSchemaTypes(it, withTypes) {\n  const ts = [];\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t);else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\");\n  }\n  it.dataTypes = ts;\n}\nfunction strictTypesError(it, msg) {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n  msg += ` at \"${schemaPath}\" (strictTypes)`;\n  (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n  constructor(it, def, keyword) {\n    (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n    this.gen = it.gen;\n    this.allErrors = it.allErrors;\n    this.keyword = keyword;\n    this.data = it.data;\n    this.schema = it.schema[keyword];\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n    this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n    this.schemaType = def.schemaType;\n    this.parentSchema = it.schema;\n    this.params = {};\n    this.it = it;\n    this.def = def;\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n    } else {\n      this.schemaCode = this.schemaValue;\n      if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n      }\n    }\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n    }\n  }\n  result(condition, successAction, failAction) {\n    this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n  }\n  failResult(condition, successAction, failAction) {\n    this.gen.if(condition);\n    if (failAction) failAction();else this.error();\n    if (successAction) {\n      this.gen.else();\n      successAction();\n      if (this.allErrors) this.gen.endIf();\n    } else {\n      if (this.allErrors) this.gen.endIf();else this.gen.else();\n    }\n  }\n  pass(condition, failAction) {\n    this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n  }\n  fail(condition) {\n    if (condition === undefined) {\n      this.error();\n      if (!this.allErrors) this.gen.if(false); // this branch will be removed by gen.optimize\n      return;\n    }\n    this.gen.if(condition);\n    this.error();\n    if (this.allErrors) this.gen.endIf();else this.gen.else();\n  }\n  fail$data(condition) {\n    if (!this.$data) return this.fail(condition);\n    const {\n      schemaCode\n    } = this;\n    this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n  }\n  error(append, errorParams, errorPaths) {\n    if (errorParams) {\n      this.setParams(errorParams);\n      this._error(append, errorPaths);\n      this.setParams({});\n      return;\n    }\n    this._error(append, errorPaths);\n  }\n  _error(append, errorPaths) {\n    ;\n    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n  }\n  $dataError() {\n    (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n  }\n  reset() {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition');\n    (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n  }\n  ok(cond) {\n    if (!this.allErrors) this.gen.if(cond);\n  }\n  setParams(obj, assign) {\n    if (assign) Object.assign(this.params, obj);else this.params = obj;\n  }\n  block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid);\n      codeBlock();\n    });\n  }\n  check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n    if (!this.$data) return;\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def\n    } = this;\n    gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));\n    if (valid !== codegen_1.nil) gen.assign(valid, true);\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data());\n      this.$dataError();\n      if (valid !== codegen_1.nil) gen.assign(valid, false);\n    }\n    gen.else();\n  }\n  invalid$data() {\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def,\n      it\n    } = this;\n    return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n    function wrong$DataType() {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof codegen_1.Name)) throw new Error(\"ajv implementation error\");\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n        return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n      }\n      return codegen_1.nil;\n    }\n    function invalid$DataSchema() {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {\n          ref: def.validateSchema\n        }); // TODO value.code for standalone\n        return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;\n      }\n      return codegen_1.nil;\n    }\n  }\n  subschema(appl, valid) {\n    const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n    (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n    (0, subschema_1.extendSubschemaMode)(subschema, appl);\n    const nextContext = {\n      ...this.it,\n      ...subschema,\n      items: undefined,\n      props: undefined\n    };\n    subschemaCode(nextContext, valid);\n    return nextContext;\n  }\n  mergeEvaluated(schemaCxt, toName) {\n    const {\n      it,\n      gen\n    } = this;\n    if (!it.opts.unevaluated) return;\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n    }\n  }\n  mergeValidEvaluated(schemaCxt, valid) {\n    const {\n      it,\n      gen\n    } = this;\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n      return true;\n    }\n  }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n  const cxt = new KeywordCxt(it, def, keyword);\n  if (\"code\" in def) {\n    def.code(cxt, ruleType);\n  } else if (cxt.$data && def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  } else if (\"macro\" in def) {\n    (0, keyword_1.macroKeywordCode)(cxt, def);\n  } else if (def.compile || def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, {\n  dataLevel,\n  dataNames,\n  dataPathArr\n}) {\n  let jsonPointer;\n  let data;\n  if ($data === \"\") return names_1.default.rootData;\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);\n    jsonPointer = $data;\n    data = names_1.default.rootData;\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data);\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);\n    const up = +matches[1];\n    jsonPointer = matches[2];\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up));\n      return dataPathArr[dataLevel - up];\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up));\n    data = dataNames[dataLevel - up];\n    if (!jsonPointer) return data;\n  }\n  let expr = data;\n  const segments = jsonPointer.split(\"/\");\n  for (const segment of segments) {\n    if (segment) {\n      data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n      expr = (0, codegen_1._)`${expr} && ${data}`;\n    }\n  }\n  return expr;\n  function errorMsg(pointerType, up) {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n  }\n}\nexports.getData = getData;","map":{"version":3,"names":["Object","defineProperty","exports","value","getData","KeywordCxt","validateFunctionCode","boolSchema_1","require","dataType_1","applicability_1","dataType_2","defaults_1","keyword_1","subschema_1","codegen_1","names_1","resolve_1","util_1","errors_1","it","isSchemaObj","checkKeywords","schemaCxtHasRules","topSchemaObjCode","validateFunction","topBoolOrEmptySchema","gen","validateName","schema","schemaEnv","opts","body","code","es5","func","_","default","data","valCxt","$async","funcSourceUrl","destructureValCxtES5","destructureValCxt","instancePath","parentData","parentDataProperty","rootData","dynamicRef","dynamicAnchors","nil","if","var","$comment","commentKeyword","checkNoDefault","let","vErrors","errors","unevaluated","resetEvaluated","typeAndKeywords","returnResults","evaluated","const","assign","schId","schemaId","source","process","subschemaCode","valid","subSchemaObjCode","boolOrEmptySchema","self","key","RULES","all","updateContext","checkAsyncSchema","errsCount","checkUnknownRules","checkRefsAndKeywords","jtd","schemaKeywords","types","getSchemaTypes","checkedTypes","coerceAndCheckDataType","errSchemaPath","$ref","ignoreKeywordsWithRef","schemaHasRulesButRef","logger","warn","undefined","useDefaults","strictSchema","checkStrictMode","baseId","resolveUrl","uriResolver","Error","msg","schemaPath","str","rootName","scopeValue","ref","root","ValidationError","return","throw","assignEvaluated","props","items","Name","typeErrors","allErrors","block","keywordCode","definition","checkStrictTypes","group","rules","groupKeywords","post","shouldUseGroup","type","checkDataType","strictNumbers","iterateKeywords","length","else","reportTypeError","endIf","assignDefaults","rule","shouldUseRule","keyword","meta","strictTypes","checkContextTypes","allowUnionTypes","checkMultipleTypes","checkKeywordTypes","dataTypes","forEach","t","includesType","strictTypesError","join","narrowSchemaTypes","ts","includes","some","hasApplicableType","schTs","kwdT","withTypes","push","constructor","def","validateKeywordUsage","$data","schemaValue","schemaRefOrVal","schemaType","parentSchema","params","schemaCode","validSchemaType","allowUndefined","JSON","stringify","trackErrors","result","condition","successAction","failAction","failResult","not","error","pass","fail","fail$data","or","invalid$data","append","errorParams","errorPaths","setParams","_error","reportExtraError","reportError","$dataError","keyword$DataError","reset","resetErrorsCount","ok","cond","obj","block$data","codeBlock","$dataValid","check$data","validateSchema","elseIf","wrong$DataType","invalid$DataSchema","st","Array","isArray","checkDataTypes","DataType","Wrong","validateSchemaRef","subschema","appl","getSubschema","extendSubschemaData","extendSubschemaMode","nextContext","mergeEvaluated","schemaCxt","toName","mergeValidEvaluated","ruleType","cxt","validate","funcKeywordCode","macroKeywordCode","compile","JSON_POINTER","RELATIVE_JSON_POINTER","dataLevel","dataNames","dataPathArr","jsonPointer","test","matches","exec","up","errorMsg","expr","segments","split","segment","getProperty","unescapeJsonPointer","pointerType"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/ajv/dist/compile/validate/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    narrowSchemaTypes(it, types);\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction narrowSchemaTypes(it, withTypes) {\n    const ts = [];\n    for (const t of it.dataTypes) {\n        if (includesType(withTypes, t))\n            ts.push(t);\n        else if (withTypes.includes(\"integer\") && t === \"number\")\n            ts.push(\"integer\");\n    }\n    it.dataTypes = ts;\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}