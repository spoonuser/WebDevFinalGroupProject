{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst SourceMapGenerator = require(\"./source-map-generator\").SourceMapGenerator;\nconst util = require(\"./util\");\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nconst REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nconst NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nconst isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nclass SourceNode {\n  constructor(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n  }\n\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   * @param aRelativePath Optional. The path that relative sources in the\n   *        SourceMapConsumer should be relative to.\n   */\n  static fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    const node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    let remainingLinesIndex = 0;\n    const shiftNextLine = function () {\n      const lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      const newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    let lastGeneratedLine = 1,\n      lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    let lastMapping = null;\n    let nextLine;\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          nextLine = remainingLines[remainingLinesIndex] || \"\";\n          const code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        nextLine = remainingLines[remainingLinesIndex] || \"\";\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      const content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n    return node;\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        const source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n      }\n    }\n  }\n\n  /**\n   * Add a chunk of generated JS to this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  add(aChunk) {\n    if (Array.isArray(aChunk)) {\n      aChunk.forEach(function (chunk) {\n        this.add(chunk);\n      }, this);\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      if (aChunk) {\n        this.children.push(aChunk);\n      }\n    } else {\n      throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n    }\n    return this;\n  }\n\n  /**\n   * Add a chunk of generated JS to the beginning of this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n      for (let i = aChunk.length - 1; i >= 0; i--) {\n        this.prepend(aChunk[i]);\n      }\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      this.children.unshift(aChunk);\n    } else {\n      throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n    }\n    return this;\n  }\n\n  /**\n   * Walk over the tree of JS snippets in this node and its children. The\n   * walking function is called once for each snippet of JS and is passed that\n   * snippet and the its original associated source's line/column location.\n   *\n   * @param aFn The traversal function.\n   */\n  walk(aFn) {\n    let chunk;\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      chunk = this.children[i];\n      if (chunk[isSourceNode]) {\n        chunk.walk(aFn);\n      } else if (chunk !== \"\") {\n        aFn(chunk, {\n          source: this.source,\n          line: this.line,\n          column: this.column,\n          name: this.name\n        });\n      }\n    }\n  }\n\n  /**\n   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n   * each of `this.children`.\n   *\n   * @param aSep The separator.\n   */\n  join(aSep) {\n    let newChildren;\n    let i;\n    const len = this.children.length;\n    if (len > 0) {\n      newChildren = [];\n      for (i = 0; i < len - 1; i++) {\n        newChildren.push(this.children[i]);\n        newChildren.push(aSep);\n      }\n      newChildren.push(this.children[i]);\n      this.children = newChildren;\n    }\n    return this;\n  }\n\n  /**\n   * Call String.prototype.replace on the very right-most source snippet. Useful\n   * for trimming whitespace from the end of a source node, etc.\n   *\n   * @param aPattern The pattern to replace.\n   * @param aReplacement The thing to replace the pattern with.\n   */\n  replaceRight(aPattern, aReplacement) {\n    const lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n      lastChild.replaceRight(aPattern, aReplacement);\n    } else if (typeof lastChild === \"string\") {\n      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    } else {\n      this.children.push(\"\".replace(aPattern, aReplacement));\n    }\n    return this;\n  }\n\n  /**\n   * Set the source content for a source file. This will be added to the SourceMapGenerator\n   * in the sourcesContent field.\n   *\n   * @param aSourceFile The filename of the source file\n   * @param aSourceContent The content of the source file\n   */\n  setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  }\n\n  /**\n   * Walk over the tree of SourceNodes. The walking function is called for each\n   * source file content and is passed the filename and source content.\n   *\n   * @param aFn The traversal function.\n   */\n  walkSourceContents(aFn) {\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n    const sources = Object.keys(this.sourceContents);\n    for (let i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  }\n\n  /**\n   * Return the string representation of this source node. Walks over the tree\n   * and concatenates all the various snippets together to one string.\n   */\n  toString() {\n    let str = \"\";\n    this.walk(function (chunk) {\n      str += chunk;\n    });\n    return str;\n  }\n\n  /**\n   * Returns the string representation of this source node along with a source\n   * map.\n   */\n  toStringWithSourceMap(aArgs) {\n    const generated = {\n      code: \"\",\n      line: 1,\n      column: 0\n    };\n    const map = new SourceMapGenerator(aArgs);\n    let sourceMappingActive = false;\n    let lastOriginalSource = null;\n    let lastOriginalLine = null;\n    let lastOriginalColumn = null;\n    let lastOriginalName = null;\n    this.walk(function (chunk, original) {\n      generated.code += chunk;\n      if (original.source !== null && original.line !== null && original.column !== null) {\n        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n        lastOriginalSource = original.source;\n        lastOriginalLine = original.line;\n        lastOriginalColumn = original.column;\n        lastOriginalName = original.name;\n        sourceMappingActive = true;\n      } else if (sourceMappingActive) {\n        map.addMapping({\n          generated: {\n            line: generated.line,\n            column: generated.column\n          }\n        });\n        lastOriginalSource = null;\n        sourceMappingActive = false;\n      }\n      for (let idx = 0, length = chunk.length; idx < length; idx++) {\n        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n          generated.line++;\n          generated.column = 0;\n          // Mappings end at eol\n          if (idx + 1 === length) {\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column\n              },\n              name: original.name\n            });\n          }\n        } else {\n          generated.column++;\n        }\n      }\n    });\n    this.walkSourceContents(function (sourceFile, sourceContent) {\n      map.setSourceContent(sourceFile, sourceContent);\n    });\n    return {\n      code: generated.code,\n      map\n    };\n  }\n}\nexports.SourceNode = SourceNode;","map":{"version":3,"names":["SourceMapGenerator","require","util","REGEX_NEWLINE","NEWLINE_CODE","isSourceNode","SourceNode","constructor","aLine","aColumn","aSource","aChunks","aName","children","sourceContents","line","column","source","name","add","fromStringWithSourceMap","aGeneratedCode","aSourceMapConsumer","aRelativePath","node","remainingLines","split","remainingLinesIndex","shiftNextLine","lineContents","getNextLine","newLine","length","undefined","lastGeneratedLine","lastGeneratedColumn","lastMapping","nextLine","eachMapping","mapping","generatedLine","addMappingWithCode","code","substr","generatedColumn","splice","join","sources","forEach","sourceFile","content","sourceContentFor","setSourceContent","originalLine","originalColumn","aChunk","Array","isArray","chunk","push","TypeError","prepend","i","unshift","walk","aFn","len","aSep","newChildren","replaceRight","aPattern","aReplacement","lastChild","replace","aSourceFile","aSourceContent","toSetString","walkSourceContents","Object","keys","fromSetString","toString","str","toStringWithSourceMap","aArgs","generated","map","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","original","addMapping","idx","charCodeAt","sourceContent","exports"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/source-map/lib/source-node.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst SourceMapGenerator = require(\"./source-map-generator\").SourceMapGenerator;\nconst util = require(\"./util\");\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nconst REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nconst NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nconst isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nclass SourceNode {\n  constructor(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n  }\n\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   * @param aRelativePath Optional. The path that relative sources in the\n   *        SourceMapConsumer should be relative to.\n   */\n  static fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    const node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    let remainingLinesIndex = 0;\n    const shiftNextLine = function() {\n      const lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      const newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    let lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    let lastMapping = null;\n    let nextLine;\n\n    aSourceMapConsumer.eachMapping(function(mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          nextLine = remainingLines[remainingLinesIndex] || \"\";\n          const code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        nextLine = remainingLines[remainingLinesIndex] || \"\";\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n      const content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        const source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  }\n\n  /**\n   * Add a chunk of generated JS to this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  add(aChunk) {\n    if (Array.isArray(aChunk)) {\n      aChunk.forEach(function(chunk) {\n        this.add(chunk);\n      }, this);\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      if (aChunk) {\n        this.children.push(aChunk);\n      }\n    } else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Add a chunk of generated JS to the beginning of this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n      for (let i = aChunk.length - 1; i >= 0; i--) {\n        this.prepend(aChunk[i]);\n      }\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      this.children.unshift(aChunk);\n    } else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Walk over the tree of JS snippets in this node and its children. The\n   * walking function is called once for each snippet of JS and is passed that\n   * snippet and the its original associated source's line/column location.\n   *\n   * @param aFn The traversal function.\n   */\n  walk(aFn) {\n    let chunk;\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      chunk = this.children[i];\n      if (chunk[isSourceNode]) {\n        chunk.walk(aFn);\n      } else if (chunk !== \"\") {\n        aFn(chunk, { source: this.source,\n                      line: this.line,\n                      column: this.column,\n                      name: this.name });\n      }\n    }\n  }\n\n  /**\n   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n   * each of `this.children`.\n   *\n   * @param aSep The separator.\n   */\n  join(aSep) {\n    let newChildren;\n    let i;\n    const len = this.children.length;\n    if (len > 0) {\n      newChildren = [];\n      for (i = 0; i < len - 1; i++) {\n        newChildren.push(this.children[i]);\n        newChildren.push(aSep);\n      }\n      newChildren.push(this.children[i]);\n      this.children = newChildren;\n    }\n    return this;\n  }\n\n  /**\n   * Call String.prototype.replace on the very right-most source snippet. Useful\n   * for trimming whitespace from the end of a source node, etc.\n   *\n   * @param aPattern The pattern to replace.\n   * @param aReplacement The thing to replace the pattern with.\n   */\n  replaceRight(aPattern, aReplacement) {\n    const lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n      lastChild.replaceRight(aPattern, aReplacement);\n    } else if (typeof lastChild === \"string\") {\n      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    } else {\n      this.children.push(\"\".replace(aPattern, aReplacement));\n    }\n    return this;\n  }\n\n  /**\n   * Set the source content for a source file. This will be added to the SourceMapGenerator\n   * in the sourcesContent field.\n   *\n   * @param aSourceFile The filename of the source file\n   * @param aSourceContent The content of the source file\n   */\n  setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  }\n\n  /**\n   * Walk over the tree of SourceNodes. The walking function is called for each\n   * source file content and is passed the filename and source content.\n   *\n   * @param aFn The traversal function.\n   */\n  walkSourceContents(aFn) {\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    const sources = Object.keys(this.sourceContents);\n    for (let i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  }\n\n  /**\n   * Return the string representation of this source node. Walks over the tree\n   * and concatenates all the various snippets together to one string.\n   */\n  toString() {\n    let str = \"\";\n    this.walk(function(chunk) {\n      str += chunk;\n    });\n    return str;\n  }\n\n  /**\n   * Returns the string representation of this source node along with a source\n   * map.\n   */\n  toStringWithSourceMap(aArgs) {\n    const generated = {\n      code: \"\",\n      line: 1,\n      column: 0\n    };\n    const map = new SourceMapGenerator(aArgs);\n    let sourceMappingActive = false;\n    let lastOriginalSource = null;\n    let lastOriginalLine = null;\n    let lastOriginalColumn = null;\n    let lastOriginalName = null;\n    this.walk(function(chunk, original) {\n      generated.code += chunk;\n      if (original.source !== null\n          && original.line !== null\n          && original.column !== null) {\n        if (lastOriginalSource !== original.source\n          || lastOriginalLine !== original.line\n          || lastOriginalColumn !== original.column\n          || lastOriginalName !== original.name) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n        lastOriginalSource = original.source;\n        lastOriginalLine = original.line;\n        lastOriginalColumn = original.column;\n        lastOriginalName = original.name;\n        sourceMappingActive = true;\n      } else if (sourceMappingActive) {\n        map.addMapping({\n          generated: {\n            line: generated.line,\n            column: generated.column\n          }\n        });\n        lastOriginalSource = null;\n        sourceMappingActive = false;\n      }\n      for (let idx = 0, length = chunk.length; idx < length; idx++) {\n        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n          generated.line++;\n          generated.column = 0;\n          // Mappings end at eol\n          if (idx + 1 === length) {\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column\n              },\n              name: original.name\n            });\n          }\n        } else {\n          generated.column++;\n        }\n      }\n    });\n    this.walkSourceContents(function(sourceFile, sourceContent) {\n      map.setSourceContent(sourceFile, sourceContent);\n    });\n\n    return { code: generated.code, map };\n  }\n}\n\nexports.SourceNode = SourceNode;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}