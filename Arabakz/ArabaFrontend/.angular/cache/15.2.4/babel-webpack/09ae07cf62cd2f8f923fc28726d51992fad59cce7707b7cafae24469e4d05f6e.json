{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FilterHostTree = exports.HostCreateTree = exports.HostTree = exports.HostDirEntry = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst jsonc_parser_1 = require(\"jsonc-parser\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst util_1 = require(\"util\");\nconst exception_1 = require(\"../exception/exception\");\nconst delegate_1 = require(\"./delegate\");\nconst entry_1 = require(\"./entry\");\nconst interface_1 = require(\"./interface\");\nconst recorder_1 = require(\"./recorder\");\nconst scoped_1 = require(\"./scoped\");\nlet _uniqueId = 0;\nclass HostDirEntry {\n  constructor(parent, path, _host, _tree) {\n    this.parent = parent;\n    this.path = path;\n    this._host = _host;\n    this._tree = _tree;\n  }\n  get subdirs() {\n    return this._host.list(this.path).filter(fragment => this._host.isDirectory((0, core_1.join)(this.path, fragment)));\n  }\n  get subfiles() {\n    return this._host.list(this.path).filter(fragment => this._host.isFile((0, core_1.join)(this.path, fragment)));\n  }\n  dir(name) {\n    return this._tree.getDir((0, core_1.join)(this.path, name));\n  }\n  file(name) {\n    return this._tree.get((0, core_1.join)(this.path, name));\n  }\n  visit(visitor) {\n    try {\n      this.getSubfilesRecursively().forEach(file => visitor(file.path, file));\n    } catch (e) {\n      if (e !== interface_1.FileVisitorCancelToken) {\n        throw e;\n      }\n    }\n  }\n  getSubfilesRecursively() {\n    function _recurse(entry) {\n      return entry.subdirs.reduce((files, subdir) => [...files, ..._recurse(entry.dir(subdir))], entry.subfiles.map(subfile => entry.file(subfile)));\n    }\n    return _recurse(this);\n  }\n}\nexports.HostDirEntry = HostDirEntry;\nclass HostTree {\n  [interface_1.TreeSymbol]() {\n    return this;\n  }\n  static isHostTree(tree) {\n    if (tree instanceof HostTree) {\n      return true;\n    }\n    if (typeof tree === 'object' && typeof tree._ancestry === 'object') {\n      return true;\n    }\n    return false;\n  }\n  constructor(_backend = new core_1.virtualFs.Empty()) {\n    this._backend = _backend;\n    this._id = --_uniqueId;\n    this._ancestry = new Set();\n    this._dirCache = new Map();\n    this._record = new core_1.virtualFs.CordHost(new core_1.virtualFs.SafeReadonlyHost(_backend));\n    this._recordSync = new core_1.virtualFs.SyncDelegateHost(this._record);\n  }\n  _normalizePath(path) {\n    return (0, core_1.normalize)('/' + path);\n  }\n  _willCreate(path) {\n    return this._record.willCreate(path);\n  }\n  _willOverwrite(path) {\n    return this._record.willOverwrite(path);\n  }\n  _willDelete(path) {\n    return this._record.willDelete(path);\n  }\n  _willRename(path) {\n    return this._record.willRename(path);\n  }\n  branch() {\n    const branchedTree = new HostTree(this._backend);\n    branchedTree._record = this._record.clone();\n    branchedTree._recordSync = new core_1.virtualFs.SyncDelegateHost(branchedTree._record);\n    branchedTree._ancestry = new Set(this._ancestry).add(this._id);\n    return branchedTree;\n  }\n  isAncestorOf(tree) {\n    if (tree instanceof HostTree) {\n      return tree._ancestry.has(this._id);\n    }\n    if (tree instanceof delegate_1.DelegateTree) {\n      return this.isAncestorOf(tree._other);\n    }\n    if (tree instanceof scoped_1.ScopedTree) {\n      return this.isAncestorOf(tree._base);\n    }\n    return false;\n  }\n  merge(other, strategy = interface_1.MergeStrategy.Default) {\n    if (other === this) {\n      // Merging with yourself? Tsk tsk. Nothing to do at least.\n      return;\n    }\n    if (this.isAncestorOf(other)) {\n      // Workaround for merging a branch back into one of its ancestors\n      // More complete branch point tracking is required to avoid\n      strategy |= interface_1.MergeStrategy.Overwrite;\n    }\n    const creationConflictAllowed = (strategy & interface_1.MergeStrategy.AllowCreationConflict) == interface_1.MergeStrategy.AllowCreationConflict;\n    const overwriteConflictAllowed = (strategy & interface_1.MergeStrategy.AllowOverwriteConflict) == interface_1.MergeStrategy.AllowOverwriteConflict;\n    const deleteConflictAllowed = (strategy & interface_1.MergeStrategy.AllowDeleteConflict) == interface_1.MergeStrategy.AllowDeleteConflict;\n    other.actions.forEach(action => {\n      switch (action.kind) {\n        case 'c':\n          {\n            const {\n              path,\n              content\n            } = action;\n            if (this._willCreate(path) || this._willOverwrite(path) || this.exists(path)) {\n              const existingContent = this.read(path);\n              if (existingContent && content.equals(existingContent)) {\n                // Identical outcome; no action required\n                return;\n              }\n              if (!creationConflictAllowed) {\n                throw new exception_1.MergeConflictException(path);\n              }\n              this._record.overwrite(path, content).subscribe();\n            } else {\n              this._record.create(path, content).subscribe();\n            }\n            return;\n          }\n        case 'o':\n          {\n            const {\n              path,\n              content\n            } = action;\n            if (this._willDelete(path) && !overwriteConflictAllowed) {\n              throw new exception_1.MergeConflictException(path);\n            }\n            // Ignore if content is the same (considered the same change).\n            if (this._willOverwrite(path)) {\n              const existingContent = this.read(path);\n              if (existingContent && content.equals(existingContent)) {\n                // Identical outcome; no action required\n                return;\n              }\n              if (!overwriteConflictAllowed) {\n                throw new exception_1.MergeConflictException(path);\n              }\n            }\n            // We use write here as merge validation has already been done, and we want to let\n            // the CordHost do its job.\n            this._record.write(path, content).subscribe();\n            return;\n          }\n        case 'r':\n          {\n            const {\n              path,\n              to\n            } = action;\n            if (this._willDelete(path)) {\n              throw new exception_1.MergeConflictException(path);\n            }\n            if (this._willRename(path)) {\n              if (this._record.willRenameTo(path, to)) {\n                // Identical outcome; no action required\n                return;\n              }\n              // No override possible for renaming.\n              throw new exception_1.MergeConflictException(path);\n            }\n            this.rename(path, to);\n            return;\n          }\n        case 'd':\n          {\n            const {\n              path\n            } = action;\n            if (this._willDelete(path)) {\n              // TODO: This should technically check the content (e.g., hash on delete)\n              // Identical outcome; no action required\n              return;\n            }\n            if (!this.exists(path) && !deleteConflictAllowed) {\n              throw new exception_1.MergeConflictException(path);\n            }\n            this._recordSync.delete(path);\n            return;\n          }\n      }\n    });\n  }\n  get root() {\n    return this.getDir('/');\n  }\n  // Readonly.\n  read(path) {\n    const entry = this.get(path);\n    return entry ? entry.content : null;\n  }\n  readText(path) {\n    const data = this.read(path);\n    if (data === null) {\n      throw new exception_1.FileDoesNotExistException(path);\n    }\n    const decoder = new util_1.TextDecoder('utf-8', {\n      fatal: true\n    });\n    try {\n      // With the `fatal` option enabled, invalid data will throw a TypeError\n      return decoder.decode(data);\n    } catch (e) {\n      if (e instanceof TypeError) {\n        throw new Error(`Failed to decode \"${path}\" as UTF-8 text.`);\n      }\n      throw e;\n    }\n  }\n  readJson(path) {\n    const content = this.readText(path);\n    const errors = [];\n    const result = (0, jsonc_parser_1.parse)(content, errors, {\n      allowTrailingComma: true\n    });\n    // If there is a parse error throw with the error information\n    if (errors[0]) {\n      const {\n        error,\n        offset\n      } = errors[0];\n      throw new Error(`Failed to parse \"${path}\" as JSON. ${(0, jsonc_parser_1.printParseErrorCode)(error)} at offset: ${offset}.`);\n    }\n    return result;\n  }\n  exists(path) {\n    return this._recordSync.isFile(this._normalizePath(path));\n  }\n  get(path) {\n    const p = this._normalizePath(path);\n    if (this._recordSync.isDirectory(p)) {\n      throw new core_1.PathIsDirectoryException(p);\n    }\n    if (!this._recordSync.exists(p)) {\n      return null;\n    }\n    return new entry_1.LazyFileEntry(p, () => Buffer.from(this._recordSync.read(p)));\n  }\n  getDir(path) {\n    const p = this._normalizePath(path);\n    if (this._recordSync.isFile(p)) {\n      throw new core_1.PathIsFileException(p);\n    }\n    let maybeCache = this._dirCache.get(p);\n    if (!maybeCache) {\n      let parent = (0, core_1.dirname)(p);\n      if (p === parent) {\n        parent = null;\n      }\n      maybeCache = new HostDirEntry(parent && this.getDir(parent), p, this._recordSync, this);\n      this._dirCache.set(p, maybeCache);\n    }\n    return maybeCache;\n  }\n  visit(visitor) {\n    this.root.visit((path, entry) => {\n      visitor(path, entry);\n    });\n  }\n  // Change content of host files.\n  overwrite(path, content) {\n    const p = this._normalizePath(path);\n    if (!this._recordSync.exists(p)) {\n      throw new exception_1.FileDoesNotExistException(p);\n    }\n    const c = typeof content == 'string' ? Buffer.from(content) : content;\n    this._record.overwrite(p, c).subscribe();\n  }\n  beginUpdate(path) {\n    const entry = this.get(path);\n    if (!entry) {\n      throw new exception_1.FileDoesNotExistException(path);\n    }\n    return recorder_1.UpdateRecorderBase.createFromFileEntry(entry);\n  }\n  commitUpdate(record) {\n    if (record instanceof recorder_1.UpdateRecorderBase) {\n      const path = record.path;\n      const entry = this.get(path);\n      if (!entry) {\n        throw new exception_1.ContentHasMutatedException(path);\n      } else {\n        const newContent = record.apply(entry.content);\n        if (!newContent.equals(entry.content)) {\n          this.overwrite(path, newContent);\n        }\n      }\n    } else {\n      throw new exception_1.InvalidUpdateRecordException();\n    }\n  }\n  // Structural methods.\n  create(path, content) {\n    const p = this._normalizePath(path);\n    if (this._recordSync.exists(p)) {\n      throw new exception_1.FileAlreadyExistException(p);\n    }\n    const c = typeof content == 'string' ? Buffer.from(content) : content;\n    this._record.create(p, c).subscribe();\n  }\n  delete(path) {\n    this._recordSync.delete(this._normalizePath(path));\n  }\n  rename(from, to) {\n    this._recordSync.rename(this._normalizePath(from), this._normalizePath(to));\n  }\n  apply(action, strategy) {\n    throw new exception_1.SchematicsException('Apply not implemented on host trees.');\n  }\n  *generateActions() {\n    for (const record of this._record.records()) {\n      switch (record.kind) {\n        case 'create':\n          yield {\n            id: this._id,\n            parent: 0,\n            kind: 'c',\n            path: record.path,\n            content: Buffer.from(record.content)\n          };\n          break;\n        case 'overwrite':\n          yield {\n            id: this._id,\n            parent: 0,\n            kind: 'o',\n            path: record.path,\n            content: Buffer.from(record.content)\n          };\n          break;\n        case 'rename':\n          yield {\n            id: this._id,\n            parent: 0,\n            kind: 'r',\n            path: record.from,\n            to: record.to\n          };\n          break;\n        case 'delete':\n          yield {\n            id: this._id,\n            parent: 0,\n            kind: 'd',\n            path: record.path\n          };\n          break;\n      }\n    }\n  }\n  get actions() {\n    // Create a list of all records until we hit our original backend. This is to support branches\n    // that diverge from each others.\n    return Array.from(this.generateActions());\n  }\n}\nexports.HostTree = HostTree;\nclass HostCreateTree extends HostTree {\n  constructor(host) {\n    super();\n    const tempHost = new HostTree(host);\n    tempHost.visit(path => {\n      const content = tempHost.read(path);\n      if (content) {\n        this.create(path, content);\n      }\n    });\n  }\n}\nexports.HostCreateTree = HostCreateTree;\nclass FilterHostTree extends HostTree {\n  constructor(tree, filter = () => true) {\n    const newBackend = new core_1.virtualFs.SimpleMemoryHost();\n    // cast to allow access\n    const originalBackend = tree._backend;\n    const recurse = base => {\n      return originalBackend.list(base).pipe((0, operators_1.mergeMap)(x => x), (0, operators_1.map)(path => (0, core_1.join)(base, path)), (0, operators_1.concatMap)(path => {\n        let isDirectory = false;\n        originalBackend.isDirectory(path).subscribe(val => isDirectory = val);\n        if (isDirectory) {\n          return recurse(path);\n        }\n        let isFile = false;\n        originalBackend.isFile(path).subscribe(val => isFile = val);\n        if (!isFile || !filter(path)) {\n          return rxjs_1.EMPTY;\n        }\n        let content = null;\n        originalBackend.read(path).subscribe(val => content = val);\n        if (!content) {\n          return rxjs_1.EMPTY;\n        }\n        return newBackend.write(path, content);\n      }));\n    };\n    recurse((0, core_1.normalize)('/')).subscribe();\n    super(newBackend);\n    for (const action of tree.actions) {\n      if (!filter(action.path)) {\n        continue;\n      }\n      switch (action.kind) {\n        case 'c':\n          this.create(action.path, action.content);\n          break;\n        case 'd':\n          this.delete(action.path);\n          break;\n        case 'o':\n          this.overwrite(action.path, action.content);\n          break;\n        case 'r':\n          this.rename(action.path, action.to);\n          break;\n      }\n    }\n  }\n}\nexports.FilterHostTree = FilterHostTree;","map":{"version":3,"names":["Object","defineProperty","exports","value","FilterHostTree","HostCreateTree","HostTree","HostDirEntry","core_1","require","jsonc_parser_1","rxjs_1","operators_1","util_1","exception_1","delegate_1","entry_1","interface_1","recorder_1","scoped_1","_uniqueId","constructor","parent","path","_host","_tree","subdirs","list","filter","fragment","isDirectory","join","subfiles","isFile","dir","name","getDir","file","get","visit","visitor","getSubfilesRecursively","forEach","e","FileVisitorCancelToken","_recurse","entry","reduce","files","subdir","map","subfile","TreeSymbol","isHostTree","tree","_ancestry","_backend","virtualFs","Empty","_id","Set","_dirCache","Map","_record","CordHost","SafeReadonlyHost","_recordSync","SyncDelegateHost","_normalizePath","normalize","_willCreate","willCreate","_willOverwrite","willOverwrite","_willDelete","willDelete","_willRename","willRename","branch","branchedTree","clone","add","isAncestorOf","has","DelegateTree","_other","ScopedTree","_base","merge","other","strategy","MergeStrategy","Default","Overwrite","creationConflictAllowed","AllowCreationConflict","overwriteConflictAllowed","AllowOverwriteConflict","deleteConflictAllowed","AllowDeleteConflict","actions","action","kind","content","exists","existingContent","read","equals","MergeConflictException","overwrite","subscribe","create","write","to","willRenameTo","rename","delete","root","readText","data","FileDoesNotExistException","decoder","TextDecoder","fatal","decode","TypeError","Error","readJson","errors","result","parse","allowTrailingComma","error","offset","printParseErrorCode","p","PathIsDirectoryException","LazyFileEntry","Buffer","from","PathIsFileException","maybeCache","dirname","set","c","beginUpdate","UpdateRecorderBase","createFromFileEntry","commitUpdate","record","ContentHasMutatedException","newContent","apply","InvalidUpdateRecordException","FileAlreadyExistException","SchematicsException","generateActions","records","id","Array","host","tempHost","newBackend","SimpleMemoryHost","originalBackend","recurse","base","pipe","mergeMap","x","concatMap","val","EMPTY"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular-devkit/schematics/src/tree/host-tree.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FilterHostTree = exports.HostCreateTree = exports.HostTree = exports.HostDirEntry = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst jsonc_parser_1 = require(\"jsonc-parser\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst util_1 = require(\"util\");\nconst exception_1 = require(\"../exception/exception\");\nconst delegate_1 = require(\"./delegate\");\nconst entry_1 = require(\"./entry\");\nconst interface_1 = require(\"./interface\");\nconst recorder_1 = require(\"./recorder\");\nconst scoped_1 = require(\"./scoped\");\nlet _uniqueId = 0;\nclass HostDirEntry {\n    constructor(parent, path, _host, _tree) {\n        this.parent = parent;\n        this.path = path;\n        this._host = _host;\n        this._tree = _tree;\n    }\n    get subdirs() {\n        return this._host\n            .list(this.path)\n            .filter((fragment) => this._host.isDirectory((0, core_1.join)(this.path, fragment)));\n    }\n    get subfiles() {\n        return this._host\n            .list(this.path)\n            .filter((fragment) => this._host.isFile((0, core_1.join)(this.path, fragment)));\n    }\n    dir(name) {\n        return this._tree.getDir((0, core_1.join)(this.path, name));\n    }\n    file(name) {\n        return this._tree.get((0, core_1.join)(this.path, name));\n    }\n    visit(visitor) {\n        try {\n            this.getSubfilesRecursively().forEach((file) => visitor(file.path, file));\n        }\n        catch (e) {\n            if (e !== interface_1.FileVisitorCancelToken) {\n                throw e;\n            }\n        }\n    }\n    getSubfilesRecursively() {\n        function _recurse(entry) {\n            return entry.subdirs.reduce((files, subdir) => [...files, ..._recurse(entry.dir(subdir))], entry.subfiles.map((subfile) => entry.file(subfile)));\n        }\n        return _recurse(this);\n    }\n}\nexports.HostDirEntry = HostDirEntry;\nclass HostTree {\n    [interface_1.TreeSymbol]() {\n        return this;\n    }\n    static isHostTree(tree) {\n        if (tree instanceof HostTree) {\n            return true;\n        }\n        if (typeof tree === 'object' && typeof tree._ancestry === 'object') {\n            return true;\n        }\n        return false;\n    }\n    constructor(_backend = new core_1.virtualFs.Empty()) {\n        this._backend = _backend;\n        this._id = --_uniqueId;\n        this._ancestry = new Set();\n        this._dirCache = new Map();\n        this._record = new core_1.virtualFs.CordHost(new core_1.virtualFs.SafeReadonlyHost(_backend));\n        this._recordSync = new core_1.virtualFs.SyncDelegateHost(this._record);\n    }\n    _normalizePath(path) {\n        return (0, core_1.normalize)('/' + path);\n    }\n    _willCreate(path) {\n        return this._record.willCreate(path);\n    }\n    _willOverwrite(path) {\n        return this._record.willOverwrite(path);\n    }\n    _willDelete(path) {\n        return this._record.willDelete(path);\n    }\n    _willRename(path) {\n        return this._record.willRename(path);\n    }\n    branch() {\n        const branchedTree = new HostTree(this._backend);\n        branchedTree._record = this._record.clone();\n        branchedTree._recordSync = new core_1.virtualFs.SyncDelegateHost(branchedTree._record);\n        branchedTree._ancestry = new Set(this._ancestry).add(this._id);\n        return branchedTree;\n    }\n    isAncestorOf(tree) {\n        if (tree instanceof HostTree) {\n            return tree._ancestry.has(this._id);\n        }\n        if (tree instanceof delegate_1.DelegateTree) {\n            return this.isAncestorOf(tree._other);\n        }\n        if (tree instanceof scoped_1.ScopedTree) {\n            return this.isAncestorOf(tree._base);\n        }\n        return false;\n    }\n    merge(other, strategy = interface_1.MergeStrategy.Default) {\n        if (other === this) {\n            // Merging with yourself? Tsk tsk. Nothing to do at least.\n            return;\n        }\n        if (this.isAncestorOf(other)) {\n            // Workaround for merging a branch back into one of its ancestors\n            // More complete branch point tracking is required to avoid\n            strategy |= interface_1.MergeStrategy.Overwrite;\n        }\n        const creationConflictAllowed = (strategy & interface_1.MergeStrategy.AllowCreationConflict) == interface_1.MergeStrategy.AllowCreationConflict;\n        const overwriteConflictAllowed = (strategy & interface_1.MergeStrategy.AllowOverwriteConflict) == interface_1.MergeStrategy.AllowOverwriteConflict;\n        const deleteConflictAllowed = (strategy & interface_1.MergeStrategy.AllowDeleteConflict) == interface_1.MergeStrategy.AllowDeleteConflict;\n        other.actions.forEach((action) => {\n            switch (action.kind) {\n                case 'c': {\n                    const { path, content } = action;\n                    if (this._willCreate(path) || this._willOverwrite(path) || this.exists(path)) {\n                        const existingContent = this.read(path);\n                        if (existingContent && content.equals(existingContent)) {\n                            // Identical outcome; no action required\n                            return;\n                        }\n                        if (!creationConflictAllowed) {\n                            throw new exception_1.MergeConflictException(path);\n                        }\n                        this._record.overwrite(path, content).subscribe();\n                    }\n                    else {\n                        this._record.create(path, content).subscribe();\n                    }\n                    return;\n                }\n                case 'o': {\n                    const { path, content } = action;\n                    if (this._willDelete(path) && !overwriteConflictAllowed) {\n                        throw new exception_1.MergeConflictException(path);\n                    }\n                    // Ignore if content is the same (considered the same change).\n                    if (this._willOverwrite(path)) {\n                        const existingContent = this.read(path);\n                        if (existingContent && content.equals(existingContent)) {\n                            // Identical outcome; no action required\n                            return;\n                        }\n                        if (!overwriteConflictAllowed) {\n                            throw new exception_1.MergeConflictException(path);\n                        }\n                    }\n                    // We use write here as merge validation has already been done, and we want to let\n                    // the CordHost do its job.\n                    this._record.write(path, content).subscribe();\n                    return;\n                }\n                case 'r': {\n                    const { path, to } = action;\n                    if (this._willDelete(path)) {\n                        throw new exception_1.MergeConflictException(path);\n                    }\n                    if (this._willRename(path)) {\n                        if (this._record.willRenameTo(path, to)) {\n                            // Identical outcome; no action required\n                            return;\n                        }\n                        // No override possible for renaming.\n                        throw new exception_1.MergeConflictException(path);\n                    }\n                    this.rename(path, to);\n                    return;\n                }\n                case 'd': {\n                    const { path } = action;\n                    if (this._willDelete(path)) {\n                        // TODO: This should technically check the content (e.g., hash on delete)\n                        // Identical outcome; no action required\n                        return;\n                    }\n                    if (!this.exists(path) && !deleteConflictAllowed) {\n                        throw new exception_1.MergeConflictException(path);\n                    }\n                    this._recordSync.delete(path);\n                    return;\n                }\n            }\n        });\n    }\n    get root() {\n        return this.getDir('/');\n    }\n    // Readonly.\n    read(path) {\n        const entry = this.get(path);\n        return entry ? entry.content : null;\n    }\n    readText(path) {\n        const data = this.read(path);\n        if (data === null) {\n            throw new exception_1.FileDoesNotExistException(path);\n        }\n        const decoder = new util_1.TextDecoder('utf-8', { fatal: true });\n        try {\n            // With the `fatal` option enabled, invalid data will throw a TypeError\n            return decoder.decode(data);\n        }\n        catch (e) {\n            if (e instanceof TypeError) {\n                throw new Error(`Failed to decode \"${path}\" as UTF-8 text.`);\n            }\n            throw e;\n        }\n    }\n    readJson(path) {\n        const content = this.readText(path);\n        const errors = [];\n        const result = (0, jsonc_parser_1.parse)(content, errors, { allowTrailingComma: true });\n        // If there is a parse error throw with the error information\n        if (errors[0]) {\n            const { error, offset } = errors[0];\n            throw new Error(`Failed to parse \"${path}\" as JSON. ${(0, jsonc_parser_1.printParseErrorCode)(error)} at offset: ${offset}.`);\n        }\n        return result;\n    }\n    exists(path) {\n        return this._recordSync.isFile(this._normalizePath(path));\n    }\n    get(path) {\n        const p = this._normalizePath(path);\n        if (this._recordSync.isDirectory(p)) {\n            throw new core_1.PathIsDirectoryException(p);\n        }\n        if (!this._recordSync.exists(p)) {\n            return null;\n        }\n        return new entry_1.LazyFileEntry(p, () => Buffer.from(this._recordSync.read(p)));\n    }\n    getDir(path) {\n        const p = this._normalizePath(path);\n        if (this._recordSync.isFile(p)) {\n            throw new core_1.PathIsFileException(p);\n        }\n        let maybeCache = this._dirCache.get(p);\n        if (!maybeCache) {\n            let parent = (0, core_1.dirname)(p);\n            if (p === parent) {\n                parent = null;\n            }\n            maybeCache = new HostDirEntry(parent && this.getDir(parent), p, this._recordSync, this);\n            this._dirCache.set(p, maybeCache);\n        }\n        return maybeCache;\n    }\n    visit(visitor) {\n        this.root.visit((path, entry) => {\n            visitor(path, entry);\n        });\n    }\n    // Change content of host files.\n    overwrite(path, content) {\n        const p = this._normalizePath(path);\n        if (!this._recordSync.exists(p)) {\n            throw new exception_1.FileDoesNotExistException(p);\n        }\n        const c = typeof content == 'string' ? Buffer.from(content) : content;\n        this._record.overwrite(p, c).subscribe();\n    }\n    beginUpdate(path) {\n        const entry = this.get(path);\n        if (!entry) {\n            throw new exception_1.FileDoesNotExistException(path);\n        }\n        return recorder_1.UpdateRecorderBase.createFromFileEntry(entry);\n    }\n    commitUpdate(record) {\n        if (record instanceof recorder_1.UpdateRecorderBase) {\n            const path = record.path;\n            const entry = this.get(path);\n            if (!entry) {\n                throw new exception_1.ContentHasMutatedException(path);\n            }\n            else {\n                const newContent = record.apply(entry.content);\n                if (!newContent.equals(entry.content)) {\n                    this.overwrite(path, newContent);\n                }\n            }\n        }\n        else {\n            throw new exception_1.InvalidUpdateRecordException();\n        }\n    }\n    // Structural methods.\n    create(path, content) {\n        const p = this._normalizePath(path);\n        if (this._recordSync.exists(p)) {\n            throw new exception_1.FileAlreadyExistException(p);\n        }\n        const c = typeof content == 'string' ? Buffer.from(content) : content;\n        this._record.create(p, c).subscribe();\n    }\n    delete(path) {\n        this._recordSync.delete(this._normalizePath(path));\n    }\n    rename(from, to) {\n        this._recordSync.rename(this._normalizePath(from), this._normalizePath(to));\n    }\n    apply(action, strategy) {\n        throw new exception_1.SchematicsException('Apply not implemented on host trees.');\n    }\n    *generateActions() {\n        for (const record of this._record.records()) {\n            switch (record.kind) {\n                case 'create':\n                    yield {\n                        id: this._id,\n                        parent: 0,\n                        kind: 'c',\n                        path: record.path,\n                        content: Buffer.from(record.content),\n                    };\n                    break;\n                case 'overwrite':\n                    yield {\n                        id: this._id,\n                        parent: 0,\n                        kind: 'o',\n                        path: record.path,\n                        content: Buffer.from(record.content),\n                    };\n                    break;\n                case 'rename':\n                    yield {\n                        id: this._id,\n                        parent: 0,\n                        kind: 'r',\n                        path: record.from,\n                        to: record.to,\n                    };\n                    break;\n                case 'delete':\n                    yield {\n                        id: this._id,\n                        parent: 0,\n                        kind: 'd',\n                        path: record.path,\n                    };\n                    break;\n            }\n        }\n    }\n    get actions() {\n        // Create a list of all records until we hit our original backend. This is to support branches\n        // that diverge from each others.\n        return Array.from(this.generateActions());\n    }\n}\nexports.HostTree = HostTree;\nclass HostCreateTree extends HostTree {\n    constructor(host) {\n        super();\n        const tempHost = new HostTree(host);\n        tempHost.visit((path) => {\n            const content = tempHost.read(path);\n            if (content) {\n                this.create(path, content);\n            }\n        });\n    }\n}\nexports.HostCreateTree = HostCreateTree;\nclass FilterHostTree extends HostTree {\n    constructor(tree, filter = () => true) {\n        const newBackend = new core_1.virtualFs.SimpleMemoryHost();\n        // cast to allow access\n        const originalBackend = tree._backend;\n        const recurse = (base) => {\n            return originalBackend.list(base).pipe((0, operators_1.mergeMap)((x) => x), (0, operators_1.map)((path) => (0, core_1.join)(base, path)), (0, operators_1.concatMap)((path) => {\n                let isDirectory = false;\n                originalBackend.isDirectory(path).subscribe((val) => (isDirectory = val));\n                if (isDirectory) {\n                    return recurse(path);\n                }\n                let isFile = false;\n                originalBackend.isFile(path).subscribe((val) => (isFile = val));\n                if (!isFile || !filter(path)) {\n                    return rxjs_1.EMPTY;\n                }\n                let content = null;\n                originalBackend.read(path).subscribe((val) => (content = val));\n                if (!content) {\n                    return rxjs_1.EMPTY;\n                }\n                return newBackend.write(path, content);\n            }));\n        };\n        recurse((0, core_1.normalize)('/')).subscribe();\n        super(newBackend);\n        for (const action of tree.actions) {\n            if (!filter(action.path)) {\n                continue;\n            }\n            switch (action.kind) {\n                case 'c':\n                    this.create(action.path, action.content);\n                    break;\n                case 'd':\n                    this.delete(action.path);\n                    break;\n                case 'o':\n                    this.overwrite(action.path, action.content);\n                    break;\n                case 'r':\n                    this.rename(action.path, action.to);\n                    break;\n            }\n        }\n    }\n}\nexports.FilterHostTree = FilterHostTree;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}