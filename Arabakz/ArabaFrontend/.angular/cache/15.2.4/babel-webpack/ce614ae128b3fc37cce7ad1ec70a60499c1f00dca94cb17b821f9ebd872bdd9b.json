{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    it\n  } = cxt;\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n  const schemaRef = useKeyword(gen, keyword, macroSchema);\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);\n  const valid = gen.name(\"valid\");\n  cxt.subschema({\n    schema: macroSchema,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n    topSchemaRef: schemaRef,\n    compositeRule: true\n  }, valid);\n  cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n  var _a;\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    $data,\n    it\n  } = cxt;\n  checkAsyncKeyword(it, def);\n  const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n  const validateRef = useKeyword(gen, keyword, validate);\n  const valid = gen.let(\"valid\");\n  cxt.block$data(valid, validateKeyword);\n  cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n  function validateKeyword() {\n    if (def.errors === false) {\n      assignValid();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => cxt.error());\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => addErrs(cxt, ruleErrs));\n    }\n  }\n  function validateAsync() {\n    const ruleErrs = gen.let(\"ruleErrs\", null);\n    gen.try(() => assignValid((0, codegen_1._)`await `), e => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));\n    return ruleErrs;\n  }\n  function validateSync() {\n    const validateErrs = (0, codegen_1._)`${validateRef}.errors`;\n    gen.assign(validateErrs, null);\n    assignValid(codegen_1.nil);\n    return validateErrs;\n  }\n  function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {\n    const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n    const passSchema = !(\"compile\" in def && !$data || def.schema === false);\n    gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n  }\n  function reportErrs(errors) {\n    var _a;\n    gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n  }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n  const {\n    gen\n  } = cxt;\n  gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {\n    gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);\n    (0, errors_1.extendErrors)(cxt);\n  }, () => cxt.error());\n}\nfunction checkAsyncKeyword({\n  schemaEnv\n}, def) {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`);\n  return gen.scopeValue(\"keyword\", typeof result == \"function\" ? {\n    ref: result\n  } : {\n    ref: result,\n    code: (0, codegen_1.stringify)(result)\n  });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n  // TODO add tests\n  return !schemaType.length || schemaType.some(st => st === \"array\" ? Array.isArray(schema) : st === \"object\" ? schema && typeof schema == \"object\" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == \"undefined\");\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({\n  schema,\n  opts,\n  self,\n  errSchemaPath\n}, def, keyword) {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\");\n  }\n  const deps = def.dependencies;\n  if (deps === null || deps === void 0 ? void 0 : deps.some(kwd => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n  }\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword]);\n    if (!valid) {\n      const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` + self.errorsText(def.validateSchema.errors);\n      if (opts.validateSchema === \"log\") self.logger.error(msg);else throw new Error(msg);\n    }\n  }\n}\nexports.validateKeywordUsage = validateKeywordUsage;","map":{"version":3,"names":["Object","defineProperty","exports","value","validateKeywordUsage","validSchemaType","funcKeywordCode","macroKeywordCode","codegen_1","require","names_1","code_1","errors_1","cxt","def","gen","keyword","schema","parentSchema","it","macroSchema","macro","call","self","schemaRef","useKeyword","opts","validateSchema","valid","name","subschema","schemaPath","nil","errSchemaPath","topSchemaRef","compositeRule","pass","error","_a","$data","checkAsyncKeyword","validate","compile","validateRef","let","block$data","validateKeyword","ok","errors","assignValid","modifying","modifyData","reportErrs","ruleErrs","async","validateAsync","validateSync","addErrs","try","_","e","assign","if","ValidationError","throw","validateErrs","_await","passCxt","passContext","default","this","passSchema","callValidateCode","not","data","parentData","parentDataProperty","errs","vErrors","extendErrors","schemaEnv","$async","Error","result","undefined","scopeValue","ref","code","stringify","schemaType","allowUndefined","length","some","st","Array","isArray","includes","deps","dependencies","kwd","prototype","hasOwnProperty","join","msg","errorsText","logger"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/ajv/dist/compile/validate/keyword.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}