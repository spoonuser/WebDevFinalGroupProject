{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UpdateBuffer2 = exports.UpdateBuffer = exports.UpdateBufferBase = exports.Chunk = exports.ContentCannotBeRemovedException = exports.IndexOutOfBoundException = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst magic_string_1 = __importDefault(require(\"magic-string\"));\nconst environment_options_1 = require(\"./environment-options\");\nconst linked_list_1 = require(\"./linked-list\");\nclass IndexOutOfBoundException extends core_1.BaseException {\n  constructor(index, min, max = Infinity) {\n    super(`Index ${index} outside of range [${min}, ${max}].`);\n  }\n}\nexports.IndexOutOfBoundException = IndexOutOfBoundException;\n/** @deprecated Since v13.0 */\nclass ContentCannotBeRemovedException extends core_1.BaseException {\n  constructor() {\n    super(`User tried to remove content that was marked essential.`);\n  }\n}\nexports.ContentCannotBeRemovedException = ContentCannotBeRemovedException;\n/**\n * A Chunk description, including left/right content that has been inserted.\n * If _left/_right is null, this means that content was deleted. If the _content is null,\n * it means the content itself was deleted.\n *\n * @see UpdateBuffer\n * @deprecated Since v13.0\n */\nclass Chunk {\n  constructor(start, end, originalContent) {\n    this.start = start;\n    this.end = end;\n    this.originalContent = originalContent;\n    this._left = Buffer.alloc(0);\n    this._right = Buffer.alloc(0);\n    this._assertLeft = false;\n    this._assertRight = false;\n    this.next = null;\n    this._content = originalContent.slice(start, end);\n  }\n  get length() {\n    return (this._left ? this._left.length : 0) + (this._content ? this._content.length : 0) + (this._right ? this._right.length : 0);\n  }\n  toString(encoding = 'utf-8') {\n    return (this._left ? this._left.toString(encoding) : '') + (this._content ? this._content.toString(encoding) : '') + (this._right ? this._right.toString(encoding) : '');\n  }\n  slice(start) {\n    if (start < this.start || start > this.end) {\n      throw new IndexOutOfBoundException(start, this.start, this.end);\n    }\n    // Update _content to the new indices.\n    const newChunk = new Chunk(start, this.end, this.originalContent);\n    // If this chunk has _content, reslice the original _content. We move the _right so we are not\n    // losing any data here. If this chunk has been deleted, the next chunk should also be deleted.\n    if (this._content) {\n      this._content = this.originalContent.slice(this.start, start);\n    } else {\n      newChunk._content = this._content;\n      if (this._right === null) {\n        newChunk._left = null;\n      }\n    }\n    this.end = start;\n    // Move _right to the new chunk.\n    newChunk._right = this._right;\n    this._right = this._right && Buffer.alloc(0);\n    // Update essentials.\n    if (this._assertRight) {\n      newChunk._assertRight = true;\n      this._assertRight = false;\n    }\n    // Update the linked list.\n    newChunk.next = this.next;\n    this.next = newChunk;\n    return newChunk;\n  }\n  append(buffer, essential) {\n    if (!this._right) {\n      if (essential) {\n        throw new ContentCannotBeRemovedException();\n      }\n      return;\n    }\n    const outro = this._right;\n    this._right = Buffer.alloc(outro.length + buffer.length);\n    outro.copy(this._right, 0);\n    buffer.copy(this._right, outro.length);\n    if (essential) {\n      this._assertRight = true;\n    }\n  }\n  prepend(buffer, essential) {\n    if (!this._left) {\n      if (essential) {\n        throw new ContentCannotBeRemovedException();\n      }\n      return;\n    }\n    const intro = this._left;\n    this._left = Buffer.alloc(intro.length + buffer.length);\n    intro.copy(this._left, 0);\n    buffer.copy(this._left, intro.length);\n    if (essential) {\n      this._assertLeft = true;\n    }\n  }\n  assert(left, _content, right) {\n    if (left && this._assertLeft) {\n      throw new ContentCannotBeRemovedException();\n    }\n    if (right && this._assertRight) {\n      throw new ContentCannotBeRemovedException();\n    }\n  }\n  remove(left, content, right) {\n    if (left) {\n      if (this._assertLeft) {\n        throw new ContentCannotBeRemovedException();\n      }\n      this._left = null;\n    }\n    if (content) {\n      this._content = null;\n    }\n    if (right) {\n      if (this._assertRight) {\n        throw new ContentCannotBeRemovedException();\n      }\n      this._right = null;\n    }\n  }\n  copy(target, start) {\n    if (this._left) {\n      this._left.copy(target, start);\n      start += this._left.length;\n    }\n    if (this._content) {\n      this._content.copy(target, start);\n      start += this._content.length;\n    }\n    if (this._right) {\n      this._right.copy(target, start);\n      start += this._right.length;\n    }\n    return start;\n  }\n}\nexports.Chunk = Chunk;\n/**\n * Base class for an update buffer implementation that allows buffers to be inserted to the _right\n * or _left, or deleted, while keeping indices to the original buffer.\n */\nclass UpdateBufferBase {\n  constructor(_originalContent) {\n    this._originalContent = _originalContent;\n  }\n  /**\n   * Creates an UpdateBufferBase instance. Depending on the NG_UPDATE_BUFFER_V2\n   * environment variable, will either create an UpdateBuffer or an UpdateBuffer2\n   * instance.\n   *\n   * See: https://github.com/angular/angular-cli/issues/21110\n   *\n   * @param originalContent The original content of the update buffer instance.\n   * @returns An UpdateBufferBase instance.\n   */\n  static create(originalContent) {\n    return environment_options_1.updateBufferV2Enabled ? new UpdateBuffer2(originalContent) : new UpdateBuffer(originalContent);\n  }\n}\nexports.UpdateBufferBase = UpdateBufferBase;\n/**\n * An utility class that allows buffers to be inserted to the _right or _left, or deleted, while\n * keeping indices to the original buffer.\n *\n * The constructor takes an original buffer, and keeps it into a linked list of chunks, smaller\n * buffers that keep track of _content inserted to the _right or _left of it.\n *\n * Since the Node Buffer structure is non-destructive when slicing, we try to use slicing to create\n * new chunks, and always keep chunks pointing to the original content.\n *\n * @deprecated Since v13.0\n */\nclass UpdateBuffer extends UpdateBufferBase {\n  constructor(originalContent) {\n    super(originalContent);\n    this._linkedList = new linked_list_1.LinkedList(new Chunk(0, originalContent.length, originalContent));\n  }\n  _assertIndex(index) {\n    if (index < 0 || index > this._originalContent.length) {\n      throw new IndexOutOfBoundException(index, 0, this._originalContent.length);\n    }\n  }\n  _slice(start) {\n    let index;\n    if (start >= this._originalContent.length) {\n      index = start;\n    } else if (start < 0) {\n      index = this._originalContent.length + start;\n    } else {\n      index = this._getTextPosition(start);\n    }\n    this._assertIndex(index);\n    // Find the chunk by going through the list.\n    const h = this._linkedList.find(chunk => index <= chunk.end);\n    if (!h) {\n      throw Error('Chunk cannot be found.');\n    }\n    if (index == h.end && h.next !== null) {\n      return [h, h.next];\n    }\n    return [h, h.slice(index)];\n  }\n  /**\n   * Gets the position in the content based on the position in the string.\n   * Some characters might be wider than one byte, thus we have to determine the position using\n   * string functions.\n   */\n  _getTextPosition(index) {\n    return Buffer.from(this._originalContent.toString().substring(0, index)).length;\n  }\n  get length() {\n    return this._linkedList.reduce((acc, chunk) => acc + chunk.length, 0);\n  }\n  get original() {\n    return this._originalContent;\n  }\n  toString(encoding = 'utf-8') {\n    return this._linkedList.reduce((acc, chunk) => acc + chunk.toString(encoding), '');\n  }\n  generate() {\n    const result = Buffer.allocUnsafe(this.length);\n    let i = 0;\n    this._linkedList.forEach(chunk => {\n      chunk.copy(result, i);\n      i += chunk.length;\n    });\n    return result;\n  }\n  insertLeft(index, content, assert = false) {\n    this._slice(index)[0].append(content, assert);\n  }\n  insertRight(index, content, assert = false) {\n    this._slice(index)[1].prepend(content, assert);\n  }\n  remove(index, length) {\n    if (length === 0) {\n      return;\n    }\n    const end = index + length;\n    const first = this._slice(index)[1];\n    const last = this._slice(end)[1];\n    let curr;\n    for (curr = first; curr && curr !== last; curr = curr.next) {\n      curr.assert(curr !== first, curr !== last, curr === first);\n    }\n    for (curr = first; curr && curr !== last; curr = curr.next) {\n      curr.remove(curr !== first, curr !== last, curr === first);\n    }\n    if (curr) {\n      curr.remove(true, false, false);\n    }\n  }\n}\nexports.UpdateBuffer = UpdateBuffer;\n/**\n * An utility class that allows buffers to be inserted to the _right or _left, or deleted, while\n * keeping indices to the original buffer.\n */\nclass UpdateBuffer2 extends UpdateBufferBase {\n  constructor() {\n    super(...arguments);\n    this._mutatableContent = new magic_string_1.default(this._originalContent.toString());\n  }\n  _assertIndex(index) {\n    if (index < 0 || index > this._originalContent.length) {\n      throw new IndexOutOfBoundException(index, 0, this._originalContent.length);\n    }\n  }\n  get length() {\n    return this._mutatableContent.length();\n  }\n  get original() {\n    return this._originalContent;\n  }\n  toString() {\n    return this._mutatableContent.toString();\n  }\n  generate() {\n    return Buffer.from(this.toString());\n  }\n  insertLeft(index, content) {\n    this._assertIndex(index);\n    this._mutatableContent.appendLeft(index, content.toString());\n  }\n  insertRight(index, content) {\n    this._assertIndex(index);\n    this._mutatableContent.appendRight(index, content.toString());\n  }\n  remove(index, length) {\n    this._assertIndex(index);\n    this._mutatableContent.remove(index, index + length);\n  }\n}\nexports.UpdateBuffer2 = UpdateBuffer2;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","UpdateBuffer2","UpdateBuffer","UpdateBufferBase","Chunk","ContentCannotBeRemovedException","IndexOutOfBoundException","core_1","require","magic_string_1","environment_options_1","linked_list_1","BaseException","constructor","index","min","max","Infinity","start","end","originalContent","_left","Buffer","alloc","_right","_assertLeft","_assertRight","next","_content","slice","length","toString","encoding","newChunk","append","buffer","essential","outro","copy","prepend","intro","assert","left","right","remove","content","target","_originalContent","create","updateBufferV2Enabled","_linkedList","LinkedList","_assertIndex","_slice","_getTextPosition","h","find","chunk","Error","from","substring","reduce","acc","original","generate","result","allocUnsafe","i","forEach","insertLeft","insertRight","first","last","curr","arguments","_mutatableContent","default","appendLeft","appendRight"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular-devkit/schematics/src/utility/update-buffer.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UpdateBuffer2 = exports.UpdateBuffer = exports.UpdateBufferBase = exports.Chunk = exports.ContentCannotBeRemovedException = exports.IndexOutOfBoundException = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst magic_string_1 = __importDefault(require(\"magic-string\"));\nconst environment_options_1 = require(\"./environment-options\");\nconst linked_list_1 = require(\"./linked-list\");\nclass IndexOutOfBoundException extends core_1.BaseException {\n    constructor(index, min, max = Infinity) {\n        super(`Index ${index} outside of range [${min}, ${max}].`);\n    }\n}\nexports.IndexOutOfBoundException = IndexOutOfBoundException;\n/** @deprecated Since v13.0 */\nclass ContentCannotBeRemovedException extends core_1.BaseException {\n    constructor() {\n        super(`User tried to remove content that was marked essential.`);\n    }\n}\nexports.ContentCannotBeRemovedException = ContentCannotBeRemovedException;\n/**\n * A Chunk description, including left/right content that has been inserted.\n * If _left/_right is null, this means that content was deleted. If the _content is null,\n * it means the content itself was deleted.\n *\n * @see UpdateBuffer\n * @deprecated Since v13.0\n */\nclass Chunk {\n    constructor(start, end, originalContent) {\n        this.start = start;\n        this.end = end;\n        this.originalContent = originalContent;\n        this._left = Buffer.alloc(0);\n        this._right = Buffer.alloc(0);\n        this._assertLeft = false;\n        this._assertRight = false;\n        this.next = null;\n        this._content = originalContent.slice(start, end);\n    }\n    get length() {\n        return ((this._left ? this._left.length : 0) +\n            (this._content ? this._content.length : 0) +\n            (this._right ? this._right.length : 0));\n    }\n    toString(encoding = 'utf-8') {\n        return ((this._left ? this._left.toString(encoding) : '') +\n            (this._content ? this._content.toString(encoding) : '') +\n            (this._right ? this._right.toString(encoding) : ''));\n    }\n    slice(start) {\n        if (start < this.start || start > this.end) {\n            throw new IndexOutOfBoundException(start, this.start, this.end);\n        }\n        // Update _content to the new indices.\n        const newChunk = new Chunk(start, this.end, this.originalContent);\n        // If this chunk has _content, reslice the original _content. We move the _right so we are not\n        // losing any data here. If this chunk has been deleted, the next chunk should also be deleted.\n        if (this._content) {\n            this._content = this.originalContent.slice(this.start, start);\n        }\n        else {\n            newChunk._content = this._content;\n            if (this._right === null) {\n                newChunk._left = null;\n            }\n        }\n        this.end = start;\n        // Move _right to the new chunk.\n        newChunk._right = this._right;\n        this._right = this._right && Buffer.alloc(0);\n        // Update essentials.\n        if (this._assertRight) {\n            newChunk._assertRight = true;\n            this._assertRight = false;\n        }\n        // Update the linked list.\n        newChunk.next = this.next;\n        this.next = newChunk;\n        return newChunk;\n    }\n    append(buffer, essential) {\n        if (!this._right) {\n            if (essential) {\n                throw new ContentCannotBeRemovedException();\n            }\n            return;\n        }\n        const outro = this._right;\n        this._right = Buffer.alloc(outro.length + buffer.length);\n        outro.copy(this._right, 0);\n        buffer.copy(this._right, outro.length);\n        if (essential) {\n            this._assertRight = true;\n        }\n    }\n    prepend(buffer, essential) {\n        if (!this._left) {\n            if (essential) {\n                throw new ContentCannotBeRemovedException();\n            }\n            return;\n        }\n        const intro = this._left;\n        this._left = Buffer.alloc(intro.length + buffer.length);\n        intro.copy(this._left, 0);\n        buffer.copy(this._left, intro.length);\n        if (essential) {\n            this._assertLeft = true;\n        }\n    }\n    assert(left, _content, right) {\n        if (left && this._assertLeft) {\n            throw new ContentCannotBeRemovedException();\n        }\n        if (right && this._assertRight) {\n            throw new ContentCannotBeRemovedException();\n        }\n    }\n    remove(left, content, right) {\n        if (left) {\n            if (this._assertLeft) {\n                throw new ContentCannotBeRemovedException();\n            }\n            this._left = null;\n        }\n        if (content) {\n            this._content = null;\n        }\n        if (right) {\n            if (this._assertRight) {\n                throw new ContentCannotBeRemovedException();\n            }\n            this._right = null;\n        }\n    }\n    copy(target, start) {\n        if (this._left) {\n            this._left.copy(target, start);\n            start += this._left.length;\n        }\n        if (this._content) {\n            this._content.copy(target, start);\n            start += this._content.length;\n        }\n        if (this._right) {\n            this._right.copy(target, start);\n            start += this._right.length;\n        }\n        return start;\n    }\n}\nexports.Chunk = Chunk;\n/**\n * Base class for an update buffer implementation that allows buffers to be inserted to the _right\n * or _left, or deleted, while keeping indices to the original buffer.\n */\nclass UpdateBufferBase {\n    constructor(_originalContent) {\n        this._originalContent = _originalContent;\n    }\n    /**\n     * Creates an UpdateBufferBase instance. Depending on the NG_UPDATE_BUFFER_V2\n     * environment variable, will either create an UpdateBuffer or an UpdateBuffer2\n     * instance.\n     *\n     * See: https://github.com/angular/angular-cli/issues/21110\n     *\n     * @param originalContent The original content of the update buffer instance.\n     * @returns An UpdateBufferBase instance.\n     */\n    static create(originalContent) {\n        return environment_options_1.updateBufferV2Enabled\n            ? new UpdateBuffer2(originalContent)\n            : new UpdateBuffer(originalContent);\n    }\n}\nexports.UpdateBufferBase = UpdateBufferBase;\n/**\n * An utility class that allows buffers to be inserted to the _right or _left, or deleted, while\n * keeping indices to the original buffer.\n *\n * The constructor takes an original buffer, and keeps it into a linked list of chunks, smaller\n * buffers that keep track of _content inserted to the _right or _left of it.\n *\n * Since the Node Buffer structure is non-destructive when slicing, we try to use slicing to create\n * new chunks, and always keep chunks pointing to the original content.\n *\n * @deprecated Since v13.0\n */\nclass UpdateBuffer extends UpdateBufferBase {\n    constructor(originalContent) {\n        super(originalContent);\n        this._linkedList = new linked_list_1.LinkedList(new Chunk(0, originalContent.length, originalContent));\n    }\n    _assertIndex(index) {\n        if (index < 0 || index > this._originalContent.length) {\n            throw new IndexOutOfBoundException(index, 0, this._originalContent.length);\n        }\n    }\n    _slice(start) {\n        let index;\n        if (start >= this._originalContent.length) {\n            index = start;\n        }\n        else if (start < 0) {\n            index = this._originalContent.length + start;\n        }\n        else {\n            index = this._getTextPosition(start);\n        }\n        this._assertIndex(index);\n        // Find the chunk by going through the list.\n        const h = this._linkedList.find((chunk) => index <= chunk.end);\n        if (!h) {\n            throw Error('Chunk cannot be found.');\n        }\n        if (index == h.end && h.next !== null) {\n            return [h, h.next];\n        }\n        return [h, h.slice(index)];\n    }\n    /**\n     * Gets the position in the content based on the position in the string.\n     * Some characters might be wider than one byte, thus we have to determine the position using\n     * string functions.\n     */\n    _getTextPosition(index) {\n        return Buffer.from(this._originalContent.toString().substring(0, index)).length;\n    }\n    get length() {\n        return this._linkedList.reduce((acc, chunk) => acc + chunk.length, 0);\n    }\n    get original() {\n        return this._originalContent;\n    }\n    toString(encoding = 'utf-8') {\n        return this._linkedList.reduce((acc, chunk) => acc + chunk.toString(encoding), '');\n    }\n    generate() {\n        const result = Buffer.allocUnsafe(this.length);\n        let i = 0;\n        this._linkedList.forEach((chunk) => {\n            chunk.copy(result, i);\n            i += chunk.length;\n        });\n        return result;\n    }\n    insertLeft(index, content, assert = false) {\n        this._slice(index)[0].append(content, assert);\n    }\n    insertRight(index, content, assert = false) {\n        this._slice(index)[1].prepend(content, assert);\n    }\n    remove(index, length) {\n        if (length === 0) {\n            return;\n        }\n        const end = index + length;\n        const first = this._slice(index)[1];\n        const last = this._slice(end)[1];\n        let curr;\n        for (curr = first; curr && curr !== last; curr = curr.next) {\n            curr.assert(curr !== first, curr !== last, curr === first);\n        }\n        for (curr = first; curr && curr !== last; curr = curr.next) {\n            curr.remove(curr !== first, curr !== last, curr === first);\n        }\n        if (curr) {\n            curr.remove(true, false, false);\n        }\n    }\n}\nexports.UpdateBuffer = UpdateBuffer;\n/**\n * An utility class that allows buffers to be inserted to the _right or _left, or deleted, while\n * keeping indices to the original buffer.\n */\nclass UpdateBuffer2 extends UpdateBufferBase {\n    constructor() {\n        super(...arguments);\n        this._mutatableContent = new magic_string_1.default(this._originalContent.toString());\n    }\n    _assertIndex(index) {\n        if (index < 0 || index > this._originalContent.length) {\n            throw new IndexOutOfBoundException(index, 0, this._originalContent.length);\n        }\n    }\n    get length() {\n        return this._mutatableContent.length();\n    }\n    get original() {\n        return this._originalContent;\n    }\n    toString() {\n        return this._mutatableContent.toString();\n    }\n    generate() {\n        return Buffer.from(this.toString());\n    }\n    insertLeft(index, content) {\n        this._assertIndex(index);\n        this._mutatableContent.appendLeft(index, content.toString());\n    }\n    insertRight(index, content) {\n        this._assertIndex(index);\n        this._mutatableContent.appendRight(index, content.toString());\n    }\n    remove(index, length) {\n        this._assertIndex(index);\n        this._mutatableContent.remove(index, index + length);\n    }\n}\nexports.UpdateBuffer2 = UpdateBuffer2;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}