{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst code_1 = require(\"./codegen/code\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n  const hash = {};\n  for (const item of arr) hash[item] = true;\n  return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n  if (typeof schema == \"boolean\") return schema;\n  if (Object.keys(schema).length === 0) return true;\n  checkUnknownRules(it, schema);\n  return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it, schema = it.schema) {\n  const {\n    opts,\n    self\n  } = it;\n  if (!opts.strictSchema) return;\n  if (typeof schema === \"boolean\") return;\n  const rules = self.RULES.keywords;\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`);\n  }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n  if (typeof schema == \"boolean\") return !schema;\n  for (const key in schema) if (rules[key]) return true;\n  return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n  if (typeof schema == \"boolean\") return !schema;\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true;\n  return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal({\n  topSchemaRef,\n  schemaPath\n}, schema, keyword, $data) {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema;\n    if (typeof schema == \"string\") return (0, codegen_1._)`${schema}`;\n  }\n  return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n  return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n  return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n  if (typeof str == \"number\") return `${str}`;\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x);\n  } else {\n    f(xs);\n  }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName\n}) {\n  return (gen, from, to, toName) => {\n    const res = to === undefined ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);\n    return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n  };\n}\nexports.mergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {\n      gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));\n    }),\n    mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {\n      if (from === true) {\n        gen.assign(to, true);\n      } else {\n        gen.assign(to, (0, codegen_1._)`${to} || {}`);\n        setEvaluated(gen, to, from);\n      }\n    }),\n    mergeValues: (from, to) => from === true ? true : {\n      ...from,\n      ...to\n    },\n    resultToName: evaluatedPropsToName\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n    mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),\n    mergeValues: (from, to) => from === true ? true : Math.max(from, to),\n    resultToName: (gen, items) => gen.var(\"items\", items)\n  })\n};\nfunction evaluatedPropsToName(gen, ps) {\n  if (ps === true) return gen.var(\"props\", true);\n  const props = gen.var(\"props\", (0, codegen_1._)`{}`);\n  if (ps !== undefined) setEvaluated(gen, props, ps);\n  return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n  Object.keys(ps).forEach(p => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))\n  });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n  Type[Type[\"Num\"] = 0] = \"Num\";\n  Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type = exports.Type || (exports.Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n  // let path\n  if (dataProp instanceof codegen_1.Name) {\n    const isNumber = dataPropType === Type.Num;\n    return jsPropertySyntax ? isNumber ? (0, codegen_1._)`\"[\" + ${dataProp} + \"]\"` : (0, codegen_1._)`\"['\" + ${dataProp} + \"']\"` : isNumber ? (0, codegen_1._)`\"/\" + ${dataProp}` : (0, codegen_1._)`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n  }\n\n  return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n  if (!mode) return;\n  msg = `strict mode: ${msg}`;\n  if (mode === true) throw new Error(msg);\n  it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;","map":{"version":3,"names":["Object","defineProperty","exports","value","checkStrictMode","getErrorPath","Type","useFunc","setEvaluated","evaluatedPropsToName","mergeEvaluated","eachItem","unescapeJsonPointer","escapeJsonPointer","escapeFragment","unescapeFragment","schemaRefOrVal","schemaHasRulesButRef","schemaHasRules","checkUnknownRules","alwaysValidSchema","toHash","codegen_1","require","code_1","arr","hash","item","it","schema","keys","length","self","RULES","all","opts","strictSchema","rules","keywords","key","topSchemaRef","schemaPath","keyword","$data","_","getProperty","str","decodeURIComponent","encodeURIComponent","replace","xs","f","Array","isArray","x","makeMergeEvaluated","mergeNames","mergeToName","mergeValues","resultToName","gen","from","to","toName","res","undefined","Name","props","if","assign","code","items","Math","max","var","ps","forEach","p","snippets","scopeValue","ref","_Code","dataProp","dataPropType","jsPropertySyntax","isNumber","Num","toString","msg","mode","Error","logger","warn"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/ajv/dist/compile/util.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst code_1 = require(\"./codegen/code\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n    const hash = {};\n    for (const item of arr)\n        hash[item] = true;\n    return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n    if (typeof schema == \"boolean\")\n        return schema;\n    if (Object.keys(schema).length === 0)\n        return true;\n    checkUnknownRules(it, schema);\n    return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it, schema = it.schema) {\n    const { opts, self } = it;\n    if (!opts.strictSchema)\n        return;\n    if (typeof schema === \"boolean\")\n        return;\n    const rules = self.RULES.keywords;\n    for (const key in schema) {\n        if (!rules[key])\n            checkStrictMode(it, `unknown keyword: \"${key}\"`);\n    }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (rules[key])\n            return true;\n    return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (key !== \"$ref\" && RULES.all[key])\n            return true;\n    return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n    if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\")\n            return schema;\n        if (typeof schema == \"string\")\n            return (0, codegen_1._) `${schema}`;\n    }\n    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n    return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n    return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n    if (typeof str == \"number\")\n        return `${str}`;\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n    if (Array.isArray(xs)) {\n        for (const x of xs)\n            f(x);\n    }\n    else {\n        f(xs);\n    }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {\n    return (gen, from, to, toName) => {\n        const res = to === undefined\n            ? from\n            : to instanceof codegen_1.Name\n                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n                : from instanceof codegen_1.Name\n                    ? (mergeToName(gen, to, from), from)\n                    : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n    };\n}\nexports.mergeEvaluated = {\n    props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {\n            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {\n            if (from === true) {\n                gen.assign(to, true);\n            }\n            else {\n                gen.assign(to, (0, codegen_1._) `${to} || {}`);\n                setEvaluated(gen, to, from);\n            }\n        }),\n        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),\n        resultToName: evaluatedPropsToName,\n    }),\n    items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n        resultToName: (gen, items) => gen.var(\"items\", items),\n    }),\n};\nfunction evaluatedPropsToName(gen, ps) {\n    if (ps === true)\n        return gen.var(\"props\", true);\n    const props = gen.var(\"props\", (0, codegen_1._) `{}`);\n    if (ps !== undefined)\n        setEvaluated(gen, props, ps);\n    return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n    return gen.scopeValue(\"func\", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),\n    });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n    Type[Type[\"Num\"] = 0] = \"Num\";\n    Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type = exports.Type || (exports.Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n    // let path\n    if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax\n            ? isNumber\n                ? (0, codegen_1._) `\"[\" + ${dataProp} + \"]\"`\n                : (0, codegen_1._) `\"['\" + ${dataProp} + \"']\"`\n            : isNumber\n                ? (0, codegen_1._) `\"/\" + ${dataProp}`\n                : (0, codegen_1._) `\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n    }\n    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n    if (!mode)\n        return;\n    msg = `strict mode: ${msg}`;\n    if (mode === true)\n        throw new Error(msg);\n    it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}