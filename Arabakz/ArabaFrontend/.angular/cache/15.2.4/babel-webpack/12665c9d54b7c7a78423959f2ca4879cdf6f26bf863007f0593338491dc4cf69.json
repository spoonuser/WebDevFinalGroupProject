{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _asyncIterator = require(\"/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyToSubtree = exports.composeFileOperators = exports.forEach = exports.partitionApplyMerge = exports.when = exports.branchAndMerge = exports.asSource = exports.filter = exports.noop = exports.mergeWith = exports.apply = exports.chain = exports.empty = exports.source = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst exception_1 = require(\"../exception/exception\");\nconst host_tree_1 = require(\"../tree/host-tree\");\nconst interface_1 = require(\"../tree/interface\");\nconst scoped_1 = require(\"../tree/scoped\");\nconst static_1 = require(\"../tree/static\");\nconst call_1 = require(\"./call\");\n/**\n * A Source that returns an tree as its single value.\n */\nfunction source(tree) {\n  return () => tree;\n}\nexports.source = source;\n/**\n * A source that returns an empty tree.\n */\nfunction empty() {\n  return () => (0, static_1.empty)();\n}\nexports.empty = empty;\n/**\n * Chain multiple rules into a single rule.\n */\nfunction chain(rules) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (initialTree, context) {\n      let intermediateTree;\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n      var _iteratorError;\n      try {\n        for (var _iterator = _asyncIterator(rules), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const rule = _step.value;\n          {\n            intermediateTree = (0, call_1.callRule)(rule, intermediateTree !== null && intermediateTree !== void 0 ? intermediateTree : initialTree, context);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      return () => intermediateTree;\n    });\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\nexports.chain = chain;\n/**\n * Apply multiple rules to a source, and returns the source transformed.\n */\nfunction apply(source, rules) {\n  return context => (0, call_1.callRule)(chain(rules), (0, call_1.callSource)(source, context), context);\n}\nexports.apply = apply;\n/**\n * Merge an input tree with the source passed in.\n */\nfunction mergeWith(source, strategy = interface_1.MergeStrategy.Default) {\n  return (tree, context) => {\n    return (0, call_1.callSource)(source, context).pipe((0, operators_1.map)(sourceTree => tree.merge(sourceTree, strategy || context.strategy)), (0, operators_1.mapTo)(tree));\n  };\n}\nexports.mergeWith = mergeWith;\nfunction noop() {\n  return () => {};\n}\nexports.noop = noop;\nfunction filter(predicate) {\n  return tree => {\n    if (host_tree_1.HostTree.isHostTree(tree)) {\n      return new host_tree_1.FilterHostTree(tree, predicate);\n    } else {\n      throw new exception_1.SchematicsException('Tree type is not supported.');\n    }\n  };\n}\nexports.filter = filter;\nfunction asSource(rule) {\n  return context => (0, call_1.callRule)(rule, (0, static_1.empty)(), context);\n}\nexports.asSource = asSource;\nfunction branchAndMerge(rule, strategy = interface_1.MergeStrategy.Default) {\n  return (tree, context) => {\n    return (0, call_1.callRule)(rule, tree.branch(), context).pipe((0, operators_1.map)(branch => tree.merge(branch, strategy || context.strategy)), (0, operators_1.mapTo)(tree));\n  };\n}\nexports.branchAndMerge = branchAndMerge;\nfunction when(predicate, operator) {\n  return entry => {\n    if (predicate(entry.path, entry)) {\n      return operator(entry);\n    } else {\n      return entry;\n    }\n  };\n}\nexports.when = when;\nfunction partitionApplyMerge(predicate, ruleYes, ruleNo) {\n  return (tree, context) => {\n    const [yes, no] = (0, static_1.partition)(tree, predicate);\n    return (0, rxjs_1.concat)((0, call_1.callRule)(ruleYes, yes, context), (0, call_1.callRule)(ruleNo || noop(), no, context)).pipe((0, operators_1.toArray)(), (0, operators_1.map)(([yesTree, noTree]) => {\n      yesTree.merge(noTree, context.strategy);\n      return yesTree;\n    }));\n  };\n}\nexports.partitionApplyMerge = partitionApplyMerge;\nfunction forEach(operator) {\n  return tree => {\n    tree.visit((path, entry) => {\n      if (!entry) {\n        return;\n      }\n      const newEntry = operator(entry);\n      if (newEntry === entry) {\n        return;\n      }\n      if (newEntry === null) {\n        tree.delete(path);\n        return;\n      }\n      if (newEntry.path != path) {\n        tree.rename(path, newEntry.path);\n      }\n      if (!newEntry.content.equals(entry.content)) {\n        tree.overwrite(newEntry.path, newEntry.content);\n      }\n    });\n  };\n}\nexports.forEach = forEach;\nfunction composeFileOperators(operators) {\n  return entry => {\n    let current = entry;\n    for (const op of operators) {\n      current = op(current);\n      if (current === null) {\n        // Deleted, just return.\n        return null;\n      }\n    }\n    return current;\n  };\n}\nexports.composeFileOperators = composeFileOperators;\nfunction applyToSubtree(path, rules) {\n  return (tree, context) => {\n    const scoped = new scoped_1.ScopedTree(tree, path);\n    return (0, call_1.callRule)(chain(rules), scoped, context).pipe((0, operators_1.map)(result => {\n      if (result === scoped) {\n        return tree;\n      } else {\n        throw new exception_1.SchematicsException('Original tree must be returned from all rules when using \"applyToSubtree\".');\n      }\n    }));\n  };\n}\nexports.applyToSubtree = applyToSubtree;","map":{"version":3,"names":["Object","defineProperty","exports","value","applyToSubtree","composeFileOperators","forEach","partitionApplyMerge","when","branchAndMerge","asSource","filter","noop","mergeWith","apply","chain","empty","source","rxjs_1","require","operators_1","exception_1","host_tree_1","interface_1","scoped_1","static_1","call_1","tree","rules","initialTree","context","intermediateTree","rule","callRule","callSource","strategy","MergeStrategy","Default","pipe","map","sourceTree","merge","mapTo","predicate","HostTree","isHostTree","FilterHostTree","SchematicsException","branch","operator","entry","path","ruleYes","ruleNo","yes","no","partition","concat","toArray","yesTree","noTree","visit","newEntry","delete","rename","content","equals","overwrite","operators","current","op","scoped","ScopedTree","result"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular-devkit/schematics/src/rules/base.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyToSubtree = exports.composeFileOperators = exports.forEach = exports.partitionApplyMerge = exports.when = exports.branchAndMerge = exports.asSource = exports.filter = exports.noop = exports.mergeWith = exports.apply = exports.chain = exports.empty = exports.source = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst exception_1 = require(\"../exception/exception\");\nconst host_tree_1 = require(\"../tree/host-tree\");\nconst interface_1 = require(\"../tree/interface\");\nconst scoped_1 = require(\"../tree/scoped\");\nconst static_1 = require(\"../tree/static\");\nconst call_1 = require(\"./call\");\n/**\n * A Source that returns an tree as its single value.\n */\nfunction source(tree) {\n    return () => tree;\n}\nexports.source = source;\n/**\n * A source that returns an empty tree.\n */\nfunction empty() {\n    return () => (0, static_1.empty)();\n}\nexports.empty = empty;\n/**\n * Chain multiple rules into a single rule.\n */\nfunction chain(rules) {\n    return async (initialTree, context) => {\n        let intermediateTree;\n        for await (const rule of rules) {\n            intermediateTree = (0, call_1.callRule)(rule, intermediateTree !== null && intermediateTree !== void 0 ? intermediateTree : initialTree, context);\n        }\n        return () => intermediateTree;\n    };\n}\nexports.chain = chain;\n/**\n * Apply multiple rules to a source, and returns the source transformed.\n */\nfunction apply(source, rules) {\n    return (context) => (0, call_1.callRule)(chain(rules), (0, call_1.callSource)(source, context), context);\n}\nexports.apply = apply;\n/**\n * Merge an input tree with the source passed in.\n */\nfunction mergeWith(source, strategy = interface_1.MergeStrategy.Default) {\n    return (tree, context) => {\n        return (0, call_1.callSource)(source, context).pipe((0, operators_1.map)((sourceTree) => tree.merge(sourceTree, strategy || context.strategy)), (0, operators_1.mapTo)(tree));\n    };\n}\nexports.mergeWith = mergeWith;\nfunction noop() {\n    return () => { };\n}\nexports.noop = noop;\nfunction filter(predicate) {\n    return (tree) => {\n        if (host_tree_1.HostTree.isHostTree(tree)) {\n            return new host_tree_1.FilterHostTree(tree, predicate);\n        }\n        else {\n            throw new exception_1.SchematicsException('Tree type is not supported.');\n        }\n    };\n}\nexports.filter = filter;\nfunction asSource(rule) {\n    return (context) => (0, call_1.callRule)(rule, (0, static_1.empty)(), context);\n}\nexports.asSource = asSource;\nfunction branchAndMerge(rule, strategy = interface_1.MergeStrategy.Default) {\n    return (tree, context) => {\n        return (0, call_1.callRule)(rule, tree.branch(), context).pipe((0, operators_1.map)((branch) => tree.merge(branch, strategy || context.strategy)), (0, operators_1.mapTo)(tree));\n    };\n}\nexports.branchAndMerge = branchAndMerge;\nfunction when(predicate, operator) {\n    return (entry) => {\n        if (predicate(entry.path, entry)) {\n            return operator(entry);\n        }\n        else {\n            return entry;\n        }\n    };\n}\nexports.when = when;\nfunction partitionApplyMerge(predicate, ruleYes, ruleNo) {\n    return (tree, context) => {\n        const [yes, no] = (0, static_1.partition)(tree, predicate);\n        return (0, rxjs_1.concat)((0, call_1.callRule)(ruleYes, yes, context), (0, call_1.callRule)(ruleNo || noop(), no, context)).pipe((0, operators_1.toArray)(), (0, operators_1.map)(([yesTree, noTree]) => {\n            yesTree.merge(noTree, context.strategy);\n            return yesTree;\n        }));\n    };\n}\nexports.partitionApplyMerge = partitionApplyMerge;\nfunction forEach(operator) {\n    return (tree) => {\n        tree.visit((path, entry) => {\n            if (!entry) {\n                return;\n            }\n            const newEntry = operator(entry);\n            if (newEntry === entry) {\n                return;\n            }\n            if (newEntry === null) {\n                tree.delete(path);\n                return;\n            }\n            if (newEntry.path != path) {\n                tree.rename(path, newEntry.path);\n            }\n            if (!newEntry.content.equals(entry.content)) {\n                tree.overwrite(newEntry.path, newEntry.content);\n            }\n        });\n    };\n}\nexports.forEach = forEach;\nfunction composeFileOperators(operators) {\n    return (entry) => {\n        let current = entry;\n        for (const op of operators) {\n            current = op(current);\n            if (current === null) {\n                // Deleted, just return.\n                return null;\n            }\n        }\n        return current;\n    };\n}\nexports.composeFileOperators = composeFileOperators;\nfunction applyToSubtree(path, rules) {\n    return (tree, context) => {\n        const scoped = new scoped_1.ScopedTree(tree, path);\n        return (0, call_1.callRule)(chain(rules), scoped, context).pipe((0, operators_1.map)((result) => {\n            if (result === scoped) {\n                return tree;\n            }\n            else {\n                throw new exception_1.SchematicsException('Original tree must be returned from all rules when using \"applyToSubtree\".');\n            }\n        }));\n    };\n}\nexports.applyToSubtree = applyToSubtree;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAAA;AAOAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,cAAc,GAAGF,OAAO,CAACG,oBAAoB,GAAGH,OAAO,CAACI,OAAO,GAAGJ,OAAO,CAACK,mBAAmB,GAAGL,OAAO,CAACM,IAAI,GAAGN,OAAO,CAACO,cAAc,GAAGP,OAAO,CAACQ,QAAQ,GAAGR,OAAO,CAACS,MAAM,GAAGT,OAAO,CAACU,IAAI,GAAGV,OAAO,CAACW,SAAS,GAAGX,OAAO,CAACY,KAAK,GAAGZ,OAAO,CAACa,KAAK,GAAGb,OAAO,CAACc,KAAK,GAAGd,OAAO,CAACe,MAAM,GAAG,KAAK,CAAC;AAC9R,MAAMC,MAAM,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC9B,MAAMC,WAAW,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAC7C,MAAME,WAAW,GAAGF,OAAO,CAAC,wBAAwB,CAAC;AACrD,MAAMG,WAAW,GAAGH,OAAO,CAAC,mBAAmB,CAAC;AAChD,MAAMI,WAAW,GAAGJ,OAAO,CAAC,mBAAmB,CAAC;AAChD,MAAMK,QAAQ,GAAGL,OAAO,CAAC,gBAAgB,CAAC;AAC1C,MAAMM,QAAQ,GAAGN,OAAO,CAAC,gBAAgB,CAAC;AAC1C,MAAMO,MAAM,GAAGP,OAAO,CAAC,QAAQ,CAAC;AAChC;AACA;AACA;AACA,SAASF,MAAM,CAACU,IAAI,EAAE;EAClB,OAAO,MAAMA,IAAI;AACrB;AACAzB,OAAO,CAACe,MAAM,GAAGA,MAAM;AACvB;AACA;AACA;AACA,SAASD,KAAK,GAAG;EACb,OAAO,MAAM,CAAC,CAAC,EAAES,QAAQ,CAACT,KAAK,GAAG;AACtC;AACAd,OAAO,CAACc,KAAK,GAAGA,KAAK;AACrB;AACA;AACA;AACA,SAASD,KAAK,CAACa,KAAK,EAAE;EAClB;IAAA,6BAAO,WAAOC,WAAW,EAAEC,OAAO,EAAK;MACnC,IAAIC,gBAAgB;MAAC;MAAA;MAAA;MAAA;QACrB,oCAAyBH,KAAK,iHAAE;UAAA,MAAfI,IAAI;UAAA;YACjBD,gBAAgB,GAAG,CAAC,CAAC,EAAEL,MAAM,CAACO,QAAQ,EAAED,IAAI,EAAED,gBAAgB,KAAK,IAAI,IAAIA,gBAAgB,KAAK,KAAK,CAAC,GAAGA,gBAAgB,GAAGF,WAAW,EAAEC,OAAO,CAAC;UAAC;QACtJ;MAAC;QAAA;QAAA;MAAA;QAAA;UAAA;YAAA;UAAA;QAAA;UAAA;YAAA;UAAA;QAAA;MAAA;MACD,OAAO,MAAMC,gBAAgB;IACjC,CAAC;IAAA;MAAA;IAAA;EAAA;AACL;AACA7B,OAAO,CAACa,KAAK,GAAGA,KAAK;AACrB;AACA;AACA;AACA,SAASD,KAAK,CAACG,MAAM,EAAEW,KAAK,EAAE;EAC1B,OAAQE,OAAO,IAAK,CAAC,CAAC,EAAEJ,MAAM,CAACO,QAAQ,EAAElB,KAAK,CAACa,KAAK,CAAC,EAAE,CAAC,CAAC,EAAEF,MAAM,CAACQ,UAAU,EAAEjB,MAAM,EAAEa,OAAO,CAAC,EAAEA,OAAO,CAAC;AAC5G;AACA5B,OAAO,CAACY,KAAK,GAAGA,KAAK;AACrB;AACA;AACA;AACA,SAASD,SAAS,CAACI,MAAM,EAAEkB,QAAQ,GAAGZ,WAAW,CAACa,aAAa,CAACC,OAAO,EAAE;EACrE,OAAO,CAACV,IAAI,EAAEG,OAAO,KAAK;IACtB,OAAO,CAAC,CAAC,EAAEJ,MAAM,CAACQ,UAAU,EAAEjB,MAAM,EAAEa,OAAO,CAAC,CAACQ,IAAI,CAAC,CAAC,CAAC,EAAElB,WAAW,CAACmB,GAAG,EAAGC,UAAU,IAAKb,IAAI,CAACc,KAAK,CAACD,UAAU,EAAEL,QAAQ,IAAIL,OAAO,CAACK,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEf,WAAW,CAACsB,KAAK,EAAEf,IAAI,CAAC,CAAC;EACjL,CAAC;AACL;AACAzB,OAAO,CAACW,SAAS,GAAGA,SAAS;AAC7B,SAASD,IAAI,GAAG;EACZ,OAAO,MAAM,CAAE,CAAC;AACpB;AACAV,OAAO,CAACU,IAAI,GAAGA,IAAI;AACnB,SAASD,MAAM,CAACgC,SAAS,EAAE;EACvB,OAAQhB,IAAI,IAAK;IACb,IAAIL,WAAW,CAACsB,QAAQ,CAACC,UAAU,CAAClB,IAAI,CAAC,EAAE;MACvC,OAAO,IAAIL,WAAW,CAACwB,cAAc,CAACnB,IAAI,EAAEgB,SAAS,CAAC;IAC1D,CAAC,MACI;MACD,MAAM,IAAItB,WAAW,CAAC0B,mBAAmB,CAAC,6BAA6B,CAAC;IAC5E;EACJ,CAAC;AACL;AACA7C,OAAO,CAACS,MAAM,GAAGA,MAAM;AACvB,SAASD,QAAQ,CAACsB,IAAI,EAAE;EACpB,OAAQF,OAAO,IAAK,CAAC,CAAC,EAAEJ,MAAM,CAACO,QAAQ,EAAED,IAAI,EAAE,CAAC,CAAC,EAAEP,QAAQ,CAACT,KAAK,GAAG,EAAEc,OAAO,CAAC;AAClF;AACA5B,OAAO,CAACQ,QAAQ,GAAGA,QAAQ;AAC3B,SAASD,cAAc,CAACuB,IAAI,EAAEG,QAAQ,GAAGZ,WAAW,CAACa,aAAa,CAACC,OAAO,EAAE;EACxE,OAAO,CAACV,IAAI,EAAEG,OAAO,KAAK;IACtB,OAAO,CAAC,CAAC,EAAEJ,MAAM,CAACO,QAAQ,EAAED,IAAI,EAAEL,IAAI,CAACqB,MAAM,EAAE,EAAElB,OAAO,CAAC,CAACQ,IAAI,CAAC,CAAC,CAAC,EAAElB,WAAW,CAACmB,GAAG,EAAGS,MAAM,IAAKrB,IAAI,CAACc,KAAK,CAACO,MAAM,EAAEb,QAAQ,IAAIL,OAAO,CAACK,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,EAAEf,WAAW,CAACsB,KAAK,EAAEf,IAAI,CAAC,CAAC;EACpL,CAAC;AACL;AACAzB,OAAO,CAACO,cAAc,GAAGA,cAAc;AACvC,SAASD,IAAI,CAACmC,SAAS,EAAEM,QAAQ,EAAE;EAC/B,OAAQC,KAAK,IAAK;IACd,IAAIP,SAAS,CAACO,KAAK,CAACC,IAAI,EAAED,KAAK,CAAC,EAAE;MAC9B,OAAOD,QAAQ,CAACC,KAAK,CAAC;IAC1B,CAAC,MACI;MACD,OAAOA,KAAK;IAChB;EACJ,CAAC;AACL;AACAhD,OAAO,CAACM,IAAI,GAAGA,IAAI;AACnB,SAASD,mBAAmB,CAACoC,SAAS,EAAES,OAAO,EAAEC,MAAM,EAAE;EACrD,OAAO,CAAC1B,IAAI,EAAEG,OAAO,KAAK;IACtB,MAAM,CAACwB,GAAG,EAAEC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE9B,QAAQ,CAAC+B,SAAS,EAAE7B,IAAI,EAAEgB,SAAS,CAAC;IAC1D,OAAO,CAAC,CAAC,EAAEzB,MAAM,CAACuC,MAAM,EAAE,CAAC,CAAC,EAAE/B,MAAM,CAACO,QAAQ,EAAEmB,OAAO,EAAEE,GAAG,EAAExB,OAAO,CAAC,EAAE,CAAC,CAAC,EAAEJ,MAAM,CAACO,QAAQ,EAAEoB,MAAM,IAAIzC,IAAI,EAAE,EAAE2C,EAAE,EAAEzB,OAAO,CAAC,CAAC,CAACQ,IAAI,CAAC,CAAC,CAAC,EAAElB,WAAW,CAACsC,OAAO,GAAG,EAAE,CAAC,CAAC,EAAEtC,WAAW,CAACmB,GAAG,EAAE,CAAC,CAACoB,OAAO,EAAEC,MAAM,CAAC,KAAK;MACrMD,OAAO,CAAClB,KAAK,CAACmB,MAAM,EAAE9B,OAAO,CAACK,QAAQ,CAAC;MACvC,OAAOwB,OAAO;IAClB,CAAC,CAAC,CAAC;EACP,CAAC;AACL;AACAzD,OAAO,CAACK,mBAAmB,GAAGA,mBAAmB;AACjD,SAASD,OAAO,CAAC2C,QAAQ,EAAE;EACvB,OAAQtB,IAAI,IAAK;IACbA,IAAI,CAACkC,KAAK,CAAC,CAACV,IAAI,EAAED,KAAK,KAAK;MACxB,IAAI,CAACA,KAAK,EAAE;QACR;MACJ;MACA,MAAMY,QAAQ,GAAGb,QAAQ,CAACC,KAAK,CAAC;MAChC,IAAIY,QAAQ,KAAKZ,KAAK,EAAE;QACpB;MACJ;MACA,IAAIY,QAAQ,KAAK,IAAI,EAAE;QACnBnC,IAAI,CAACoC,MAAM,CAACZ,IAAI,CAAC;QACjB;MACJ;MACA,IAAIW,QAAQ,CAACX,IAAI,IAAIA,IAAI,EAAE;QACvBxB,IAAI,CAACqC,MAAM,CAACb,IAAI,EAAEW,QAAQ,CAACX,IAAI,CAAC;MACpC;MACA,IAAI,CAACW,QAAQ,CAACG,OAAO,CAACC,MAAM,CAAChB,KAAK,CAACe,OAAO,CAAC,EAAE;QACzCtC,IAAI,CAACwC,SAAS,CAACL,QAAQ,CAACX,IAAI,EAAEW,QAAQ,CAACG,OAAO,CAAC;MACnD;IACJ,CAAC,CAAC;EACN,CAAC;AACL;AACA/D,OAAO,CAACI,OAAO,GAAGA,OAAO;AACzB,SAASD,oBAAoB,CAAC+D,SAAS,EAAE;EACrC,OAAQlB,KAAK,IAAK;IACd,IAAImB,OAAO,GAAGnB,KAAK;IACnB,KAAK,MAAMoB,EAAE,IAAIF,SAAS,EAAE;MACxBC,OAAO,GAAGC,EAAE,CAACD,OAAO,CAAC;MACrB,IAAIA,OAAO,KAAK,IAAI,EAAE;QAClB;QACA,OAAO,IAAI;MACf;IACJ;IACA,OAAOA,OAAO;EAClB,CAAC;AACL;AACAnE,OAAO,CAACG,oBAAoB,GAAGA,oBAAoB;AACnD,SAASD,cAAc,CAAC+C,IAAI,EAAEvB,KAAK,EAAE;EACjC,OAAO,CAACD,IAAI,EAAEG,OAAO,KAAK;IACtB,MAAMyC,MAAM,GAAG,IAAI/C,QAAQ,CAACgD,UAAU,CAAC7C,IAAI,EAAEwB,IAAI,CAAC;IAClD,OAAO,CAAC,CAAC,EAAEzB,MAAM,CAACO,QAAQ,EAAElB,KAAK,CAACa,KAAK,CAAC,EAAE2C,MAAM,EAAEzC,OAAO,CAAC,CAACQ,IAAI,CAAC,CAAC,CAAC,EAAElB,WAAW,CAACmB,GAAG,EAAGkC,MAAM,IAAK;MAC7F,IAAIA,MAAM,KAAKF,MAAM,EAAE;QACnB,OAAO5C,IAAI;MACf,CAAC,MACI;QACD,MAAM,IAAIN,WAAW,CAAC0B,mBAAmB,CAAC,4EAA4E,CAAC;MAC3H;IACJ,CAAC,CAAC,CAAC;EACP,CAAC;AACL;AACA7C,OAAO,CAACE,cAAc,GAAGA,cAAc"},"metadata":{},"sourceType":"script","externalDependencies":[]}