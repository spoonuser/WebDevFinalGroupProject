{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSystemPath = exports.asPosixPath = exports.asWindowsPath = exports.path = exports.noCacheNormalize = exports.normalize = exports.resetNormalizeCache = exports.fragment = exports.resolve = exports.relative = exports.isAbsolute = exports.join = exports.dirname = exports.basename = exports.extname = exports.split = exports.NormalizedRoot = exports.NormalizedSep = exports.PathCannotBeFragmentException = exports.PathMustBeAbsoluteException = exports.InvalidPathException = void 0;\nconst exception_1 = require(\"../exception\");\nclass InvalidPathException extends exception_1.BaseException {\n  constructor(path) {\n    super(`Path ${JSON.stringify(path)} is invalid.`);\n  }\n}\nexports.InvalidPathException = InvalidPathException;\nclass PathMustBeAbsoluteException extends exception_1.BaseException {\n  constructor(path) {\n    super(`Path ${JSON.stringify(path)} must be absolute.`);\n  }\n}\nexports.PathMustBeAbsoluteException = PathMustBeAbsoluteException;\nclass PathCannotBeFragmentException extends exception_1.BaseException {\n  constructor(path) {\n    super(`Path ${JSON.stringify(path)} cannot be made a fragment.`);\n  }\n}\nexports.PathCannotBeFragmentException = PathCannotBeFragmentException;\n/**\n * The Separator for normalized path.\n * @type {Path}\n */\nexports.NormalizedSep = '/';\n/**\n * The root of a normalized path.\n * @type {Path}\n */\nexports.NormalizedRoot = exports.NormalizedSep;\n/**\n * Split a path into multiple path fragments. Each fragments except the last one will end with\n * a path separator.\n * @param {Path} path The path to split.\n * @returns {Path[]} An array of path fragments.\n */\nfunction split(path) {\n  const fragments = path.split(exports.NormalizedSep).map(x => fragment(x));\n  if (fragments[fragments.length - 1].length === 0) {\n    fragments.pop();\n  }\n  return fragments;\n}\nexports.split = split;\n/**\n *\n */\nfunction extname(path) {\n  const base = basename(path);\n  const i = base.lastIndexOf('.');\n  if (i < 1) {\n    return '';\n  } else {\n    return base.slice(i);\n  }\n}\nexports.extname = extname;\n/**\n * Return the basename of the path, as a Path. See path.basename\n */\nfunction basename(path) {\n  const i = path.lastIndexOf(exports.NormalizedSep);\n  if (i == -1) {\n    return fragment(path);\n  } else {\n    return fragment(path.slice(path.lastIndexOf(exports.NormalizedSep) + 1));\n  }\n}\nexports.basename = basename;\n/**\n * Return the dirname of the path, as a Path. See path.dirname\n */\nfunction dirname(path) {\n  const index = path.lastIndexOf(exports.NormalizedSep);\n  if (index === -1) {\n    return '';\n  }\n  const endIndex = index === 0 ? 1 : index; // case of file under root: '/file'\n  return normalize(path.slice(0, endIndex));\n}\nexports.dirname = dirname;\n/**\n * Join multiple paths together, and normalize the result. Accepts strings that will be\n * normalized as well (but the original must be a path).\n */\nfunction join(p1, ...others) {\n  if (others.length > 0) {\n    return normalize((p1 ? p1 + exports.NormalizedSep : '') + others.join(exports.NormalizedSep));\n  } else {\n    return p1;\n  }\n}\nexports.join = join;\n/**\n * Returns true if a path is absolute.\n */\nfunction isAbsolute(p) {\n  return p.startsWith(exports.NormalizedSep);\n}\nexports.isAbsolute = isAbsolute;\n/**\n * Returns a path such that `join(from, relative(from, to)) == to`.\n * Both paths must be absolute, otherwise it does not make much sense.\n */\nfunction relative(from, to) {\n  if (!isAbsolute(from)) {\n    throw new PathMustBeAbsoluteException(from);\n  }\n  if (!isAbsolute(to)) {\n    throw new PathMustBeAbsoluteException(to);\n  }\n  let p;\n  if (from == to) {\n    p = '';\n  } else {\n    const splitFrom = split(from);\n    const splitTo = split(to);\n    while (splitFrom.length > 0 && splitTo.length > 0 && splitFrom[0] == splitTo[0]) {\n      splitFrom.shift();\n      splitTo.shift();\n    }\n    if (splitFrom.length == 0) {\n      p = splitTo.join(exports.NormalizedSep);\n    } else {\n      p = splitFrom.map(() => '..').concat(splitTo).join(exports.NormalizedSep);\n    }\n  }\n  return normalize(p);\n}\nexports.relative = relative;\n/**\n * Returns a Path that is the resolution of p2, from p1. If p2 is absolute, it will return p2,\n * otherwise will join both p1 and p2.\n */\nfunction resolve(p1, p2) {\n  if (isAbsolute(p2)) {\n    return p2;\n  } else {\n    return join(p1, p2);\n  }\n}\nexports.resolve = resolve;\nfunction fragment(path) {\n  if (path.indexOf(exports.NormalizedSep) != -1) {\n    throw new PathCannotBeFragmentException(path);\n  }\n  return path;\n}\nexports.fragment = fragment;\n/**\n * normalize() cache to reduce computation. For now this grows and we never flush it, but in the\n * future we might want to add a few cache flush to prevent this from growing too large.\n */\nlet normalizedCache = new Map();\n/**\n * Reset the cache. This is only useful for testing.\n * @private\n */\nfunction resetNormalizeCache() {\n  normalizedCache = new Map();\n}\nexports.resetNormalizeCache = resetNormalizeCache;\n/**\n * Normalize a string into a Path. This is the only mean to get a Path type from a string that\n * represents a system path. This method cache the results as real world paths tend to be\n * duplicated often.\n * Normalization includes:\n *   - Windows backslashes `\\\\` are replaced with `/`.\n *   - Windows drivers are replaced with `/X/`, where X is the drive letter.\n *   - Absolute paths starts with `/`.\n *   - Multiple `/` are replaced by a single one.\n *   - Path segments `.` are removed.\n *   - Path segments `..` are resolved.\n *   - If a path is absolute, having a `..` at the start is invalid (and will throw).\n * @param path The path to be normalized.\n */\nfunction normalize(path) {\n  let maybePath = normalizedCache.get(path);\n  if (!maybePath) {\n    maybePath = noCacheNormalize(path);\n    normalizedCache.set(path, maybePath);\n  }\n  return maybePath;\n}\nexports.normalize = normalize;\n/**\n * The no cache version of the normalize() function. Used for benchmarking and testing.\n */\nfunction noCacheNormalize(path) {\n  if (path == '' || path == '.') {\n    return '';\n  } else if (path == exports.NormalizedRoot) {\n    return exports.NormalizedRoot;\n  }\n  // Match absolute windows path.\n  const original = path;\n  if (path.match(/^[A-Z]:[/\\\\]/i)) {\n    path = '\\\\' + path[0] + '\\\\' + path.slice(3);\n  }\n  // We convert Windows paths as well here.\n  const p = path.split(/[/\\\\]/g);\n  let relative = false;\n  let i = 1;\n  // Special case the first one.\n  if (p[0] != '') {\n    p.unshift('.');\n    relative = true;\n  }\n  while (i < p.length) {\n    if (p[i] == '.') {\n      p.splice(i, 1);\n    } else if (p[i] == '..') {\n      if (i < 2 && !relative) {\n        throw new InvalidPathException(original);\n      } else if (i >= 2 && p[i - 1] != '..') {\n        p.splice(i - 1, 2);\n        i--;\n      } else {\n        i++;\n      }\n    } else if (p[i] == '') {\n      p.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n  if (p.length == 1) {\n    return p[0] == '' ? exports.NormalizedSep : '';\n  } else {\n    if (p[0] == '.') {\n      p.shift();\n    }\n    return p.join(exports.NormalizedSep);\n  }\n}\nexports.noCacheNormalize = noCacheNormalize;\nconst path = (strings, ...values) => {\n  return normalize(String.raw(strings, ...values));\n};\nexports.path = path;\nfunction asWindowsPath(path) {\n  const drive = path.match(/^\\/(\\w)(?:\\/(.*))?$/);\n  if (drive) {\n    const subPath = drive[2] ? drive[2].replace(/\\//g, '\\\\') : '';\n    return `${drive[1]}:\\\\${subPath}`;\n  }\n  return path.replace(/\\//g, '\\\\');\n}\nexports.asWindowsPath = asWindowsPath;\nfunction asPosixPath(path) {\n  return path;\n}\nexports.asPosixPath = asPosixPath;\nfunction getSystemPath(path) {\n  if (process.platform.startsWith('win32')) {\n    return asWindowsPath(path);\n  } else {\n    return asPosixPath(path);\n  }\n}\nexports.getSystemPath = getSystemPath;","map":{"version":3,"names":["Object","defineProperty","exports","value","getSystemPath","asPosixPath","asWindowsPath","path","noCacheNormalize","normalize","resetNormalizeCache","fragment","resolve","relative","isAbsolute","join","dirname","basename","extname","split","NormalizedRoot","NormalizedSep","PathCannotBeFragmentException","PathMustBeAbsoluteException","InvalidPathException","exception_1","require","BaseException","constructor","JSON","stringify","fragments","map","x","length","pop","base","i","lastIndexOf","slice","index","endIndex","p1","others","p","startsWith","from","to","splitFrom","splitTo","shift","concat","p2","indexOf","normalizedCache","Map","maybePath","get","set","original","match","unshift","splice","strings","values","String","raw","drive","subPath","replace","process","platform"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/node_modules/@angular-devkit/core/src/virtual-fs/path.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSystemPath = exports.asPosixPath = exports.asWindowsPath = exports.path = exports.noCacheNormalize = exports.normalize = exports.resetNormalizeCache = exports.fragment = exports.resolve = exports.relative = exports.isAbsolute = exports.join = exports.dirname = exports.basename = exports.extname = exports.split = exports.NormalizedRoot = exports.NormalizedSep = exports.PathCannotBeFragmentException = exports.PathMustBeAbsoluteException = exports.InvalidPathException = void 0;\nconst exception_1 = require(\"../exception\");\nclass InvalidPathException extends exception_1.BaseException {\n    constructor(path) {\n        super(`Path ${JSON.stringify(path)} is invalid.`);\n    }\n}\nexports.InvalidPathException = InvalidPathException;\nclass PathMustBeAbsoluteException extends exception_1.BaseException {\n    constructor(path) {\n        super(`Path ${JSON.stringify(path)} must be absolute.`);\n    }\n}\nexports.PathMustBeAbsoluteException = PathMustBeAbsoluteException;\nclass PathCannotBeFragmentException extends exception_1.BaseException {\n    constructor(path) {\n        super(`Path ${JSON.stringify(path)} cannot be made a fragment.`);\n    }\n}\nexports.PathCannotBeFragmentException = PathCannotBeFragmentException;\n/**\n * The Separator for normalized path.\n * @type {Path}\n */\nexports.NormalizedSep = '/';\n/**\n * The root of a normalized path.\n * @type {Path}\n */\nexports.NormalizedRoot = exports.NormalizedSep;\n/**\n * Split a path into multiple path fragments. Each fragments except the last one will end with\n * a path separator.\n * @param {Path} path The path to split.\n * @returns {Path[]} An array of path fragments.\n */\nfunction split(path) {\n    const fragments = path.split(exports.NormalizedSep).map((x) => fragment(x));\n    if (fragments[fragments.length - 1].length === 0) {\n        fragments.pop();\n    }\n    return fragments;\n}\nexports.split = split;\n/**\n *\n */\nfunction extname(path) {\n    const base = basename(path);\n    const i = base.lastIndexOf('.');\n    if (i < 1) {\n        return '';\n    }\n    else {\n        return base.slice(i);\n    }\n}\nexports.extname = extname;\n/**\n * Return the basename of the path, as a Path. See path.basename\n */\nfunction basename(path) {\n    const i = path.lastIndexOf(exports.NormalizedSep);\n    if (i == -1) {\n        return fragment(path);\n    }\n    else {\n        return fragment(path.slice(path.lastIndexOf(exports.NormalizedSep) + 1));\n    }\n}\nexports.basename = basename;\n/**\n * Return the dirname of the path, as a Path. See path.dirname\n */\nfunction dirname(path) {\n    const index = path.lastIndexOf(exports.NormalizedSep);\n    if (index === -1) {\n        return '';\n    }\n    const endIndex = index === 0 ? 1 : index; // case of file under root: '/file'\n    return normalize(path.slice(0, endIndex));\n}\nexports.dirname = dirname;\n/**\n * Join multiple paths together, and normalize the result. Accepts strings that will be\n * normalized as well (but the original must be a path).\n */\nfunction join(p1, ...others) {\n    if (others.length > 0) {\n        return normalize((p1 ? p1 + exports.NormalizedSep : '') + others.join(exports.NormalizedSep));\n    }\n    else {\n        return p1;\n    }\n}\nexports.join = join;\n/**\n * Returns true if a path is absolute.\n */\nfunction isAbsolute(p) {\n    return p.startsWith(exports.NormalizedSep);\n}\nexports.isAbsolute = isAbsolute;\n/**\n * Returns a path such that `join(from, relative(from, to)) == to`.\n * Both paths must be absolute, otherwise it does not make much sense.\n */\nfunction relative(from, to) {\n    if (!isAbsolute(from)) {\n        throw new PathMustBeAbsoluteException(from);\n    }\n    if (!isAbsolute(to)) {\n        throw new PathMustBeAbsoluteException(to);\n    }\n    let p;\n    if (from == to) {\n        p = '';\n    }\n    else {\n        const splitFrom = split(from);\n        const splitTo = split(to);\n        while (splitFrom.length > 0 && splitTo.length > 0 && splitFrom[0] == splitTo[0]) {\n            splitFrom.shift();\n            splitTo.shift();\n        }\n        if (splitFrom.length == 0) {\n            p = splitTo.join(exports.NormalizedSep);\n        }\n        else {\n            p = splitFrom\n                .map(() => '..')\n                .concat(splitTo)\n                .join(exports.NormalizedSep);\n        }\n    }\n    return normalize(p);\n}\nexports.relative = relative;\n/**\n * Returns a Path that is the resolution of p2, from p1. If p2 is absolute, it will return p2,\n * otherwise will join both p1 and p2.\n */\nfunction resolve(p1, p2) {\n    if (isAbsolute(p2)) {\n        return p2;\n    }\n    else {\n        return join(p1, p2);\n    }\n}\nexports.resolve = resolve;\nfunction fragment(path) {\n    if (path.indexOf(exports.NormalizedSep) != -1) {\n        throw new PathCannotBeFragmentException(path);\n    }\n    return path;\n}\nexports.fragment = fragment;\n/**\n * normalize() cache to reduce computation. For now this grows and we never flush it, but in the\n * future we might want to add a few cache flush to prevent this from growing too large.\n */\nlet normalizedCache = new Map();\n/**\n * Reset the cache. This is only useful for testing.\n * @private\n */\nfunction resetNormalizeCache() {\n    normalizedCache = new Map();\n}\nexports.resetNormalizeCache = resetNormalizeCache;\n/**\n * Normalize a string into a Path. This is the only mean to get a Path type from a string that\n * represents a system path. This method cache the results as real world paths tend to be\n * duplicated often.\n * Normalization includes:\n *   - Windows backslashes `\\\\` are replaced with `/`.\n *   - Windows drivers are replaced with `/X/`, where X is the drive letter.\n *   - Absolute paths starts with `/`.\n *   - Multiple `/` are replaced by a single one.\n *   - Path segments `.` are removed.\n *   - Path segments `..` are resolved.\n *   - If a path is absolute, having a `..` at the start is invalid (and will throw).\n * @param path The path to be normalized.\n */\nfunction normalize(path) {\n    let maybePath = normalizedCache.get(path);\n    if (!maybePath) {\n        maybePath = noCacheNormalize(path);\n        normalizedCache.set(path, maybePath);\n    }\n    return maybePath;\n}\nexports.normalize = normalize;\n/**\n * The no cache version of the normalize() function. Used for benchmarking and testing.\n */\nfunction noCacheNormalize(path) {\n    if (path == '' || path == '.') {\n        return '';\n    }\n    else if (path == exports.NormalizedRoot) {\n        return exports.NormalizedRoot;\n    }\n    // Match absolute windows path.\n    const original = path;\n    if (path.match(/^[A-Z]:[/\\\\]/i)) {\n        path = '\\\\' + path[0] + '\\\\' + path.slice(3);\n    }\n    // We convert Windows paths as well here.\n    const p = path.split(/[/\\\\]/g);\n    let relative = false;\n    let i = 1;\n    // Special case the first one.\n    if (p[0] != '') {\n        p.unshift('.');\n        relative = true;\n    }\n    while (i < p.length) {\n        if (p[i] == '.') {\n            p.splice(i, 1);\n        }\n        else if (p[i] == '..') {\n            if (i < 2 && !relative) {\n                throw new InvalidPathException(original);\n            }\n            else if (i >= 2 && p[i - 1] != '..') {\n                p.splice(i - 1, 2);\n                i--;\n            }\n            else {\n                i++;\n            }\n        }\n        else if (p[i] == '') {\n            p.splice(i, 1);\n        }\n        else {\n            i++;\n        }\n    }\n    if (p.length == 1) {\n        return p[0] == '' ? exports.NormalizedSep : '';\n    }\n    else {\n        if (p[0] == '.') {\n            p.shift();\n        }\n        return p.join(exports.NormalizedSep);\n    }\n}\nexports.noCacheNormalize = noCacheNormalize;\nconst path = (strings, ...values) => {\n    return normalize(String.raw(strings, ...values));\n};\nexports.path = path;\nfunction asWindowsPath(path) {\n    const drive = path.match(/^\\/(\\w)(?:\\/(.*))?$/);\n    if (drive) {\n        const subPath = drive[2] ? drive[2].replace(/\\//g, '\\\\') : '';\n        return `${drive[1]}:\\\\${subPath}`;\n    }\n    return path.replace(/\\//g, '\\\\');\n}\nexports.asWindowsPath = asWindowsPath;\nfunction asPosixPath(path) {\n    return path;\n}\nexports.asPosixPath = asPosixPath;\nfunction getSystemPath(path) {\n    if (process.platform.startsWith('win32')) {\n        return asWindowsPath(path);\n    }\n    else {\n        return asPosixPath(path);\n    }\n}\nexports.getSystemPath = getSystemPath;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}