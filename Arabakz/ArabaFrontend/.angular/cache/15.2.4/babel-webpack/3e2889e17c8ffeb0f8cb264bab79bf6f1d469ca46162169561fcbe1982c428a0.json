{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyTemplates = exports.template = exports.renameTemplateFiles = exports.pathTemplate = exports.applyPathTemplate = exports.contentTemplate = exports.applyContentTemplate = exports.InvalidPipeException = exports.UnknownPipeException = exports.OptionIsNotDefinedException = exports.TEMPLATE_FILENAME_RE = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst util_1 = require(\"util\");\nconst base_1 = require(\"./base\");\nexports.TEMPLATE_FILENAME_RE = /\\.template$/;\nclass OptionIsNotDefinedException extends core_1.BaseException {\n  constructor(name) {\n    super(`Option \"${name}\" is not defined.`);\n  }\n}\nexports.OptionIsNotDefinedException = OptionIsNotDefinedException;\nclass UnknownPipeException extends core_1.BaseException {\n  constructor(name) {\n    super(`Pipe \"${name}\" is not defined.`);\n  }\n}\nexports.UnknownPipeException = UnknownPipeException;\nclass InvalidPipeException extends core_1.BaseException {\n  constructor(name) {\n    super(`Pipe \"${name}\" is invalid.`);\n  }\n}\nexports.InvalidPipeException = InvalidPipeException;\nconst decoder = new util_1.TextDecoder('utf-8', {\n  fatal: true\n});\nfunction applyContentTemplate(options) {\n  return entry => {\n    const {\n      path,\n      content\n    } = entry;\n    try {\n      const decodedContent = decoder.decode(content);\n      return {\n        path,\n        content: Buffer.from((0, core_1.template)(decodedContent, {})(options))\n      };\n    } catch (e) {\n      if (e.code === 'ERR_ENCODING_INVALID_ENCODED_DATA') {\n        return entry;\n      }\n      throw e;\n    }\n  };\n}\nexports.applyContentTemplate = applyContentTemplate;\nfunction contentTemplate(options) {\n  return (0, base_1.forEach)(applyContentTemplate(options));\n}\nexports.contentTemplate = contentTemplate;\nfunction applyPathTemplate(data, options = {\n  interpolationStart: '__',\n  interpolationEnd: '__',\n  pipeSeparator: '@'\n}) {\n  const is = options.interpolationStart;\n  const ie = options.interpolationEnd;\n  const isL = is.length;\n  const ieL = ie.length;\n  return entry => {\n    let path = entry.path;\n    const content = entry.content;\n    const original = path;\n    let start = path.indexOf(is);\n    // + 1 to have at least a length 1 name. `____` is not valid.\n    let end = path.indexOf(ie, start + isL + 1);\n    while (start != -1 && end != -1) {\n      const match = path.substring(start + isL, end);\n      let replacement = data[match];\n      if (!options.pipeSeparator) {\n        if (typeof replacement == 'function') {\n          replacement = replacement.call(data, original);\n        }\n        if (replacement === undefined) {\n          throw new OptionIsNotDefinedException(match);\n        }\n      } else {\n        const [name, ...pipes] = match.split(options.pipeSeparator);\n        replacement = data[name];\n        if (typeof replacement == 'function') {\n          replacement = replacement.call(data, original);\n        }\n        if (replacement === undefined) {\n          throw new OptionIsNotDefinedException(name);\n        }\n        replacement = pipes.reduce((acc, pipe) => {\n          if (!pipe) {\n            return acc;\n          }\n          if (!(pipe in data)) {\n            throw new UnknownPipeException(pipe);\n          }\n          if (typeof data[pipe] != 'function') {\n            throw new InvalidPipeException(pipe);\n          }\n          // Coerce to string.\n          return '' + data[pipe](acc);\n        }, '' + replacement);\n      }\n      path = path.substring(0, start) + replacement + path.substring(end + ieL);\n      start = path.indexOf(options.interpolationStart);\n      // See above.\n      end = path.indexOf(options.interpolationEnd, start + isL + 1);\n    }\n    return {\n      path: (0, core_1.normalize)(path),\n      content\n    };\n  };\n}\nexports.applyPathTemplate = applyPathTemplate;\nfunction pathTemplate(options) {\n  return (0, base_1.forEach)(applyPathTemplate(options));\n}\nexports.pathTemplate = pathTemplate;\n/**\n * Remove every `.template` suffix from file names.\n */\nfunction renameTemplateFiles() {\n  return (0, base_1.forEach)(entry => {\n    if (entry.path.match(exports.TEMPLATE_FILENAME_RE)) {\n      return {\n        content: entry.content,\n        path: (0, core_1.normalize)(entry.path.replace(exports.TEMPLATE_FILENAME_RE, ''))\n      };\n    } else {\n      return entry;\n    }\n  });\n}\nexports.renameTemplateFiles = renameTemplateFiles;\nfunction template(options) {\n  return (0, base_1.chain)([contentTemplate(options),\n  // Force cast to PathTemplateData. We need the type for the actual pathTemplate() call,\n  // but in this case we cannot do anything as contentTemplate are more permissive.\n  // Since values are coerced to strings in PathTemplates it will be fine in the end.\n  pathTemplate(options)]);\n}\nexports.template = template;\nfunction applyTemplates(options) {\n  return (0, base_1.forEach)((0, base_1.when)(path => path.endsWith('.template'), (0, base_1.composeFileOperators)([applyContentTemplate(options),\n  // See above for this weird cast.\n  applyPathTemplate(options), entry => {\n    return {\n      content: entry.content,\n      path: entry.path.replace(exports.TEMPLATE_FILENAME_RE, '')\n    };\n  }])));\n}\nexports.applyTemplates = applyTemplates;","map":{"version":3,"names":["Object","defineProperty","exports","value","applyTemplates","template","renameTemplateFiles","pathTemplate","applyPathTemplate","contentTemplate","applyContentTemplate","InvalidPipeException","UnknownPipeException","OptionIsNotDefinedException","TEMPLATE_FILENAME_RE","core_1","require","util_1","base_1","BaseException","constructor","name","decoder","TextDecoder","fatal","options","entry","path","content","decodedContent","decode","Buffer","from","e","code","forEach","data","interpolationStart","interpolationEnd","pipeSeparator","is","ie","isL","length","ieL","original","start","indexOf","end","match","substring","replacement","call","undefined","pipes","split","reduce","acc","pipe","normalize","replace","chain","when","endsWith","composeFileOperators"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular-devkit/schematics/src/rules/template.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyTemplates = exports.template = exports.renameTemplateFiles = exports.pathTemplate = exports.applyPathTemplate = exports.contentTemplate = exports.applyContentTemplate = exports.InvalidPipeException = exports.UnknownPipeException = exports.OptionIsNotDefinedException = exports.TEMPLATE_FILENAME_RE = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst util_1 = require(\"util\");\nconst base_1 = require(\"./base\");\nexports.TEMPLATE_FILENAME_RE = /\\.template$/;\nclass OptionIsNotDefinedException extends core_1.BaseException {\n    constructor(name) {\n        super(`Option \"${name}\" is not defined.`);\n    }\n}\nexports.OptionIsNotDefinedException = OptionIsNotDefinedException;\nclass UnknownPipeException extends core_1.BaseException {\n    constructor(name) {\n        super(`Pipe \"${name}\" is not defined.`);\n    }\n}\nexports.UnknownPipeException = UnknownPipeException;\nclass InvalidPipeException extends core_1.BaseException {\n    constructor(name) {\n        super(`Pipe \"${name}\" is invalid.`);\n    }\n}\nexports.InvalidPipeException = InvalidPipeException;\nconst decoder = new util_1.TextDecoder('utf-8', { fatal: true });\nfunction applyContentTemplate(options) {\n    return (entry) => {\n        const { path, content } = entry;\n        try {\n            const decodedContent = decoder.decode(content);\n            return {\n                path,\n                content: Buffer.from((0, core_1.template)(decodedContent, {})(options)),\n            };\n        }\n        catch (e) {\n            if (e.code === 'ERR_ENCODING_INVALID_ENCODED_DATA') {\n                return entry;\n            }\n            throw e;\n        }\n    };\n}\nexports.applyContentTemplate = applyContentTemplate;\nfunction contentTemplate(options) {\n    return (0, base_1.forEach)(applyContentTemplate(options));\n}\nexports.contentTemplate = contentTemplate;\nfunction applyPathTemplate(data, options = {\n    interpolationStart: '__',\n    interpolationEnd: '__',\n    pipeSeparator: '@',\n}) {\n    const is = options.interpolationStart;\n    const ie = options.interpolationEnd;\n    const isL = is.length;\n    const ieL = ie.length;\n    return (entry) => {\n        let path = entry.path;\n        const content = entry.content;\n        const original = path;\n        let start = path.indexOf(is);\n        // + 1 to have at least a length 1 name. `____` is not valid.\n        let end = path.indexOf(ie, start + isL + 1);\n        while (start != -1 && end != -1) {\n            const match = path.substring(start + isL, end);\n            let replacement = data[match];\n            if (!options.pipeSeparator) {\n                if (typeof replacement == 'function') {\n                    replacement = replacement.call(data, original);\n                }\n                if (replacement === undefined) {\n                    throw new OptionIsNotDefinedException(match);\n                }\n            }\n            else {\n                const [name, ...pipes] = match.split(options.pipeSeparator);\n                replacement = data[name];\n                if (typeof replacement == 'function') {\n                    replacement = replacement.call(data, original);\n                }\n                if (replacement === undefined) {\n                    throw new OptionIsNotDefinedException(name);\n                }\n                replacement = pipes.reduce((acc, pipe) => {\n                    if (!pipe) {\n                        return acc;\n                    }\n                    if (!(pipe in data)) {\n                        throw new UnknownPipeException(pipe);\n                    }\n                    if (typeof data[pipe] != 'function') {\n                        throw new InvalidPipeException(pipe);\n                    }\n                    // Coerce to string.\n                    return '' + data[pipe](acc);\n                }, '' + replacement);\n            }\n            path = path.substring(0, start) + replacement + path.substring(end + ieL);\n            start = path.indexOf(options.interpolationStart);\n            // See above.\n            end = path.indexOf(options.interpolationEnd, start + isL + 1);\n        }\n        return { path: (0, core_1.normalize)(path), content };\n    };\n}\nexports.applyPathTemplate = applyPathTemplate;\nfunction pathTemplate(options) {\n    return (0, base_1.forEach)(applyPathTemplate(options));\n}\nexports.pathTemplate = pathTemplate;\n/**\n * Remove every `.template` suffix from file names.\n */\nfunction renameTemplateFiles() {\n    return (0, base_1.forEach)((entry) => {\n        if (entry.path.match(exports.TEMPLATE_FILENAME_RE)) {\n            return {\n                content: entry.content,\n                path: (0, core_1.normalize)(entry.path.replace(exports.TEMPLATE_FILENAME_RE, '')),\n            };\n        }\n        else {\n            return entry;\n        }\n    });\n}\nexports.renameTemplateFiles = renameTemplateFiles;\nfunction template(options) {\n    return (0, base_1.chain)([\n        contentTemplate(options),\n        // Force cast to PathTemplateData. We need the type for the actual pathTemplate() call,\n        // but in this case we cannot do anything as contentTemplate are more permissive.\n        // Since values are coerced to strings in PathTemplates it will be fine in the end.\n        pathTemplate(options),\n    ]);\n}\nexports.template = template;\nfunction applyTemplates(options) {\n    return (0, base_1.forEach)((0, base_1.when)((path) => path.endsWith('.template'), (0, base_1.composeFileOperators)([\n        applyContentTemplate(options),\n        // See above for this weird cast.\n        applyPathTemplate(options),\n        (entry) => {\n            return {\n                content: entry.content,\n                path: entry.path.replace(exports.TEMPLATE_FILENAME_RE, ''),\n            };\n        },\n    ])));\n}\nexports.applyTemplates = applyTemplates;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}