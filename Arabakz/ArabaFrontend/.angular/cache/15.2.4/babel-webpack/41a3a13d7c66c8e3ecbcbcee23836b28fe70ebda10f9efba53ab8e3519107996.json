{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeSchemas = exports.isJsonSchema = void 0;\nconst utils_1 = require(\"../utils\");\nfunction isJsonSchema(value) {\n  return (0, utils_1.isJsonObject)(value) || value === false || value === true;\n}\nexports.isJsonSchema = isJsonSchema;\n/**\n * Return a schema that is the merge of all subschemas, ie. it should validate all the schemas\n * that were passed in. It is possible to make an invalid schema this way, e.g. by using\n * `mergeSchemas({ type: 'number' }, { type: 'string' })`, which will never validate.\n * @param schemas All schemas to be merged.\n */\nfunction mergeSchemas(...schemas) {\n  return schemas.reduce((prev, curr) => {\n    if (curr === undefined) {\n      return prev;\n    }\n    if (prev === false || curr === false) {\n      return false;\n    } else if (prev === true) {\n      return curr;\n    } else if (curr === true) {\n      return prev;\n    } else if (Array.isArray(prev.allOf)) {\n      if (Array.isArray(curr.allOf)) {\n        return {\n          ...prev,\n          allOf: [...prev.allOf, ...curr.allOf]\n        };\n      } else {\n        return {\n          ...prev,\n          allOf: [...prev.allOf, curr]\n        };\n      }\n    } else if (Array.isArray(curr.allOf)) {\n      return {\n        ...prev,\n        allOf: [prev, ...curr.allOf]\n      };\n    } else {\n      return {\n        ...prev,\n        allOf: [prev, curr]\n      };\n    }\n  }, true);\n}\nexports.mergeSchemas = mergeSchemas;","map":{"version":3,"names":["Object","defineProperty","exports","value","mergeSchemas","isJsonSchema","utils_1","require","isJsonObject","schemas","reduce","prev","curr","undefined","Array","isArray","allOf"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/node_modules/@angular-devkit/core/src/json/schema/schema.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeSchemas = exports.isJsonSchema = void 0;\nconst utils_1 = require(\"../utils\");\nfunction isJsonSchema(value) {\n    return (0, utils_1.isJsonObject)(value) || value === false || value === true;\n}\nexports.isJsonSchema = isJsonSchema;\n/**\n * Return a schema that is the merge of all subschemas, ie. it should validate all the schemas\n * that were passed in. It is possible to make an invalid schema this way, e.g. by using\n * `mergeSchemas({ type: 'number' }, { type: 'string' })`, which will never validate.\n * @param schemas All schemas to be merged.\n */\nfunction mergeSchemas(...schemas) {\n    return schemas.reduce((prev, curr) => {\n        if (curr === undefined) {\n            return prev;\n        }\n        if (prev === false || curr === false) {\n            return false;\n        }\n        else if (prev === true) {\n            return curr;\n        }\n        else if (curr === true) {\n            return prev;\n        }\n        else if (Array.isArray(prev.allOf)) {\n            if (Array.isArray(curr.allOf)) {\n                return { ...prev, allOf: [...prev.allOf, ...curr.allOf] };\n            }\n            else {\n                return { ...prev, allOf: [...prev.allOf, curr] };\n            }\n        }\n        else if (Array.isArray(curr.allOf)) {\n            return { ...prev, allOf: [prev, ...curr.allOf] };\n        }\n        else {\n            return { ...prev, allOf: [prev, curr] };\n        }\n    }, true);\n}\nexports.mergeSchemas = mergeSchemas;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,YAAY,GAAGF,OAAO,CAACG,YAAY,GAAG,KAAK,CAAC;AACpD,MAAMC,OAAO,GAAGC,OAAO,CAAC,UAAU,CAAC;AACnC,SAASF,YAAY,CAACF,KAAK,EAAE;EACzB,OAAO,CAAC,CAAC,EAAEG,OAAO,CAACE,YAAY,EAAEL,KAAK,CAAC,IAAIA,KAAK,KAAK,KAAK,IAAIA,KAAK,KAAK,IAAI;AAChF;AACAD,OAAO,CAACG,YAAY,GAAGA,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,YAAY,CAAC,GAAGK,OAAO,EAAE;EAC9B,OAAOA,OAAO,CAACC,MAAM,CAAC,CAACC,IAAI,EAAEC,IAAI,KAAK;IAClC,IAAIA,IAAI,KAAKC,SAAS,EAAE;MACpB,OAAOF,IAAI;IACf;IACA,IAAIA,IAAI,KAAK,KAAK,IAAIC,IAAI,KAAK,KAAK,EAAE;MAClC,OAAO,KAAK;IAChB,CAAC,MACI,IAAID,IAAI,KAAK,IAAI,EAAE;MACpB,OAAOC,IAAI;IACf,CAAC,MACI,IAAIA,IAAI,KAAK,IAAI,EAAE;MACpB,OAAOD,IAAI;IACf,CAAC,MACI,IAAIG,KAAK,CAACC,OAAO,CAACJ,IAAI,CAACK,KAAK,CAAC,EAAE;MAChC,IAAIF,KAAK,CAACC,OAAO,CAACH,IAAI,CAACI,KAAK,CAAC,EAAE;QAC3B,OAAO;UAAE,GAAGL,IAAI;UAAEK,KAAK,EAAE,CAAC,GAAGL,IAAI,CAACK,KAAK,EAAE,GAAGJ,IAAI,CAACI,KAAK;QAAE,CAAC;MAC7D,CAAC,MACI;QACD,OAAO;UAAE,GAAGL,IAAI;UAAEK,KAAK,EAAE,CAAC,GAAGL,IAAI,CAACK,KAAK,EAAEJ,IAAI;QAAE,CAAC;MACpD;IACJ,CAAC,MACI,IAAIE,KAAK,CAACC,OAAO,CAACH,IAAI,CAACI,KAAK,CAAC,EAAE;MAChC,OAAO;QAAE,GAAGL,IAAI;QAAEK,KAAK,EAAE,CAACL,IAAI,EAAE,GAAGC,IAAI,CAACI,KAAK;MAAE,CAAC;IACpD,CAAC,MACI;MACD,OAAO;QAAE,GAAGL,IAAI;QAAEK,KAAK,EAAE,CAACL,IAAI,EAAEC,IAAI;MAAE,CAAC;IAC3C;EACJ,CAAC,EAAE,IAAI,CAAC;AACZ;AACAV,OAAO,CAACE,YAAY,GAAGA,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}