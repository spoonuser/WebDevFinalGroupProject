{"ast":null,"code":"'use strict';\n\nvar util = require('util'),\n  Match = require('../match');\n\n/**\n * This class matches UTF-16 and UTF-32, both big- and little-endian. The\n * BOM will be used if it is present.\n */\nmodule.exports.UTF_16BE = function () {\n  this.name = function () {\n    return 'UTF-16BE';\n  };\n  this.match = function (det) {\n    var input = det.fRawInput;\n    if (input.length >= 2 && (input[0] & 0xff) == 0xfe && (input[1] & 0xff) == 0xff) {\n      return new Match(det, this, 100); // confidence = 100\n    }\n\n    // TODO: Do some statistics to check for unsigned UTF-16BE\n    return null;\n  };\n};\nmodule.exports.UTF_16LE = function () {\n  this.name = function () {\n    return 'UTF-16LE';\n  };\n  this.match = function (det) {\n    var input = det.fRawInput;\n    if (input.length >= 2 && (input[0] & 0xff) == 0xff && (input[1] & 0xff) == 0xfe) {\n      // LE BOM is present.\n      if (input.length >= 4 && input[2] == 0x00 && input[3] == 0x00) {\n        // It is probably UTF-32 LE, not UTF-16\n        return null;\n      }\n      return new Match(det, this, 100); // confidence = 100\n    }\n\n    // TODO: Do some statistics to check for unsigned UTF-16LE\n    return null;\n  };\n};\nfunction UTF_32() {}\n;\nUTF_32.prototype.match = function (det) {\n  var input = det.fRawInput,\n    limit = det.fRawLength / 4 * 4,\n    numValid = 0,\n    numInvalid = 0,\n    hasBOM = false,\n    confidence = 0;\n  if (limit == 0) {\n    return null;\n  }\n  if (this.getChar(input, 0) == 0x0000FEFF) {\n    hasBOM = true;\n  }\n  for (var i = 0; i < limit; i += 4) {\n    var ch = this.getChar(input, i);\n    if (ch < 0 || ch >= 0x10FFFF || ch >= 0xD800 && ch <= 0xDFFF) {\n      numInvalid += 1;\n    } else {\n      numValid += 1;\n    }\n  }\n\n  // Cook up some sort of confidence score, based on presence of a BOM\n  //    and the existence of valid and/or invalid multi-byte sequences.\n  if (hasBOM && numInvalid == 0) {\n    confidence = 100;\n  } else if (hasBOM && numValid > numInvalid * 10) {\n    confidence = 80;\n  } else if (numValid > 3 && numInvalid == 0) {\n    confidence = 100;\n  } else if (numValid > 0 && numInvalid == 0) {\n    confidence = 80;\n  } else if (numValid > numInvalid * 10) {\n    // Probably corrupt UTF-32BE data.  Valid sequences aren't likely by chance.\n    confidence = 25;\n  }\n\n  // return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n  return confidence == 0 ? null : new Match(det, this, confidence);\n};\nmodule.exports.UTF_32BE = function () {\n  this.name = function () {\n    return 'UTF-32BE';\n  };\n  this.getChar = function (input, index) {\n    return (input[index + 0] & 0xff) << 24 | (input[index + 1] & 0xff) << 16 | (input[index + 2] & 0xff) << 8 | input[index + 3] & 0xff;\n  };\n};\nutil.inherits(module.exports.UTF_32BE, UTF_32);\nmodule.exports.UTF_32LE = function () {\n  this.name = function () {\n    return 'UTF-32LE';\n  };\n  this.getChar = function (input, index) {\n    return (input[index + 3] & 0xff) << 24 | (input[index + 2] & 0xff) << 16 | (input[index + 1] & 0xff) << 8 | input[index + 0] & 0xff;\n  };\n};\nutil.inherits(module.exports.UTF_32LE, UTF_32);","map":{"version":3,"names":["util","require","Match","module","exports","UTF_16BE","name","match","det","input","fRawInput","length","UTF_16LE","UTF_32","prototype","limit","fRawLength","numValid","numInvalid","hasBOM","confidence","getChar","i","ch","UTF_32BE","index","inherits","UTF_32LE"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/chardet/encoding/unicode.js"],"sourcesContent":["'use strict';\nvar util = require('util'),\n  Match = require ('../match');\n\n/**\n * This class matches UTF-16 and UTF-32, both big- and little-endian. The\n * BOM will be used if it is present.\n */\nmodule.exports.UTF_16BE = function() {\n  this.name = function() {\n    return 'UTF-16BE';\n  };\n  this.match = function(det) {\n    var input = det.fRawInput;\n\n    if (input.length >= 2 && ((input[0] & 0xff) == 0xfe && (input[1] & 0xff) == 0xff)) {\n      return new Match(det, this, 100); // confidence = 100\n    }\n\n    // TODO: Do some statistics to check for unsigned UTF-16BE\n    return null;\n  };\n};\n\nmodule.exports.UTF_16LE = function() {\n  this.name = function() {\n    return 'UTF-16LE';\n  };\n  this.match = function(det) {\n    var input = det.fRawInput;\n\n    if (input.length >= 2 && ((input[0] & 0xff) == 0xff && (input[1] & 0xff) == 0xfe)) {\n      // LE BOM is present.\n      if (input.length >= 4 && input[2] == 0x00 && input[3] == 0x00) {\n        // It is probably UTF-32 LE, not UTF-16\n        return null;\n      }\n      return new Match(det, this, 100); // confidence = 100\n    }\n\n    // TODO: Do some statistics to check for unsigned UTF-16LE\n    return null;\n  }\n};\n\nfunction UTF_32() {};\nUTF_32.prototype.match = function(det) {\n  var input      = det.fRawInput,\n    limit      = (det.fRawLength / 4) * 4,\n    numValid   = 0,\n    numInvalid = 0,\n    hasBOM     = false,\n    confidence = 0;\n\n  if (limit == 0) {\n    return null;\n  }\n\n  if (this.getChar(input, 0) == 0x0000FEFF) {\n    hasBOM = true;\n  }\n\n  for (var i = 0; i < limit; i += 4) {\n    var ch = this.getChar(input, i);\n\n    if (ch < 0 || ch >= 0x10FFFF || (ch >= 0xD800 && ch <= 0xDFFF)) {\n      numInvalid += 1;\n    } else {\n      numValid += 1;\n    }\n  }\n\n  // Cook up some sort of confidence score, based on presence of a BOM\n  //    and the existence of valid and/or invalid multi-byte sequences.\n  if (hasBOM && numInvalid == 0) {\n    confidence = 100;\n  } else if (hasBOM && numValid > numInvalid * 10) {\n    confidence = 80;\n  } else if (numValid > 3 && numInvalid == 0) {\n    confidence = 100;\n  } else if (numValid > 0 && numInvalid == 0) {\n    confidence = 80;\n  } else if (numValid > numInvalid * 10) {\n    // Probably corrupt UTF-32BE data.  Valid sequences aren't likely by chance.\n    confidence = 25;\n  }\n\n  // return confidence == 0 ? null : new CharsetMatch(det, this, confidence);\n  return confidence == 0 ? null : new Match(det, this, confidence);\n};\n\nmodule.exports.UTF_32BE = function() {\n  this.name = function() {\n    return 'UTF-32BE';\n  };\n  this.getChar = function(input, index) {\n    return (input[index + 0] & 0xff) << 24 | (input[index + 1] & 0xff) << 16 |\n         (input[index + 2] & 0xff) <<  8 | (input[index + 3] & 0xff);\n  };\n};\nutil.inherits(module.exports.UTF_32BE, UTF_32);\n\nmodule.exports.UTF_32LE = function() {\n  this.name = function() {\n    return 'UTF-32LE';\n  };\n  this.getChar = function(input, index) {\n    return (input[index + 3] & 0xff) << 24 | (input[index + 2] & 0xff) << 16 |\n         (input[index + 1] & 0xff) <<  8 | (input[index + 0] & 0xff);\n  };\n};\nutil.inherits(module.exports.UTF_32LE, UTF_32);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}