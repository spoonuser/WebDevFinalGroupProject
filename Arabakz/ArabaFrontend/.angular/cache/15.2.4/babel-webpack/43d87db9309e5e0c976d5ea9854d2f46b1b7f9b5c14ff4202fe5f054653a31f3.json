{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { format, isEOL } from './format';\nimport { parseTree, findNodeAtLocation } from './parser';\nexport function removeProperty(text, path, options) {\n  return setProperty(text, path, void 0, options);\n}\nexport function setProperty(text, originalPath, value, options) {\n  const path = originalPath.slice();\n  const errors = [];\n  const root = parseTree(text, errors);\n  let parent = void 0;\n  let lastSegment = void 0;\n  while (path.length > 0) {\n    lastSegment = path.pop();\n    parent = findNodeAtLocation(root, path);\n    if (parent === void 0 && value !== void 0) {\n      if (typeof lastSegment === 'string') {\n        value = {\n          [lastSegment]: value\n        };\n      } else {\n        value = [value];\n      }\n    } else {\n      break;\n    }\n  }\n  if (!parent) {\n    // empty document\n    if (value === void 0) {\n      // delete\n      throw new Error('Can not delete in empty document');\n    }\n    return withFormatting(text, {\n      offset: root ? root.offset : 0,\n      length: root ? root.length : 0,\n      content: JSON.stringify(value)\n    }, options);\n  } else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n    const existing = findNodeAtLocation(parent, [lastSegment]);\n    if (existing !== void 0) {\n      if (value === void 0) {\n        // delete\n        if (!existing.parent) {\n          throw new Error('Malformed AST');\n        }\n        const propertyIndex = parent.children.indexOf(existing.parent);\n        let removeBegin;\n        let removeEnd = existing.parent.offset + existing.parent.length;\n        if (propertyIndex > 0) {\n          // remove the comma of the previous node\n          let previous = parent.children[propertyIndex - 1];\n          removeBegin = previous.offset + previous.length;\n        } else {\n          removeBegin = parent.offset + 1;\n          if (parent.children.length > 1) {\n            // remove the comma of the next node\n            let next = parent.children[1];\n            removeEnd = next.offset;\n          }\n        }\n        return withFormatting(text, {\n          offset: removeBegin,\n          length: removeEnd - removeBegin,\n          content: ''\n        }, options);\n      } else {\n        // set value of existing property\n        return withFormatting(text, {\n          offset: existing.offset,\n          length: existing.length,\n          content: JSON.stringify(value)\n        }, options);\n      }\n    } else {\n      if (value === void 0) {\n        // delete\n        return []; // property does not exist, nothing to do\n      }\n\n      const newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;\n      const index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map(p => p.children[0].value)) : parent.children.length;\n      let edit;\n      if (index > 0) {\n        let previous = parent.children[index - 1];\n        edit = {\n          offset: previous.offset + previous.length,\n          length: 0,\n          content: ',' + newProperty\n        };\n      } else if (parent.children.length === 0) {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty\n        };\n      } else {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty + ','\n        };\n      }\n      return withFormatting(text, edit, options);\n    }\n  } else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n    const insertIndex = lastSegment;\n    if (insertIndex === -1) {\n      // Insert\n      const newProperty = `${JSON.stringify(value)}`;\n      let edit;\n      if (parent.children.length === 0) {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty\n        };\n      } else {\n        const previous = parent.children[parent.children.length - 1];\n        edit = {\n          offset: previous.offset + previous.length,\n          length: 0,\n          content: ',' + newProperty\n        };\n      }\n      return withFormatting(text, edit, options);\n    } else if (value === void 0 && parent.children.length >= 0) {\n      // Removal\n      const removalIndex = lastSegment;\n      const toRemove = parent.children[removalIndex];\n      let edit;\n      if (parent.children.length === 1) {\n        // only item\n        edit = {\n          offset: parent.offset + 1,\n          length: parent.length - 2,\n          content: ''\n        };\n      } else if (parent.children.length - 1 === removalIndex) {\n        // last item\n        let previous = parent.children[removalIndex - 1];\n        let offset = previous.offset + previous.length;\n        let parentEndOffset = parent.offset + parent.length;\n        edit = {\n          offset,\n          length: parentEndOffset - 2 - offset,\n          content: ''\n        };\n      } else {\n        edit = {\n          offset: toRemove.offset,\n          length: parent.children[removalIndex + 1].offset - toRemove.offset,\n          content: ''\n        };\n      }\n      return withFormatting(text, edit, options);\n    } else if (value !== void 0) {\n      let edit;\n      const newProperty = `${JSON.stringify(value)}`;\n      if (!options.isArrayInsertion && parent.children.length > lastSegment) {\n        const toModify = parent.children[lastSegment];\n        edit = {\n          offset: toModify.offset,\n          length: toModify.length,\n          content: newProperty\n        };\n      } else if (parent.children.length === 0 || lastSegment === 0) {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: parent.children.length === 0 ? newProperty : newProperty + ','\n        };\n      } else {\n        const index = lastSegment > parent.children.length ? parent.children.length : lastSegment;\n        const previous = parent.children[index - 1];\n        edit = {\n          offset: previous.offset + previous.length,\n          length: 0,\n          content: ',' + newProperty\n        };\n      }\n      return withFormatting(text, edit, options);\n    } else {\n      throw new Error(`Can not ${value === void 0 ? 'remove' : options.isArrayInsertion ? 'insert' : 'modify'} Array index ${insertIndex} as length is not sufficient`);\n    }\n  } else {\n    throw new Error(`Can not add ${typeof lastSegment !== 'number' ? 'index' : 'property'} to parent of type ${parent.type}`);\n  }\n}\nfunction withFormatting(text, edit, options) {\n  if (!options.formattingOptions) {\n    return [edit];\n  }\n  // apply the edit\n  let newText = applyEdit(text, edit);\n  // format the new text\n  let begin = edit.offset;\n  let end = edit.offset + edit.content.length;\n  if (edit.length === 0 || edit.content.length === 0) {\n    // insert or remove\n    while (begin > 0 && !isEOL(newText, begin - 1)) {\n      begin--;\n    }\n    while (end < newText.length && !isEOL(newText, end)) {\n      end++;\n    }\n  }\n  const edits = format(newText, {\n    offset: begin,\n    length: end - begin\n  }, {\n    ...options.formattingOptions,\n    keepLines: false\n  });\n  // apply the formatting edits and track the begin and end offsets of the changes\n  for (let i = edits.length - 1; i >= 0; i--) {\n    const edit = edits[i];\n    newText = applyEdit(newText, edit);\n    begin = Math.min(begin, edit.offset);\n    end = Math.max(end, edit.offset + edit.length);\n    end += edit.content.length - edit.length;\n  }\n  // create a single edit with all changes\n  const editLength = text.length - (newText.length - end) - begin;\n  return [{\n    offset: begin,\n    length: editLength,\n    content: newText.substring(begin, end)\n  }];\n}\nexport function applyEdit(text, edit) {\n  return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nexport function isWS(text, offset) {\n  return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}","map":{"version":3,"names":["format","isEOL","parseTree","findNodeAtLocation","removeProperty","text","path","options","setProperty","originalPath","value","slice","errors","root","parent","lastSegment","length","pop","Error","withFormatting","offset","content","JSON","stringify","type","Array","isArray","children","existing","propertyIndex","indexOf","removeBegin","removeEnd","previous","next","newProperty","index","getInsertionIndex","map","p","edit","insertIndex","removalIndex","toRemove","parentEndOffset","isArrayInsertion","toModify","formattingOptions","newText","applyEdit","begin","end","edits","keepLines","i","Math","min","max","editLength","substring","isWS","charAt"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/jsonc-parser/lib/esm/impl/edit.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport { format, isEOL } from './format';\nimport { parseTree, findNodeAtLocation } from './parser';\nexport function removeProperty(text, path, options) {\n    return setProperty(text, path, void 0, options);\n}\nexport function setProperty(text, originalPath, value, options) {\n    const path = originalPath.slice();\n    const errors = [];\n    const root = parseTree(text, errors);\n    let parent = void 0;\n    let lastSegment = void 0;\n    while (path.length > 0) {\n        lastSegment = path.pop();\n        parent = findNodeAtLocation(root, path);\n        if (parent === void 0 && value !== void 0) {\n            if (typeof lastSegment === 'string') {\n                value = { [lastSegment]: value };\n            }\n            else {\n                value = [value];\n            }\n        }\n        else {\n            break;\n        }\n    }\n    if (!parent) {\n        // empty document\n        if (value === void 0) { // delete\n            throw new Error('Can not delete in empty document');\n        }\n        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options);\n    }\n    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n        const existing = findNodeAtLocation(parent, [lastSegment]);\n        if (existing !== void 0) {\n            if (value === void 0) { // delete\n                if (!existing.parent) {\n                    throw new Error('Malformed AST');\n                }\n                const propertyIndex = parent.children.indexOf(existing.parent);\n                let removeBegin;\n                let removeEnd = existing.parent.offset + existing.parent.length;\n                if (propertyIndex > 0) {\n                    // remove the comma of the previous node\n                    let previous = parent.children[propertyIndex - 1];\n                    removeBegin = previous.offset + previous.length;\n                }\n                else {\n                    removeBegin = parent.offset + 1;\n                    if (parent.children.length > 1) {\n                        // remove the comma of the next node\n                        let next = parent.children[1];\n                        removeEnd = next.offset;\n                    }\n                }\n                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, options);\n            }\n            else {\n                // set value of existing property\n                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options);\n            }\n        }\n        else {\n            if (value === void 0) { // delete\n                return []; // property does not exist, nothing to do\n            }\n            const newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;\n            const index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map(p => p.children[0].value)) : parent.children.length;\n            let edit;\n            if (index > 0) {\n                let previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            else if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };\n            }\n            return withFormatting(text, edit, options);\n        }\n    }\n    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n        const insertIndex = lastSegment;\n        if (insertIndex === -1) {\n            // Insert\n            const newProperty = `${JSON.stringify(value)}`;\n            let edit;\n            if (parent.children.length === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: newProperty };\n            }\n            else {\n                const previous = parent.children[parent.children.length - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else if (value === void 0 && parent.children.length >= 0) {\n            // Removal\n            const removalIndex = lastSegment;\n            const toRemove = parent.children[removalIndex];\n            let edit;\n            if (parent.children.length === 1) {\n                // only item\n                edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };\n            }\n            else if (parent.children.length - 1 === removalIndex) {\n                // last item\n                let previous = parent.children[removalIndex - 1];\n                let offset = previous.offset + previous.length;\n                let parentEndOffset = parent.offset + parent.length;\n                edit = { offset, length: parentEndOffset - 2 - offset, content: '' };\n            }\n            else {\n                edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else if (value !== void 0) {\n            let edit;\n            const newProperty = `${JSON.stringify(value)}`;\n            if (!options.isArrayInsertion && parent.children.length > lastSegment) {\n                const toModify = parent.children[lastSegment];\n                edit = { offset: toModify.offset, length: toModify.length, content: newProperty };\n            }\n            else if (parent.children.length === 0 || lastSegment === 0) {\n                edit = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + ',' };\n            }\n            else {\n                const index = lastSegment > parent.children.length ? parent.children.length : lastSegment;\n                const previous = parent.children[index - 1];\n                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };\n            }\n            return withFormatting(text, edit, options);\n        }\n        else {\n            throw new Error(`Can not ${value === void 0 ? 'remove' : (options.isArrayInsertion ? 'insert' : 'modify')} Array index ${insertIndex} as length is not sufficient`);\n        }\n    }\n    else {\n        throw new Error(`Can not add ${typeof lastSegment !== 'number' ? 'index' : 'property'} to parent of type ${parent.type}`);\n    }\n}\nfunction withFormatting(text, edit, options) {\n    if (!options.formattingOptions) {\n        return [edit];\n    }\n    // apply the edit\n    let newText = applyEdit(text, edit);\n    // format the new text\n    let begin = edit.offset;\n    let end = edit.offset + edit.content.length;\n    if (edit.length === 0 || edit.content.length === 0) { // insert or remove\n        while (begin > 0 && !isEOL(newText, begin - 1)) {\n            begin--;\n        }\n        while (end < newText.length && !isEOL(newText, end)) {\n            end++;\n        }\n    }\n    const edits = format(newText, { offset: begin, length: end - begin }, { ...options.formattingOptions, keepLines: false });\n    // apply the formatting edits and track the begin and end offsets of the changes\n    for (let i = edits.length - 1; i >= 0; i--) {\n        const edit = edits[i];\n        newText = applyEdit(newText, edit);\n        begin = Math.min(begin, edit.offset);\n        end = Math.max(end, edit.offset + edit.length);\n        end += edit.content.length - edit.length;\n    }\n    // create a single edit with all changes\n    const editLength = text.length - (newText.length - end) - begin;\n    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];\n}\nexport function applyEdit(text, edit) {\n    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nexport function isWS(text, offset) {\n    return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}