{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      data,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      opts\n    } = it;\n    const patterns = (0, code_1.allSchemaProperties)(schema);\n    const alwaysValidPatterns = patterns.filter(p => (0, util_1.alwaysValidSchema)(it, schema[p]));\n    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {\n      return;\n    }\n    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n    const valid = gen.name(\"valid\");\n    if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n      it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n    }\n    const {\n      props\n    } = it;\n    validatePatternProperties();\n    function validatePatternProperties() {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat);\n        if (it.allErrors) {\n          validateProperties(pat);\n        } else {\n          gen.var(valid, true); // TODO var\n          validateProperties(pat);\n          gen.if(valid);\n        }\n      }\n    }\n    function checkMatchingProperties(pat) {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n        }\n      }\n    }\n    function validateProperties(pat) {\n      gen.forIn(\"key\", data, key => {\n        gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat);\n          if (!alwaysValid) {\n            cxt.subschema({\n              keyword: \"patternProperties\",\n              schemaProp: pat,\n              dataProp: key,\n              dataPropType: util_2.Type.Str\n            }, valid);\n          }\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign((0, codegen_1._)`${props}[${key}]`, true);\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if((0, codegen_1.not)(valid), () => gen.break());\n          }\n        });\n      });\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["Object","defineProperty","exports","value","code_1","require","codegen_1","util_1","util_2","def","keyword","type","schemaType","code","cxt","gen","schema","data","parentSchema","it","opts","patterns","allSchemaProperties","alwaysValidPatterns","filter","p","alwaysValidSchema","length","unevaluated","props","checkProperties","strictSchema","allowMatchingProperties","properties","valid","name","Name","evaluatedPropsToName","validatePatternProperties","pat","checkMatchingProperties","allErrors","validateProperties","var","if","prop","RegExp","test","checkStrictMode","forIn","key","_","usePattern","alwaysValid","includes","subschema","schemaProp","dataProp","dataPropType","Type","Str","assign","not","break","default"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}