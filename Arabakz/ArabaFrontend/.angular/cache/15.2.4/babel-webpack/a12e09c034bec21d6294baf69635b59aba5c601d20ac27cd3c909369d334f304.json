{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeWorkspace = exports.readWorkspace = exports._test_removeWorkspaceFile = exports._test_addWorkspaceFile = exports.WorkspaceFormat = void 0;\nconst virtual_fs_1 = require(\"../virtual-fs\");\nconst reader_1 = require(\"./json/reader\");\nconst writer_1 = require(\"./json/writer\");\nconst formatLookup = new WeakMap();\n/**\n * Supported workspace formats\n */\nvar WorkspaceFormat;\n(function (WorkspaceFormat) {\n  WorkspaceFormat[WorkspaceFormat[\"JSON\"] = 0] = \"JSON\";\n})(WorkspaceFormat = exports.WorkspaceFormat || (exports.WorkspaceFormat = {}));\n/**\n * @private\n */\nfunction _test_addWorkspaceFile(name, format) {\n  workspaceFiles[name] = format;\n}\nexports._test_addWorkspaceFile = _test_addWorkspaceFile;\n/**\n * @private\n */\nfunction _test_removeWorkspaceFile(name) {\n  delete workspaceFiles[name];\n}\nexports._test_removeWorkspaceFile = _test_removeWorkspaceFile;\n// NOTE: future additions could also perform content analysis to determine format/version\nconst workspaceFiles = {\n  'angular.json': WorkspaceFormat.JSON,\n  '.angular.json': WorkspaceFormat.JSON\n};\n/**\n * Reads and constructs a `WorkspaceDefinition`.  If the function is provided with a path to a\n * directory instead of a file, a search of the directory's files will commence to attempt to\n * locate a known workspace file.  Currently the following are considered known workspace files:\n * - `angular.json`\n * - `.angular.json`\n *\n * @param path The path to either a workspace file or a directory containing a workspace file.\n * @param host The `WorkspaceHost` to use to access the file and directory data.\n * @param format An optional `WorkspaceFormat` value. Used if the path specifies a non-standard\n * file name that would prevent automatically discovering the format.\n *\n *\n * @return An `Promise` of the read result object with the `WorkspaceDefinition` contained within\n * the `workspace` property.\n */\nfunction readWorkspace(_x, _x2, _x3) {\n  return _readWorkspace.apply(this, arguments);\n}\nfunction _readWorkspace() {\n  _readWorkspace = _asyncToGenerator(function* (path, host, format) {\n    if (yield host.isDirectory(path)) {\n      // TODO: Warn if multiple found (requires diagnostics support)\n      const directory = (0, virtual_fs_1.normalize)(path);\n      let found = false;\n      for (const [name, nameFormat] of Object.entries(workspaceFiles)) {\n        if (format !== undefined && format !== nameFormat) {\n          continue;\n        }\n        const potential = (0, virtual_fs_1.getSystemPath)((0, virtual_fs_1.join)(directory, name));\n        if (yield host.isFile(potential)) {\n          path = potential;\n          format = nameFormat;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        throw new Error('Unable to locate a workspace file for workspace path. Are you missing an `angular.json`' + ' or `.angular.json` file?');\n      }\n    } else if (format === undefined) {\n      const filename = (0, virtual_fs_1.basename)((0, virtual_fs_1.normalize)(path));\n      if (filename in workspaceFiles) {\n        format = workspaceFiles[filename];\n      }\n    }\n    if (format === undefined) {\n      throw new Error('Unable to determine format for workspace path.');\n    }\n    let workspace;\n    switch (format) {\n      case WorkspaceFormat.JSON:\n        workspace = yield (0, reader_1.readJsonWorkspace)(path, host);\n        break;\n      default:\n        throw new Error('Unsupported workspace format.');\n    }\n    formatLookup.set(workspace, WorkspaceFormat.JSON);\n    return {\n      workspace\n    };\n  });\n  return _readWorkspace.apply(this, arguments);\n}\nexports.readWorkspace = readWorkspace;\n/**\n * Writes a `WorkspaceDefinition` to the underlying storage via the provided `WorkspaceHost`.\n * If the `WorkspaceDefinition` was created via the `readWorkspace` function, metadata will be\n * used to determine the path and format of the Workspace.  In all other cases, the `path` and\n * `format` options must be specified as they would be otherwise unknown.\n *\n * @param workspace The `WorkspaceDefinition` that will be written.\n * @param host The `WorkspaceHost` to use to access/write the file and directory data.\n * @param path The path to a file location for the output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n * @param format The `WorkspaceFormat` to use for output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n *\n *\n * @return An `Promise` of type `void`.\n */\nfunction writeWorkspace(_x4, _x5, _x6, _x7) {\n  return _writeWorkspace.apply(this, arguments);\n}\nfunction _writeWorkspace() {\n  _writeWorkspace = _asyncToGenerator(function* (workspace, host, path, format) {\n    if (format === undefined) {\n      format = formatLookup.get(workspace);\n      if (format === undefined) {\n        throw new Error('A format is required for custom workspace objects.');\n      }\n    }\n    switch (format) {\n      case WorkspaceFormat.JSON:\n        return (0, writer_1.writeJsonWorkspace)(workspace, host, path);\n      default:\n        throw new Error('Unsupported workspace format.');\n    }\n  });\n  return _writeWorkspace.apply(this, arguments);\n}\nexports.writeWorkspace = writeWorkspace;","map":{"version":3,"names":["Object","defineProperty","exports","value","writeWorkspace","readWorkspace","_test_removeWorkspaceFile","_test_addWorkspaceFile","WorkspaceFormat","virtual_fs_1","require","reader_1","writer_1","formatLookup","WeakMap","name","format","workspaceFiles","JSON","path","host","isDirectory","directory","normalize","found","nameFormat","entries","undefined","potential","getSystemPath","join","isFile","Error","filename","basename","workspace","readJsonWorkspace","set","get","writeJsonWorkspace"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/node_modules/@angular-devkit/core/src/workspace/core.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.writeWorkspace = exports.readWorkspace = exports._test_removeWorkspaceFile = exports._test_addWorkspaceFile = exports.WorkspaceFormat = void 0;\nconst virtual_fs_1 = require(\"../virtual-fs\");\nconst reader_1 = require(\"./json/reader\");\nconst writer_1 = require(\"./json/writer\");\nconst formatLookup = new WeakMap();\n/**\n * Supported workspace formats\n */\nvar WorkspaceFormat;\n(function (WorkspaceFormat) {\n    WorkspaceFormat[WorkspaceFormat[\"JSON\"] = 0] = \"JSON\";\n})(WorkspaceFormat = exports.WorkspaceFormat || (exports.WorkspaceFormat = {}));\n/**\n * @private\n */\nfunction _test_addWorkspaceFile(name, format) {\n    workspaceFiles[name] = format;\n}\nexports._test_addWorkspaceFile = _test_addWorkspaceFile;\n/**\n * @private\n */\nfunction _test_removeWorkspaceFile(name) {\n    delete workspaceFiles[name];\n}\nexports._test_removeWorkspaceFile = _test_removeWorkspaceFile;\n// NOTE: future additions could also perform content analysis to determine format/version\nconst workspaceFiles = {\n    'angular.json': WorkspaceFormat.JSON,\n    '.angular.json': WorkspaceFormat.JSON,\n};\n/**\n * Reads and constructs a `WorkspaceDefinition`.  If the function is provided with a path to a\n * directory instead of a file, a search of the directory's files will commence to attempt to\n * locate a known workspace file.  Currently the following are considered known workspace files:\n * - `angular.json`\n * - `.angular.json`\n *\n * @param path The path to either a workspace file or a directory containing a workspace file.\n * @param host The `WorkspaceHost` to use to access the file and directory data.\n * @param format An optional `WorkspaceFormat` value. Used if the path specifies a non-standard\n * file name that would prevent automatically discovering the format.\n *\n *\n * @return An `Promise` of the read result object with the `WorkspaceDefinition` contained within\n * the `workspace` property.\n */\nasync function readWorkspace(path, host, format) {\n    if (await host.isDirectory(path)) {\n        // TODO: Warn if multiple found (requires diagnostics support)\n        const directory = (0, virtual_fs_1.normalize)(path);\n        let found = false;\n        for (const [name, nameFormat] of Object.entries(workspaceFiles)) {\n            if (format !== undefined && format !== nameFormat) {\n                continue;\n            }\n            const potential = (0, virtual_fs_1.getSystemPath)((0, virtual_fs_1.join)(directory, name));\n            if (await host.isFile(potential)) {\n                path = potential;\n                format = nameFormat;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw new Error('Unable to locate a workspace file for workspace path. Are you missing an `angular.json`' +\n                ' or `.angular.json` file?');\n        }\n    }\n    else if (format === undefined) {\n        const filename = (0, virtual_fs_1.basename)((0, virtual_fs_1.normalize)(path));\n        if (filename in workspaceFiles) {\n            format = workspaceFiles[filename];\n        }\n    }\n    if (format === undefined) {\n        throw new Error('Unable to determine format for workspace path.');\n    }\n    let workspace;\n    switch (format) {\n        case WorkspaceFormat.JSON:\n            workspace = await (0, reader_1.readJsonWorkspace)(path, host);\n            break;\n        default:\n            throw new Error('Unsupported workspace format.');\n    }\n    formatLookup.set(workspace, WorkspaceFormat.JSON);\n    return { workspace };\n}\nexports.readWorkspace = readWorkspace;\n/**\n * Writes a `WorkspaceDefinition` to the underlying storage via the provided `WorkspaceHost`.\n * If the `WorkspaceDefinition` was created via the `readWorkspace` function, metadata will be\n * used to determine the path and format of the Workspace.  In all other cases, the `path` and\n * `format` options must be specified as they would be otherwise unknown.\n *\n * @param workspace The `WorkspaceDefinition` that will be written.\n * @param host The `WorkspaceHost` to use to access/write the file and directory data.\n * @param path The path to a file location for the output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n * @param format The `WorkspaceFormat` to use for output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n *\n *\n * @return An `Promise` of type `void`.\n */\nasync function writeWorkspace(workspace, host, path, format) {\n    if (format === undefined) {\n        format = formatLookup.get(workspace);\n        if (format === undefined) {\n            throw new Error('A format is required for custom workspace objects.');\n        }\n    }\n    switch (format) {\n        case WorkspaceFormat.JSON:\n            return (0, writer_1.writeJsonWorkspace)(workspace, host, path);\n        default:\n            throw new Error('Unsupported workspace format.');\n    }\n}\nexports.writeWorkspace = writeWorkspace;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAOAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,cAAc,GAAGF,OAAO,CAACG,aAAa,GAAGH,OAAO,CAACI,yBAAyB,GAAGJ,OAAO,CAACK,sBAAsB,GAAGL,OAAO,CAACM,eAAe,GAAG,KAAK,CAAC;AACtJ,MAAMC,YAAY,GAAGC,OAAO,CAAC,eAAe,CAAC;AAC7C,MAAMC,QAAQ,GAAGD,OAAO,CAAC,eAAe,CAAC;AACzC,MAAME,QAAQ,GAAGF,OAAO,CAAC,eAAe,CAAC;AACzC,MAAMG,YAAY,GAAG,IAAIC,OAAO,EAAE;AAClC;AACA;AACA;AACA,IAAIN,eAAe;AACnB,CAAC,UAAUA,eAAe,EAAE;EACxBA,eAAe,CAACA,eAAe,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM;AACzD,CAAC,EAAEA,eAAe,GAAGN,OAAO,CAACM,eAAe,KAAKN,OAAO,CAACM,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;AAC/E;AACA;AACA;AACA,SAASD,sBAAsB,CAACQ,IAAI,EAAEC,MAAM,EAAE;EAC1CC,cAAc,CAACF,IAAI,CAAC,GAAGC,MAAM;AACjC;AACAd,OAAO,CAACK,sBAAsB,GAAGA,sBAAsB;AACvD;AACA;AACA;AACA,SAASD,yBAAyB,CAACS,IAAI,EAAE;EACrC,OAAOE,cAAc,CAACF,IAAI,CAAC;AAC/B;AACAb,OAAO,CAACI,yBAAyB,GAAGA,yBAAyB;AAC7D;AACA,MAAMW,cAAc,GAAG;EACnB,cAAc,EAAET,eAAe,CAACU,IAAI;EACpC,eAAe,EAAEV,eAAe,CAACU;AACrC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA,SAgBeb,aAAa;EAAA;AAAA;AAAA;EAAA,mCAA5B,WAA6Bc,IAAI,EAAEC,IAAI,EAAEJ,MAAM,EAAE;IAC7C,UAAUI,IAAI,CAACC,WAAW,CAACF,IAAI,CAAC,EAAE;MAC9B;MACA,MAAMG,SAAS,GAAG,CAAC,CAAC,EAAEb,YAAY,CAACc,SAAS,EAAEJ,IAAI,CAAC;MACnD,IAAIK,KAAK,GAAG,KAAK;MACjB,KAAK,MAAM,CAACT,IAAI,EAAEU,UAAU,CAAC,IAAIzB,MAAM,CAAC0B,OAAO,CAACT,cAAc,CAAC,EAAE;QAC7D,IAAID,MAAM,KAAKW,SAAS,IAAIX,MAAM,KAAKS,UAAU,EAAE;UAC/C;QACJ;QACA,MAAMG,SAAS,GAAG,CAAC,CAAC,EAAEnB,YAAY,CAACoB,aAAa,EAAE,CAAC,CAAC,EAAEpB,YAAY,CAACqB,IAAI,EAAER,SAAS,EAAEP,IAAI,CAAC,CAAC;QAC1F,UAAUK,IAAI,CAACW,MAAM,CAACH,SAAS,CAAC,EAAE;UAC9BT,IAAI,GAAGS,SAAS;UAChBZ,MAAM,GAAGS,UAAU;UACnBD,KAAK,GAAG,IAAI;UACZ;QACJ;MACJ;MACA,IAAI,CAACA,KAAK,EAAE;QACR,MAAM,IAAIQ,KAAK,CAAC,yFAAyF,GACrG,2BAA2B,CAAC;MACpC;IACJ,CAAC,MACI,IAAIhB,MAAM,KAAKW,SAAS,EAAE;MAC3B,MAAMM,QAAQ,GAAG,CAAC,CAAC,EAAExB,YAAY,CAACyB,QAAQ,EAAE,CAAC,CAAC,EAAEzB,YAAY,CAACc,SAAS,EAAEJ,IAAI,CAAC,CAAC;MAC9E,IAAIc,QAAQ,IAAIhB,cAAc,EAAE;QAC5BD,MAAM,GAAGC,cAAc,CAACgB,QAAQ,CAAC;MACrC;IACJ;IACA,IAAIjB,MAAM,KAAKW,SAAS,EAAE;MACtB,MAAM,IAAIK,KAAK,CAAC,gDAAgD,CAAC;IACrE;IACA,IAAIG,SAAS;IACb,QAAQnB,MAAM;MACV,KAAKR,eAAe,CAACU,IAAI;QACrBiB,SAAS,SAAS,CAAC,CAAC,EAAExB,QAAQ,CAACyB,iBAAiB,EAAEjB,IAAI,EAAEC,IAAI,CAAC;QAC7D;MACJ;QACI,MAAM,IAAIY,KAAK,CAAC,+BAA+B,CAAC;IAAC;IAEzDnB,YAAY,CAACwB,GAAG,CAACF,SAAS,EAAE3B,eAAe,CAACU,IAAI,CAAC;IACjD,OAAO;MAAEiB;IAAU,CAAC;EACxB,CAAC;EAAA;AAAA;AACDjC,OAAO,CAACG,aAAa,GAAGA,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA,SAkBeD,cAAc;EAAA;AAAA;AAAA;EAAA,oCAA7B,WAA8B+B,SAAS,EAAEf,IAAI,EAAED,IAAI,EAAEH,MAAM,EAAE;IACzD,IAAIA,MAAM,KAAKW,SAAS,EAAE;MACtBX,MAAM,GAAGH,YAAY,CAACyB,GAAG,CAACH,SAAS,CAAC;MACpC,IAAInB,MAAM,KAAKW,SAAS,EAAE;QACtB,MAAM,IAAIK,KAAK,CAAC,oDAAoD,CAAC;MACzE;IACJ;IACA,QAAQhB,MAAM;MACV,KAAKR,eAAe,CAACU,IAAI;QACrB,OAAO,CAAC,CAAC,EAAEN,QAAQ,CAAC2B,kBAAkB,EAAEJ,SAAS,EAAEf,IAAI,EAAED,IAAI,CAAC;MAClE;QACI,MAAM,IAAIa,KAAK,CAAC,+BAA+B,CAAC;IAAC;EAE7D,CAAC;EAAA;AAAA;AACD9B,OAAO,CAACE,cAAc,GAAGA,cAAc"},"metadata":{},"sourceType":"script","externalDependencies":[]}