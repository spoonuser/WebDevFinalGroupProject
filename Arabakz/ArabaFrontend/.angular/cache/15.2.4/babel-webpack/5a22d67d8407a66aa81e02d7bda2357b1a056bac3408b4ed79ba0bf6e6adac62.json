{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n  message: ({\n    schemaCode\n  }) => (0, codegen_1.str)`must match format \"${schemaCode}\"`,\n  params: ({\n    schemaCode\n  }) => (0, codegen_1._)`{format: ${schemaCode}}`\n};\nconst def = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt, ruleType) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    const {\n      opts,\n      errSchemaPath,\n      schemaEnv,\n      self\n    } = it;\n    if (!opts.validateFormats) return;\n    if ($data) validate$DataFormat();else validateFormat();\n    function validate$DataFormat() {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      const fDef = gen.const(\"fDef\", (0, codegen_1._)`${fmts}[${schemaCode}]`);\n      const fType = gen.let(\"fType\");\n      const format = gen.let(\"format\");\n      // TODO simplify\n      gen.if((0, codegen_1._)`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || \"string\"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`\"string\"`).assign(format, fDef));\n      cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n      function unknownFmt() {\n        if (opts.strictSchema === false) return codegen_1.nil;\n        return (0, codegen_1._)`${schemaCode} && !${format}`;\n      }\n      function invalidFmt() {\n        const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;\n        const validData = (0, codegen_1._)`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n        return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n      }\n    }\n    function validateFormat() {\n      const formatDef = self.formats[schema];\n      if (!formatDef) {\n        unknownFormat();\n        return;\n      }\n      if (formatDef === true) return;\n      const [fmtType, format, fmtRef] = getFormat(formatDef);\n      if (fmtType === ruleType) cxt.pass(validCondition());\n      function unknownFormat() {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg());\n          return;\n        }\n        throw new Error(unknownMsg());\n        function unknownMsg() {\n          return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n        }\n      }\n      function getFormat(fmtDef) {\n        const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : undefined;\n        const fmt = gen.scopeValue(\"formats\", {\n          key: schema,\n          ref: fmtDef,\n          code\n        });\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];\n        }\n        return [\"string\", fmtDef, fmt];\n      }\n      function validCondition() {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\");\n          return (0, codegen_1._)`await ${fmtRef}(${data})`;\n        }\n        return typeof format == \"function\" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;\n      }\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["Object","defineProperty","exports","value","codegen_1","require","error","message","schemaCode","str","params","_","def","keyword","type","schemaType","$data","code","cxt","ruleType","gen","data","schema","it","opts","errSchemaPath","schemaEnv","self","validateFormats","validate$DataFormat","validateFormat","fmts","scopeValue","ref","formats","fDef","const","fType","let","format","if","assign","fail$data","or","unknownFmt","invalidFmt","strictSchema","nil","callFormat","$async","validData","formatDef","unknownFormat","fmtType","fmtRef","getFormat","pass","validCondition","logger","warn","unknownMsg","Error","fmtDef","RegExp","regexpCode","getProperty","undefined","fmt","key","validate","async","default"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/ajv/dist/vocabularies/format/format.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match format \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self } = it;\n        if (!opts.validateFormats)\n            return;\n        if ($data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fDef = gen.const(\"fDef\", (0, codegen_1._) `${fmts}[${schemaCode}]`);\n            const fType = gen.let(\"fType\");\n            const format = gen.let(\"format\");\n            // TODO simplify\n            gen.if((0, codegen_1._) `typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || \"string\"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `\"string\"`).assign(format, fDef));\n            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false)\n                    return codegen_1.nil;\n                return (0, codegen_1._) `${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async\n                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n                    : (0, codegen_1._) `${format}(${data})`;\n                const validData = (0, codegen_1._) `(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true)\n                return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType)\n                cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp\n                    ? (0, codegen_1.regexpCode)(fmtDef)\n                    : opts.code.formats\n                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`\n                        : undefined;\n                const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n                if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n                    return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];\n                }\n                return [\"string\", fmtDef, fmt];\n            }\n            function validCondition() {\n                if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async)\n                        throw new Error(\"async format in sync schema\");\n                    return (0, codegen_1._) `await ${fmtRef}(${data})`;\n                }\n                return typeof format == \"function\" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;\n            }\n        }\n    },\n};\nexports.default = def;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}