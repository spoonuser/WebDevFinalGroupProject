{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.memoize = void 0;\n/**\n * A decorator that memoizes methods and getters.\n *\n * **Note**: Be cautious where and how to use this decorator as the size of the cache will grow unbounded.\n *\n * @see https://en.wikipedia.org/wiki/Memoization\n */\nfunction memoize(target, propertyKey, descriptor) {\n  const descriptorPropertyName = descriptor.get ? 'get' : 'value';\n  const originalMethod = descriptor[descriptorPropertyName];\n  if (typeof originalMethod !== 'function') {\n    throw new Error('Memoize decorator can only be used on methods or get accessors.');\n  }\n  const cache = new Map();\n  return {\n    ...descriptor,\n    [descriptorPropertyName]: function (...args) {\n      for (const arg of args) {\n        if (!isJSONSerializable(arg)) {\n          throw new Error(`Argument ${isNonPrimitive(arg) ? arg.toString() : arg} is JSON serializable.`);\n        }\n      }\n      const key = JSON.stringify(args);\n      if (cache.has(key)) {\n        return cache.get(key);\n      }\n      const result = originalMethod.apply(this, args);\n      cache.set(key, result);\n      return result;\n    }\n  };\n}\nexports.memoize = memoize;\n/** Method to check if value is a non primitive. */\nfunction isNonPrimitive(value) {\n  return value !== null && typeof value === 'object' || typeof value === 'function' || typeof value === 'symbol';\n}\n/** Method to check if the values are JSON serializable */\nfunction isJSONSerializable(value) {\n  if (!isNonPrimitive(value)) {\n    // Can be seralized since it's a primitive.\n    return true;\n  }\n  let nestedValues;\n  if (Array.isArray(value)) {\n    // It's an array, check each item.\n    nestedValues = value;\n  } else if (Object.prototype.toString.call(value) === '[object Object]') {\n    // It's a plain object, check each value.\n    nestedValues = Object.values(value);\n  }\n  if (!nestedValues || nestedValues.some(v => !isJSONSerializable(v))) {\n    return false;\n  }\n  return true;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","memoize","target","propertyKey","descriptor","descriptorPropertyName","get","originalMethod","Error","cache","Map","args","arg","isJSONSerializable","isNonPrimitive","toString","key","JSON","stringify","has","result","apply","set","nestedValues","Array","isArray","prototype","call","values","some","v"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/src/utilities/memoize.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.memoize = void 0;\n/**\n * A decorator that memoizes methods and getters.\n *\n * **Note**: Be cautious where and how to use this decorator as the size of the cache will grow unbounded.\n *\n * @see https://en.wikipedia.org/wiki/Memoization\n */\nfunction memoize(target, propertyKey, descriptor) {\n    const descriptorPropertyName = descriptor.get ? 'get' : 'value';\n    const originalMethod = descriptor[descriptorPropertyName];\n    if (typeof originalMethod !== 'function') {\n        throw new Error('Memoize decorator can only be used on methods or get accessors.');\n    }\n    const cache = new Map();\n    return {\n        ...descriptor,\n        [descriptorPropertyName]: function (...args) {\n            for (const arg of args) {\n                if (!isJSONSerializable(arg)) {\n                    throw new Error(`Argument ${isNonPrimitive(arg) ? arg.toString() : arg} is JSON serializable.`);\n                }\n            }\n            const key = JSON.stringify(args);\n            if (cache.has(key)) {\n                return cache.get(key);\n            }\n            const result = originalMethod.apply(this, args);\n            cache.set(key, result);\n            return result;\n        },\n    };\n}\nexports.memoize = memoize;\n/** Method to check if value is a non primitive. */\nfunction isNonPrimitive(value) {\n    return ((value !== null && typeof value === 'object') ||\n        typeof value === 'function' ||\n        typeof value === 'symbol');\n}\n/** Method to check if the values are JSON serializable */\nfunction isJSONSerializable(value) {\n    if (!isNonPrimitive(value)) {\n        // Can be seralized since it's a primitive.\n        return true;\n    }\n    let nestedValues;\n    if (Array.isArray(value)) {\n        // It's an array, check each item.\n        nestedValues = value;\n    }\n    else if (Object.prototype.toString.call(value) === '[object Object]') {\n        // It's a plain object, check each value.\n        nestedValues = Object.values(value);\n    }\n    if (!nestedValues || nestedValues.some((v) => !isJSONSerializable(v))) {\n        return false;\n    }\n    return true;\n}\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,OAAO,GAAG,KAAK,CAAC;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,OAAO,CAACC,MAAM,EAAEC,WAAW,EAAEC,UAAU,EAAE;EAC9C,MAAMC,sBAAsB,GAAGD,UAAU,CAACE,GAAG,GAAG,KAAK,GAAG,OAAO;EAC/D,MAAMC,cAAc,GAAGH,UAAU,CAACC,sBAAsB,CAAC;EACzD,IAAI,OAAOE,cAAc,KAAK,UAAU,EAAE;IACtC,MAAM,IAAIC,KAAK,CAAC,iEAAiE,CAAC;EACtF;EACA,MAAMC,KAAK,GAAG,IAAIC,GAAG,EAAE;EACvB,OAAO;IACH,GAAGN,UAAU;IACb,CAACC,sBAAsB,GAAG,UAAU,GAAGM,IAAI,EAAE;MACzC,KAAK,MAAMC,GAAG,IAAID,IAAI,EAAE;QACpB,IAAI,CAACE,kBAAkB,CAACD,GAAG,CAAC,EAAE;UAC1B,MAAM,IAAIJ,KAAK,CAAE,YAAWM,cAAc,CAACF,GAAG,CAAC,GAAGA,GAAG,CAACG,QAAQ,EAAE,GAAGH,GAAI,wBAAuB,CAAC;QACnG;MACJ;MACA,MAAMI,GAAG,GAAGC,IAAI,CAACC,SAAS,CAACP,IAAI,CAAC;MAChC,IAAIF,KAAK,CAACU,GAAG,CAACH,GAAG,CAAC,EAAE;QAChB,OAAOP,KAAK,CAACH,GAAG,CAACU,GAAG,CAAC;MACzB;MACA,MAAMI,MAAM,GAAGb,cAAc,CAACc,KAAK,CAAC,IAAI,EAAEV,IAAI,CAAC;MAC/CF,KAAK,CAACa,GAAG,CAACN,GAAG,EAAEI,MAAM,CAAC;MACtB,OAAOA,MAAM;IACjB;EACJ,CAAC;AACL;AACArB,OAAO,CAACE,OAAO,GAAGA,OAAO;AACzB;AACA,SAASa,cAAc,CAACd,KAAK,EAAE;EAC3B,OAASA,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAChD,OAAOA,KAAK,KAAK,UAAU,IAC3B,OAAOA,KAAK,KAAK,QAAQ;AACjC;AACA;AACA,SAASa,kBAAkB,CAACb,KAAK,EAAE;EAC/B,IAAI,CAACc,cAAc,CAACd,KAAK,CAAC,EAAE;IACxB;IACA,OAAO,IAAI;EACf;EACA,IAAIuB,YAAY;EAChB,IAAIC,KAAK,CAACC,OAAO,CAACzB,KAAK,CAAC,EAAE;IACtB;IACAuB,YAAY,GAAGvB,KAAK;EACxB,CAAC,MACI,IAAIH,MAAM,CAAC6B,SAAS,CAACX,QAAQ,CAACY,IAAI,CAAC3B,KAAK,CAAC,KAAK,iBAAiB,EAAE;IAClE;IACAuB,YAAY,GAAG1B,MAAM,CAAC+B,MAAM,CAAC5B,KAAK,CAAC;EACvC;EACA,IAAI,CAACuB,YAAY,IAAIA,YAAY,CAACM,IAAI,CAAEC,CAAC,IAAK,CAACjB,kBAAkB,CAACiB,CAAC,CAAC,CAAC,EAAE;IACnE,OAAO,KAAK;EAChB;EACA,OAAO,IAAI;AACf"},"metadata":{},"sourceType":"script","externalDependencies":[]}