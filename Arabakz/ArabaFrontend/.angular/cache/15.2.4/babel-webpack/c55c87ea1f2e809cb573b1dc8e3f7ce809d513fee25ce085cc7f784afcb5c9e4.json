{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = require(\"./util\");\nconst equal = require(\"fast-deep-equal\");\nconst traverse = require(\"json-schema-traverse\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\"type\", \"format\", \"pattern\", \"maxLength\", \"minLength\", \"maxProperties\", \"minProperties\", \"maxItems\", \"minItems\", \"maximum\", \"minimum\", \"uniqueItems\", \"multipleOf\", \"required\", \"enum\", \"const\"]);\nfunction inlineRef(schema, limit = true) {\n  if (typeof schema == \"boolean\") return true;\n  if (limit === true) return !hasRef(schema);\n  if (!limit) return false;\n  return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\"$ref\", \"$recursiveRef\", \"$recursiveAnchor\", \"$dynamicRef\", \"$dynamicAnchor\"]);\nfunction hasRef(schema) {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true;\n    const sch = schema[key];\n    if (Array.isArray(sch) && sch.some(hasRef)) return true;\n    if (typeof sch == \"object\" && hasRef(sch)) return true;\n  }\n  return false;\n}\nfunction countKeys(schema) {\n  let count = 0;\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity;\n    count++;\n    if (SIMPLE_INLINED.has(key)) continue;\n    if (typeof schema[key] == \"object\") {\n      (0, util_1.eachItem)(schema[key], sch => count += countKeys(sch));\n    }\n    if (count === Infinity) return Infinity;\n  }\n  return count;\n}\nfunction getFullPath(resolver, id = \"\", normalize) {\n  if (normalize !== false) id = normalizeId(id);\n  const p = resolver.parse(id);\n  return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n  const serialized = resolver.serialize(p);\n  return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n  id = normalizeId(id);\n  return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n  if (typeof schema == \"boolean\") return {};\n  const {\n    schemaId,\n    uriResolver\n  } = this.opts;\n  const schId = normalizeId(schema[schemaId] || baseId);\n  const baseIds = {\n    \"\": schId\n  };\n  const pathPrefix = getFullPath(uriResolver, schId, false);\n  const localRefs = {};\n  const schemaRefs = new Set();\n  traverse(schema, {\n    allKeys: true\n  }, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return;\n    const fullPath = pathPrefix + jsonPtr;\n    let baseId = baseIds[parentJsonPtr];\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId]);\n    addAnchor.call(this, sch.$anchor);\n    addAnchor.call(this, sch.$dynamicAnchor);\n    baseIds[jsonPtr] = baseId;\n    function addRef(ref) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve;\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);\n      if (schemaRefs.has(ref)) throw ambiguos(ref);\n      schemaRefs.add(ref);\n      let schOrRef = this.refs[ref];\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef];\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref);\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref);\n          localRefs[ref] = sch;\n        } else {\n          this.refs[ref] = fullPath;\n        }\n      }\n      return ref;\n    }\n    function addAnchor(anchor) {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`);\n        addRef.call(this, `#${anchor}`);\n      }\n    }\n  });\n  return localRefs;\n  function checkAmbiguosRef(sch1, sch2, ref) {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref);\n  }\n  function ambiguos(ref) {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`);\n  }\n}\nexports.getSchemaRefs = getSchemaRefs;","map":{"version":3,"names":["Object","defineProperty","exports","value","getSchemaRefs","resolveUrl","normalizeId","_getFullPath","getFullPath","inlineRef","util_1","require","equal","traverse","SIMPLE_INLINED","Set","schema","limit","hasRef","countKeys","REF_KEYWORDS","key","has","sch","Array","isArray","some","count","Infinity","eachItem","resolver","id","normalize","p","parse","serialized","serialize","split","TRAILING_SLASH_HASH","replace","baseId","resolve","ANCHOR","schemaId","uriResolver","opts","schId","baseIds","pathPrefix","localRefs","schemaRefs","allKeys","jsonPtr","_","parentJsonPtr","undefined","fullPath","addRef","call","addAnchor","$anchor","$dynamicAnchor","ref","_resolve","ambiguos","add","schOrRef","refs","checkAmbiguosRef","anchor","test","Error","sch1","sch2"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/ajv/dist/compile/resolve.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = require(\"./util\");\nconst equal = require(\"fast-deep-equal\");\nconst traverse = require(\"json-schema-traverse\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\",\n]);\nfunction inlineRef(schema, limit = true) {\n    if (typeof schema == \"boolean\")\n        return true;\n    if (limit === true)\n        return !hasRef(schema);\n    if (!limit)\n        return false;\n    return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\n    \"$ref\",\n    \"$recursiveRef\",\n    \"$recursiveAnchor\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n]);\nfunction hasRef(schema) {\n    for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n            return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n            return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n            return true;\n    }\n    return false;\n}\nfunction countKeys(schema) {\n    let count = 0;\n    for (const key in schema) {\n        if (key === \"$ref\")\n            return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n            continue;\n        if (typeof schema[key] == \"object\") {\n            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));\n        }\n        if (count === Infinity)\n            return Infinity;\n    }\n    return count;\n}\nfunction getFullPath(resolver, id = \"\", normalize) {\n    if (normalize !== false)\n        id = normalizeId(id);\n    const p = resolver.parse(id);\n    return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n    id = normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n    if (typeof schema == \"boolean\")\n        return {};\n    const { schemaId, uriResolver } = this.opts;\n    const schId = normalizeId(schema[schemaId] || baseId);\n    const baseIds = { \"\": schId };\n    const pathPrefix = getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === undefined)\n            return;\n        const fullPath = pathPrefix + jsonPtr;\n        let baseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n            baseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = baseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);\n            if (schemaRefs.has(ref))\n                throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == \"string\")\n                schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == \"object\") {\n                checkAmbiguosRef(sch, schOrRef.schema, ref);\n            }\n            else if (ref !== normalizeId(fullPath)) {\n                if (ref[0] === \"#\") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                }\n                else {\n                    this.refs[ref] = fullPath;\n                }\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == \"string\") {\n                if (!ANCHOR.test(anchor))\n                    throw new Error(`invalid anchor \"${anchor}\"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !equal(sch1, sch2))\n            throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n    }\n}\nexports.getSchemaRefs = getSchemaRefs;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,aAAa,GAAGF,OAAO,CAACG,UAAU,GAAGH,OAAO,CAACI,WAAW,GAAGJ,OAAO,CAACK,YAAY,GAAGL,OAAO,CAACM,WAAW,GAAGN,OAAO,CAACO,SAAS,GAAG,KAAK,CAAC;AAC1I,MAAMC,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMC,KAAK,GAAGD,OAAO,CAAC,iBAAiB,CAAC;AACxC,MAAME,QAAQ,GAAGF,OAAO,CAAC,sBAAsB,CAAC;AAChD;AACA,MAAMG,cAAc,GAAG,IAAIC,GAAG,CAAC,CAC3B,MAAM,EACN,QAAQ,EACR,SAAS,EACT,WAAW,EACX,WAAW,EACX,eAAe,EACf,eAAe,EACf,UAAU,EACV,UAAU,EACV,SAAS,EACT,SAAS,EACT,aAAa,EACb,YAAY,EACZ,UAAU,EACV,MAAM,EACN,OAAO,CACV,CAAC;AACF,SAASN,SAAS,CAACO,MAAM,EAAEC,KAAK,GAAG,IAAI,EAAE;EACrC,IAAI,OAAOD,MAAM,IAAI,SAAS,EAC1B,OAAO,IAAI;EACf,IAAIC,KAAK,KAAK,IAAI,EACd,OAAO,CAACC,MAAM,CAACF,MAAM,CAAC;EAC1B,IAAI,CAACC,KAAK,EACN,OAAO,KAAK;EAChB,OAAOE,SAAS,CAACH,MAAM,CAAC,IAAIC,KAAK;AACrC;AACAf,OAAO,CAACO,SAAS,GAAGA,SAAS;AAC7B,MAAMW,YAAY,GAAG,IAAIL,GAAG,CAAC,CACzB,MAAM,EACN,eAAe,EACf,kBAAkB,EAClB,aAAa,EACb,gBAAgB,CACnB,CAAC;AACF,SAASG,MAAM,CAACF,MAAM,EAAE;EACpB,KAAK,MAAMK,GAAG,IAAIL,MAAM,EAAE;IACtB,IAAII,YAAY,CAACE,GAAG,CAACD,GAAG,CAAC,EACrB,OAAO,IAAI;IACf,MAAME,GAAG,GAAGP,MAAM,CAACK,GAAG,CAAC;IACvB,IAAIG,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,IAAIA,GAAG,CAACG,IAAI,CAACR,MAAM,CAAC,EACtC,OAAO,IAAI;IACf,IAAI,OAAOK,GAAG,IAAI,QAAQ,IAAIL,MAAM,CAACK,GAAG,CAAC,EACrC,OAAO,IAAI;EACnB;EACA,OAAO,KAAK;AAChB;AACA,SAASJ,SAAS,CAACH,MAAM,EAAE;EACvB,IAAIW,KAAK,GAAG,CAAC;EACb,KAAK,MAAMN,GAAG,IAAIL,MAAM,EAAE;IACtB,IAAIK,GAAG,KAAK,MAAM,EACd,OAAOO,QAAQ;IACnBD,KAAK,EAAE;IACP,IAAIb,cAAc,CAACQ,GAAG,CAACD,GAAG,CAAC,EACvB;IACJ,IAAI,OAAOL,MAAM,CAACK,GAAG,CAAC,IAAI,QAAQ,EAAE;MAChC,CAAC,CAAC,EAAEX,MAAM,CAACmB,QAAQ,EAAEb,MAAM,CAACK,GAAG,CAAC,EAAGE,GAAG,IAAMI,KAAK,IAAIR,SAAS,CAACI,GAAG,CAAE,CAAC;IACzE;IACA,IAAII,KAAK,KAAKC,QAAQ,EAClB,OAAOA,QAAQ;EACvB;EACA,OAAOD,KAAK;AAChB;AACA,SAASnB,WAAW,CAACsB,QAAQ,EAAEC,EAAE,GAAG,EAAE,EAAEC,SAAS,EAAE;EAC/C,IAAIA,SAAS,KAAK,KAAK,EACnBD,EAAE,GAAGzB,WAAW,CAACyB,EAAE,CAAC;EACxB,MAAME,CAAC,GAAGH,QAAQ,CAACI,KAAK,CAACH,EAAE,CAAC;EAC5B,OAAOxB,YAAY,CAACuB,QAAQ,EAAEG,CAAC,CAAC;AACpC;AACA/B,OAAO,CAACM,WAAW,GAAGA,WAAW;AACjC,SAASD,YAAY,CAACuB,QAAQ,EAAEG,CAAC,EAAE;EAC/B,MAAME,UAAU,GAAGL,QAAQ,CAACM,SAAS,CAACH,CAAC,CAAC;EACxC,OAAOE,UAAU,CAACE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG;AACzC;AACAnC,OAAO,CAACK,YAAY,GAAGA,YAAY;AACnC,MAAM+B,mBAAmB,GAAG,OAAO;AACnC,SAAShC,WAAW,CAACyB,EAAE,EAAE;EACrB,OAAOA,EAAE,GAAGA,EAAE,CAACQ,OAAO,CAACD,mBAAmB,EAAE,EAAE,CAAC,GAAG,EAAE;AACxD;AACApC,OAAO,CAACI,WAAW,GAAGA,WAAW;AACjC,SAASD,UAAU,CAACyB,QAAQ,EAAEU,MAAM,EAAET,EAAE,EAAE;EACtCA,EAAE,GAAGzB,WAAW,CAACyB,EAAE,CAAC;EACpB,OAAOD,QAAQ,CAACW,OAAO,CAACD,MAAM,EAAET,EAAE,CAAC;AACvC;AACA7B,OAAO,CAACG,UAAU,GAAGA,UAAU;AAC/B,MAAMqC,MAAM,GAAG,uBAAuB;AACtC,SAAStC,aAAa,CAACY,MAAM,EAAEwB,MAAM,EAAE;EACnC,IAAI,OAAOxB,MAAM,IAAI,SAAS,EAC1B,OAAO,CAAC,CAAC;EACb,MAAM;IAAE2B,QAAQ;IAAEC;EAAY,CAAC,GAAG,IAAI,CAACC,IAAI;EAC3C,MAAMC,KAAK,GAAGxC,WAAW,CAACU,MAAM,CAAC2B,QAAQ,CAAC,IAAIH,MAAM,CAAC;EACrD,MAAMO,OAAO,GAAG;IAAE,EAAE,EAAED;EAAM,CAAC;EAC7B,MAAME,UAAU,GAAGxC,WAAW,CAACoC,WAAW,EAAEE,KAAK,EAAE,KAAK,CAAC;EACzD,MAAMG,SAAS,GAAG,CAAC,CAAC;EACpB,MAAMC,UAAU,GAAG,IAAInC,GAAG,EAAE;EAC5BF,QAAQ,CAACG,MAAM,EAAE;IAAEmC,OAAO,EAAE;EAAK,CAAC,EAAE,CAAC5B,GAAG,EAAE6B,OAAO,EAAEC,CAAC,EAAEC,aAAa,KAAK;IACpE,IAAIA,aAAa,KAAKC,SAAS,EAC3B;IACJ,MAAMC,QAAQ,GAAGR,UAAU,GAAGI,OAAO;IACrC,IAAIZ,MAAM,GAAGO,OAAO,CAACO,aAAa,CAAC;IACnC,IAAI,OAAO/B,GAAG,CAACoB,QAAQ,CAAC,IAAI,QAAQ,EAChCH,MAAM,GAAGiB,MAAM,CAACC,IAAI,CAAC,IAAI,EAAEnC,GAAG,CAACoB,QAAQ,CAAC,CAAC;IAC7CgB,SAAS,CAACD,IAAI,CAAC,IAAI,EAAEnC,GAAG,CAACqC,OAAO,CAAC;IACjCD,SAAS,CAACD,IAAI,CAAC,IAAI,EAAEnC,GAAG,CAACsC,cAAc,CAAC;IACxCd,OAAO,CAACK,OAAO,CAAC,GAAGZ,MAAM;IACzB,SAASiB,MAAM,CAACK,GAAG,EAAE;MACjB;MACA,MAAMC,QAAQ,GAAG,IAAI,CAAClB,IAAI,CAACD,WAAW,CAACH,OAAO;MAC9CqB,GAAG,GAAGxD,WAAW,CAACkC,MAAM,GAAGuB,QAAQ,CAACvB,MAAM,EAAEsB,GAAG,CAAC,GAAGA,GAAG,CAAC;MACvD,IAAIZ,UAAU,CAAC5B,GAAG,CAACwC,GAAG,CAAC,EACnB,MAAME,QAAQ,CAACF,GAAG,CAAC;MACvBZ,UAAU,CAACe,GAAG,CAACH,GAAG,CAAC;MACnB,IAAII,QAAQ,GAAG,IAAI,CAACC,IAAI,CAACL,GAAG,CAAC;MAC7B,IAAI,OAAOI,QAAQ,IAAI,QAAQ,EAC3BA,QAAQ,GAAG,IAAI,CAACC,IAAI,CAACD,QAAQ,CAAC;MAClC,IAAI,OAAOA,QAAQ,IAAI,QAAQ,EAAE;QAC7BE,gBAAgB,CAAC7C,GAAG,EAAE2C,QAAQ,CAAClD,MAAM,EAAE8C,GAAG,CAAC;MAC/C,CAAC,MACI,IAAIA,GAAG,KAAKxD,WAAW,CAACkD,QAAQ,CAAC,EAAE;QACpC,IAAIM,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;UAChBM,gBAAgB,CAAC7C,GAAG,EAAE0B,SAAS,CAACa,GAAG,CAAC,EAAEA,GAAG,CAAC;UAC1Cb,SAAS,CAACa,GAAG,CAAC,GAAGvC,GAAG;QACxB,CAAC,MACI;UACD,IAAI,CAAC4C,IAAI,CAACL,GAAG,CAAC,GAAGN,QAAQ;QAC7B;MACJ;MACA,OAAOM,GAAG;IACd;IACA,SAASH,SAAS,CAACU,MAAM,EAAE;MACvB,IAAI,OAAOA,MAAM,IAAI,QAAQ,EAAE;QAC3B,IAAI,CAAC3B,MAAM,CAAC4B,IAAI,CAACD,MAAM,CAAC,EACpB,MAAM,IAAIE,KAAK,CAAE,mBAAkBF,MAAO,GAAE,CAAC;QACjDZ,MAAM,CAACC,IAAI,CAAC,IAAI,EAAG,IAAGW,MAAO,EAAC,CAAC;MACnC;IACJ;EACJ,CAAC,CAAC;EACF,OAAOpB,SAAS;EAChB,SAASmB,gBAAgB,CAACI,IAAI,EAAEC,IAAI,EAAEX,GAAG,EAAE;IACvC,IAAIW,IAAI,KAAKlB,SAAS,IAAI,CAAC3C,KAAK,CAAC4D,IAAI,EAAEC,IAAI,CAAC,EACxC,MAAMT,QAAQ,CAACF,GAAG,CAAC;EAC3B;EACA,SAASE,QAAQ,CAACF,GAAG,EAAE;IACnB,OAAO,IAAIS,KAAK,CAAE,cAAaT,GAAI,oCAAmC,CAAC;EAC3E;AACJ;AACA5D,OAAO,CAACE,aAAa,GAAGA,aAAa"},"metadata":{},"sourceType":"script","externalDependencies":[]}