{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleScheduler = exports.JobOutputSchemaValidationError = exports.JobInboundMessageSchemaValidationError = exports.JobArgumentSchemaValidationError = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst api_1 = require(\"./api\");\nconst exception_1 = require(\"./exception\");\nclass JobArgumentSchemaValidationError extends core_1.schema.SchemaValidationException {\n  constructor(errors) {\n    super(errors, 'Job Argument failed to validate. Errors: ');\n  }\n}\nexports.JobArgumentSchemaValidationError = JobArgumentSchemaValidationError;\nclass JobInboundMessageSchemaValidationError extends core_1.schema.SchemaValidationException {\n  constructor(errors) {\n    super(errors, 'Job Inbound Message failed to validate. Errors: ');\n  }\n}\nexports.JobInboundMessageSchemaValidationError = JobInboundMessageSchemaValidationError;\nclass JobOutputSchemaValidationError extends core_1.schema.SchemaValidationException {\n  constructor(errors) {\n    super(errors, 'Job Output failed to validate. Errors: ');\n  }\n}\nexports.JobOutputSchemaValidationError = JobOutputSchemaValidationError;\nfunction _jobShare() {\n  // This is the same code as a `shareReplay()` operator, but uses a dumber Subject rather than a\n  // ReplaySubject.\n  return source => {\n    let refCount = 0;\n    let subject;\n    let hasError = false;\n    let isComplete = false;\n    let subscription;\n    return new rxjs_1.Observable(subscriber => {\n      let innerSub;\n      refCount++;\n      if (!subject) {\n        subject = new rxjs_1.Subject();\n        innerSub = subject.subscribe(subscriber);\n        subscription = source.subscribe({\n          next(value) {\n            subject.next(value);\n          },\n          error(err) {\n            hasError = true;\n            subject.error(err);\n          },\n          complete() {\n            isComplete = true;\n            subject.complete();\n          }\n        });\n      } else {\n        innerSub = subject.subscribe(subscriber);\n      }\n      return () => {\n        refCount--;\n        innerSub.unsubscribe();\n        if (subscription && refCount === 0 && (isComplete || hasError)) {\n          subscription.unsubscribe();\n        }\n      };\n    });\n  };\n}\n/**\n * Simple scheduler. Should be the base of all registries and schedulers.\n */\nclass SimpleScheduler {\n  constructor(_jobRegistry, _schemaRegistry = new core_1.schema.CoreSchemaRegistry()) {\n    this._jobRegistry = _jobRegistry;\n    this._schemaRegistry = _schemaRegistry;\n    this._internalJobDescriptionMap = new Map();\n    this._queue = [];\n    this._pauseCounter = 0;\n  }\n  _getInternalDescription(name) {\n    const maybeHandler = this._internalJobDescriptionMap.get(name);\n    if (maybeHandler !== undefined) {\n      return (0, rxjs_1.of)(maybeHandler);\n    }\n    const handler = this._jobRegistry.get(name);\n    return handler.pipe((0, operators_1.switchMap)(handler => {\n      if (handler === null) {\n        return (0, rxjs_1.of)(null);\n      }\n      const description = {\n        // Make a copy of it to be sure it's proper JSON.\n        ...JSON.parse(JSON.stringify(handler.jobDescription)),\n        name: handler.jobDescription.name || name,\n        argument: handler.jobDescription.argument || true,\n        input: handler.jobDescription.input || true,\n        output: handler.jobDescription.output || true,\n        channels: handler.jobDescription.channels || {}\n      };\n      const handlerWithExtra = Object.assign(handler.bind(undefined), {\n        jobDescription: description,\n        argumentV: this._schemaRegistry.compile(description.argument).pipe((0, operators_1.shareReplay)(1)),\n        inputV: this._schemaRegistry.compile(description.input).pipe((0, operators_1.shareReplay)(1)),\n        outputV: this._schemaRegistry.compile(description.output).pipe((0, operators_1.shareReplay)(1))\n      });\n      this._internalJobDescriptionMap.set(name, handlerWithExtra);\n      return (0, rxjs_1.of)(handlerWithExtra);\n    }));\n  }\n  /**\n   * Get a job description for a named job.\n   *\n   * @param name The name of the job.\n   * @returns A description, or null if the job is not registered.\n   */\n  getDescription(name) {\n    return (0, rxjs_1.concat)(this._getInternalDescription(name).pipe((0, operators_1.map)(x => x && x.jobDescription)), (0, rxjs_1.of)(null)).pipe((0, operators_1.first)());\n  }\n  /**\n   * Returns true if the job name has been registered.\n   * @param name The name of the job.\n   * @returns True if the job exists, false otherwise.\n   */\n  has(name) {\n    return this.getDescription(name).pipe((0, operators_1.map)(x => x !== null));\n  }\n  /**\n   * Pause the scheduler, temporary queueing _new_ jobs. Returns a resume function that should be\n   * used to resume execution. If multiple `pause()` were called, all their resume functions must\n   * be called before the Scheduler actually starts new jobs. Additional calls to the same resume\n   * function will have no effect.\n   *\n   * Jobs already running are NOT paused. This is pausing the scheduler only.\n   */\n  pause() {\n    let called = false;\n    this._pauseCounter++;\n    return () => {\n      if (!called) {\n        called = true;\n        if (--this._pauseCounter == 0) {\n          // Resume the queue.\n          const q = this._queue;\n          this._queue = [];\n          q.forEach(fn => fn());\n        }\n      }\n    };\n  }\n  /**\n   * Schedule a job to be run, using its name.\n   * @param name The name of job to be run.\n   * @param argument The argument to send to the job when starting it.\n   * @param options Scheduling options.\n   * @returns The Job being run.\n   */\n  schedule(name, argument, options) {\n    if (this._pauseCounter > 0) {\n      const waitable = new rxjs_1.Subject();\n      this._queue.push(() => waitable.complete());\n      return this._scheduleJob(name, argument, options || {}, waitable);\n    }\n    return this._scheduleJob(name, argument, options || {}, rxjs_1.EMPTY);\n  }\n  /**\n   * Filter messages.\n   * @private\n   */\n  _filterJobOutboundMessages(message, state) {\n    switch (message.kind) {\n      case api_1.JobOutboundMessageKind.OnReady:\n        return state == api_1.JobState.Queued;\n      case api_1.JobOutboundMessageKind.Start:\n        return state == api_1.JobState.Ready;\n      case api_1.JobOutboundMessageKind.End:\n        return state == api_1.JobState.Started || state == api_1.JobState.Ready;\n    }\n    return true;\n  }\n  /**\n   * Return a new state. This is just to simplify the reading of the _createJob method.\n   * @private\n   */\n  _updateState(message, state) {\n    switch (message.kind) {\n      case api_1.JobOutboundMessageKind.OnReady:\n        return api_1.JobState.Ready;\n      case api_1.JobOutboundMessageKind.Start:\n        return api_1.JobState.Started;\n      case api_1.JobOutboundMessageKind.End:\n        return api_1.JobState.Ended;\n    }\n    return state;\n  }\n  /**\n   * Create the job.\n   * @private\n   */\n  _createJob(name, argument, handler, inboundBus, outboundBus) {\n    const schemaRegistry = this._schemaRegistry;\n    const channelsSubject = new Map();\n    const channels = new Map();\n    let state = api_1.JobState.Queued;\n    let pingId = 0;\n    // Create the input channel by having a filter.\n    const input = new rxjs_1.Subject();\n    input.pipe((0, operators_1.concatMap)(message => handler.pipe((0, operators_1.switchMap)(handler => {\n      if (handler === null) {\n        throw new exception_1.JobDoesNotExistException(name);\n      } else {\n        return handler.inputV.pipe((0, operators_1.switchMap)(validate => validate(message)));\n      }\n    }))), (0, operators_1.filter)(result => result.success), (0, operators_1.map)(result => result.data)).subscribe(value => inboundBus.next({\n      kind: api_1.JobInboundMessageKind.Input,\n      value\n    }));\n    outboundBus = (0, rxjs_1.concat)(outboundBus,\n    // Add an End message at completion. This will be filtered out if the job actually send an\n    // End.\n    handler.pipe((0, operators_1.switchMap)(handler => {\n      if (handler) {\n        return (0, rxjs_1.of)({\n          kind: api_1.JobOutboundMessageKind.End,\n          description: handler.jobDescription\n        });\n      } else {\n        return rxjs_1.EMPTY;\n      }\n    }))).pipe((0, operators_1.filter)(message => this._filterJobOutboundMessages(message, state)),\n    // Update internal logic and Job<> members.\n    (0, operators_1.tap)(message => {\n      // Update the state.\n      state = this._updateState(message, state);\n      switch (message.kind) {\n        case api_1.JobOutboundMessageKind.ChannelCreate:\n          {\n            const maybeSubject = channelsSubject.get(message.name);\n            // If it doesn't exist or it's closed on the other end.\n            if (!maybeSubject) {\n              const s = new rxjs_1.Subject();\n              channelsSubject.set(message.name, s);\n              channels.set(message.name, s.asObservable());\n            }\n            break;\n          }\n        case api_1.JobOutboundMessageKind.ChannelMessage:\n          {\n            const maybeSubject = channelsSubject.get(message.name);\n            if (maybeSubject) {\n              maybeSubject.next(message.message);\n            }\n            break;\n          }\n        case api_1.JobOutboundMessageKind.ChannelComplete:\n          {\n            const maybeSubject = channelsSubject.get(message.name);\n            if (maybeSubject) {\n              maybeSubject.complete();\n              channelsSubject.delete(message.name);\n            }\n            break;\n          }\n        case api_1.JobOutboundMessageKind.ChannelError:\n          {\n            const maybeSubject = channelsSubject.get(message.name);\n            if (maybeSubject) {\n              maybeSubject.error(message.error);\n              channelsSubject.delete(message.name);\n            }\n            break;\n          }\n      }\n    }, () => {\n      state = api_1.JobState.Errored;\n    }),\n    // Do output validation (might include default values so this might have side\n    // effects). We keep all messages in order.\n    (0, operators_1.concatMap)(message => {\n      if (message.kind !== api_1.JobOutboundMessageKind.Output) {\n        return (0, rxjs_1.of)(message);\n      }\n      return handler.pipe((0, operators_1.switchMap)(handler => {\n        if (handler === null) {\n          throw new exception_1.JobDoesNotExistException(name);\n        } else {\n          return handler.outputV.pipe((0, operators_1.switchMap)(validate => validate(message.value)), (0, operators_1.switchMap)(output => {\n            if (!output.success) {\n              throw new JobOutputSchemaValidationError(output.errors);\n            }\n            return (0, rxjs_1.of)({\n              ...message,\n              output: output.data\n            });\n          }));\n        }\n      }));\n    }), _jobShare());\n    const output = outboundBus.pipe((0, operators_1.filter)(x => x.kind == api_1.JobOutboundMessageKind.Output), (0, operators_1.map)(x => x.value), (0, operators_1.shareReplay)(1));\n    // Return the Job.\n    return {\n      get state() {\n        return state;\n      },\n      argument,\n      description: handler.pipe((0, operators_1.switchMap)(handler => {\n        if (handler === null) {\n          throw new exception_1.JobDoesNotExistException(name);\n        } else {\n          return (0, rxjs_1.of)(handler.jobDescription);\n        }\n      })),\n      output,\n      getChannel(name, schema = true) {\n        let maybeObservable = channels.get(name);\n        if (!maybeObservable) {\n          const s = new rxjs_1.Subject();\n          channelsSubject.set(name, s);\n          channels.set(name, s.asObservable());\n          maybeObservable = s.asObservable();\n        }\n        return maybeObservable.pipe(\n        // Keep the order of messages.\n        (0, operators_1.concatMap)(message => {\n          return schemaRegistry.compile(schema).pipe((0, operators_1.switchMap)(validate => validate(message)), (0, operators_1.filter)(x => x.success), (0, operators_1.map)(x => x.data));\n        }));\n      },\n      ping() {\n        const id = pingId++;\n        inboundBus.next({\n          kind: api_1.JobInboundMessageKind.Ping,\n          id\n        });\n        return outboundBus.pipe((0, operators_1.filter)(x => x.kind === api_1.JobOutboundMessageKind.Pong && x.id == id), (0, operators_1.first)(), (0, operators_1.ignoreElements)());\n      },\n      stop() {\n        inboundBus.next({\n          kind: api_1.JobInboundMessageKind.Stop\n        });\n      },\n      input,\n      inboundBus,\n      outboundBus\n    };\n  }\n  _scheduleJob(name, argument, options, waitable) {\n    // Get handler first, since this can error out if there's no handler for the job name.\n    const handler = this._getInternalDescription(name);\n    const optionsDeps = options && options.dependencies || [];\n    const dependencies = Array.isArray(optionsDeps) ? optionsDeps : [optionsDeps];\n    const inboundBus = new rxjs_1.Subject();\n    const outboundBus = (0, rxjs_1.concat)(\n    // Wait for dependencies, make sure to not report messages from dependencies. Subscribe to\n    // all dependencies at the same time so they run concurrently.\n    (0, rxjs_1.merge)(...dependencies.map(x => x.outboundBus)).pipe((0, operators_1.ignoreElements)()),\n    // Wait for pause() to clear (if necessary).\n    waitable, (0, rxjs_1.from)(handler).pipe((0, operators_1.switchMap)(handler => new rxjs_1.Observable(subscriber => {\n      if (!handler) {\n        throw new exception_1.JobDoesNotExistException(name);\n      }\n      // Validate the argument.\n      return handler.argumentV.pipe((0, operators_1.switchMap)(validate => validate(argument)), (0, operators_1.switchMap)(output => {\n        if (!output.success) {\n          throw new JobArgumentSchemaValidationError(output.errors);\n        }\n        const argument = output.data;\n        const description = handler.jobDescription;\n        subscriber.next({\n          kind: api_1.JobOutboundMessageKind.OnReady,\n          description\n        });\n        const context = {\n          description,\n          dependencies: [...dependencies],\n          inboundBus: inboundBus.asObservable(),\n          scheduler: this\n        };\n        return handler(argument, context);\n      })).subscribe(subscriber);\n    }))));\n    return this._createJob(name, argument, handler, inboundBus, outboundBus);\n  }\n}\nexports.SimpleScheduler = SimpleScheduler;","map":{"version":3,"names":["Object","defineProperty","exports","value","SimpleScheduler","JobOutputSchemaValidationError","JobInboundMessageSchemaValidationError","JobArgumentSchemaValidationError","core_1","require","rxjs_1","operators_1","api_1","exception_1","schema","SchemaValidationException","constructor","errors","_jobShare","source","refCount","subject","hasError","isComplete","subscription","Observable","subscriber","innerSub","Subject","subscribe","next","error","err","complete","unsubscribe","_jobRegistry","_schemaRegistry","CoreSchemaRegistry","_internalJobDescriptionMap","Map","_queue","_pauseCounter","_getInternalDescription","name","maybeHandler","get","undefined","of","handler","pipe","switchMap","description","JSON","parse","stringify","jobDescription","argument","input","output","channels","handlerWithExtra","assign","bind","argumentV","compile","shareReplay","inputV","outputV","set","getDescription","concat","map","x","first","has","pause","called","q","forEach","fn","schedule","options","waitable","push","_scheduleJob","EMPTY","_filterJobOutboundMessages","message","state","kind","JobOutboundMessageKind","OnReady","JobState","Queued","Start","Ready","End","Started","_updateState","Ended","_createJob","inboundBus","outboundBus","schemaRegistry","channelsSubject","pingId","concatMap","JobDoesNotExistException","validate","filter","result","success","data","JobInboundMessageKind","Input","tap","ChannelCreate","maybeSubject","s","asObservable","ChannelMessage","ChannelComplete","delete","ChannelError","Errored","Output","getChannel","maybeObservable","ping","id","Ping","Pong","ignoreElements","stop","Stop","optionsDeps","dependencies","Array","isArray","merge","from","context","scheduler"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/node_modules/@angular-devkit/architect/src/jobs/simple-scheduler.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleScheduler = exports.JobOutputSchemaValidationError = exports.JobInboundMessageSchemaValidationError = exports.JobArgumentSchemaValidationError = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst api_1 = require(\"./api\");\nconst exception_1 = require(\"./exception\");\nclass JobArgumentSchemaValidationError extends core_1.schema.SchemaValidationException {\n    constructor(errors) {\n        super(errors, 'Job Argument failed to validate. Errors: ');\n    }\n}\nexports.JobArgumentSchemaValidationError = JobArgumentSchemaValidationError;\nclass JobInboundMessageSchemaValidationError extends core_1.schema.SchemaValidationException {\n    constructor(errors) {\n        super(errors, 'Job Inbound Message failed to validate. Errors: ');\n    }\n}\nexports.JobInboundMessageSchemaValidationError = JobInboundMessageSchemaValidationError;\nclass JobOutputSchemaValidationError extends core_1.schema.SchemaValidationException {\n    constructor(errors) {\n        super(errors, 'Job Output failed to validate. Errors: ');\n    }\n}\nexports.JobOutputSchemaValidationError = JobOutputSchemaValidationError;\nfunction _jobShare() {\n    // This is the same code as a `shareReplay()` operator, but uses a dumber Subject rather than a\n    // ReplaySubject.\n    return (source) => {\n        let refCount = 0;\n        let subject;\n        let hasError = false;\n        let isComplete = false;\n        let subscription;\n        return new rxjs_1.Observable((subscriber) => {\n            let innerSub;\n            refCount++;\n            if (!subject) {\n                subject = new rxjs_1.Subject();\n                innerSub = subject.subscribe(subscriber);\n                subscription = source.subscribe({\n                    next(value) {\n                        subject.next(value);\n                    },\n                    error(err) {\n                        hasError = true;\n                        subject.error(err);\n                    },\n                    complete() {\n                        isComplete = true;\n                        subject.complete();\n                    },\n                });\n            }\n            else {\n                innerSub = subject.subscribe(subscriber);\n            }\n            return () => {\n                refCount--;\n                innerSub.unsubscribe();\n                if (subscription && refCount === 0 && (isComplete || hasError)) {\n                    subscription.unsubscribe();\n                }\n            };\n        });\n    };\n}\n/**\n * Simple scheduler. Should be the base of all registries and schedulers.\n */\nclass SimpleScheduler {\n    constructor(_jobRegistry, _schemaRegistry = new core_1.schema.CoreSchemaRegistry()) {\n        this._jobRegistry = _jobRegistry;\n        this._schemaRegistry = _schemaRegistry;\n        this._internalJobDescriptionMap = new Map();\n        this._queue = [];\n        this._pauseCounter = 0;\n    }\n    _getInternalDescription(name) {\n        const maybeHandler = this._internalJobDescriptionMap.get(name);\n        if (maybeHandler !== undefined) {\n            return (0, rxjs_1.of)(maybeHandler);\n        }\n        const handler = this._jobRegistry.get(name);\n        return handler.pipe((0, operators_1.switchMap)((handler) => {\n            if (handler === null) {\n                return (0, rxjs_1.of)(null);\n            }\n            const description = {\n                // Make a copy of it to be sure it's proper JSON.\n                ...JSON.parse(JSON.stringify(handler.jobDescription)),\n                name: handler.jobDescription.name || name,\n                argument: handler.jobDescription.argument || true,\n                input: handler.jobDescription.input || true,\n                output: handler.jobDescription.output || true,\n                channels: handler.jobDescription.channels || {},\n            };\n            const handlerWithExtra = Object.assign(handler.bind(undefined), {\n                jobDescription: description,\n                argumentV: this._schemaRegistry.compile(description.argument).pipe((0, operators_1.shareReplay)(1)),\n                inputV: this._schemaRegistry.compile(description.input).pipe((0, operators_1.shareReplay)(1)),\n                outputV: this._schemaRegistry.compile(description.output).pipe((0, operators_1.shareReplay)(1)),\n            });\n            this._internalJobDescriptionMap.set(name, handlerWithExtra);\n            return (0, rxjs_1.of)(handlerWithExtra);\n        }));\n    }\n    /**\n     * Get a job description for a named job.\n     *\n     * @param name The name of the job.\n     * @returns A description, or null if the job is not registered.\n     */\n    getDescription(name) {\n        return (0, rxjs_1.concat)(this._getInternalDescription(name).pipe((0, operators_1.map)((x) => x && x.jobDescription)), (0, rxjs_1.of)(null)).pipe((0, operators_1.first)());\n    }\n    /**\n     * Returns true if the job name has been registered.\n     * @param name The name of the job.\n     * @returns True if the job exists, false otherwise.\n     */\n    has(name) {\n        return this.getDescription(name).pipe((0, operators_1.map)((x) => x !== null));\n    }\n    /**\n     * Pause the scheduler, temporary queueing _new_ jobs. Returns a resume function that should be\n     * used to resume execution. If multiple `pause()` were called, all their resume functions must\n     * be called before the Scheduler actually starts new jobs. Additional calls to the same resume\n     * function will have no effect.\n     *\n     * Jobs already running are NOT paused. This is pausing the scheduler only.\n     */\n    pause() {\n        let called = false;\n        this._pauseCounter++;\n        return () => {\n            if (!called) {\n                called = true;\n                if (--this._pauseCounter == 0) {\n                    // Resume the queue.\n                    const q = this._queue;\n                    this._queue = [];\n                    q.forEach((fn) => fn());\n                }\n            }\n        };\n    }\n    /**\n     * Schedule a job to be run, using its name.\n     * @param name The name of job to be run.\n     * @param argument The argument to send to the job when starting it.\n     * @param options Scheduling options.\n     * @returns The Job being run.\n     */\n    schedule(name, argument, options) {\n        if (this._pauseCounter > 0) {\n            const waitable = new rxjs_1.Subject();\n            this._queue.push(() => waitable.complete());\n            return this._scheduleJob(name, argument, options || {}, waitable);\n        }\n        return this._scheduleJob(name, argument, options || {}, rxjs_1.EMPTY);\n    }\n    /**\n     * Filter messages.\n     * @private\n     */\n    _filterJobOutboundMessages(message, state) {\n        switch (message.kind) {\n            case api_1.JobOutboundMessageKind.OnReady:\n                return state == api_1.JobState.Queued;\n            case api_1.JobOutboundMessageKind.Start:\n                return state == api_1.JobState.Ready;\n            case api_1.JobOutboundMessageKind.End:\n                return state == api_1.JobState.Started || state == api_1.JobState.Ready;\n        }\n        return true;\n    }\n    /**\n     * Return a new state. This is just to simplify the reading of the _createJob method.\n     * @private\n     */\n    _updateState(message, state) {\n        switch (message.kind) {\n            case api_1.JobOutboundMessageKind.OnReady:\n                return api_1.JobState.Ready;\n            case api_1.JobOutboundMessageKind.Start:\n                return api_1.JobState.Started;\n            case api_1.JobOutboundMessageKind.End:\n                return api_1.JobState.Ended;\n        }\n        return state;\n    }\n    /**\n     * Create the job.\n     * @private\n     */\n    _createJob(name, argument, handler, inboundBus, outboundBus) {\n        const schemaRegistry = this._schemaRegistry;\n        const channelsSubject = new Map();\n        const channels = new Map();\n        let state = api_1.JobState.Queued;\n        let pingId = 0;\n        // Create the input channel by having a filter.\n        const input = new rxjs_1.Subject();\n        input\n            .pipe((0, operators_1.concatMap)((message) => handler.pipe((0, operators_1.switchMap)((handler) => {\n            if (handler === null) {\n                throw new exception_1.JobDoesNotExistException(name);\n            }\n            else {\n                return handler.inputV.pipe((0, operators_1.switchMap)((validate) => validate(message)));\n            }\n        }))), (0, operators_1.filter)((result) => result.success), (0, operators_1.map)((result) => result.data))\n            .subscribe((value) => inboundBus.next({ kind: api_1.JobInboundMessageKind.Input, value }));\n        outboundBus = (0, rxjs_1.concat)(outboundBus, \n        // Add an End message at completion. This will be filtered out if the job actually send an\n        // End.\n        handler.pipe((0, operators_1.switchMap)((handler) => {\n            if (handler) {\n                return (0, rxjs_1.of)({\n                    kind: api_1.JobOutboundMessageKind.End,\n                    description: handler.jobDescription,\n                });\n            }\n            else {\n                return rxjs_1.EMPTY;\n            }\n        }))).pipe((0, operators_1.filter)((message) => this._filterJobOutboundMessages(message, state)), \n        // Update internal logic and Job<> members.\n        (0, operators_1.tap)((message) => {\n            // Update the state.\n            state = this._updateState(message, state);\n            switch (message.kind) {\n                case api_1.JobOutboundMessageKind.ChannelCreate: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    // If it doesn't exist or it's closed on the other end.\n                    if (!maybeSubject) {\n                        const s = new rxjs_1.Subject();\n                        channelsSubject.set(message.name, s);\n                        channels.set(message.name, s.asObservable());\n                    }\n                    break;\n                }\n                case api_1.JobOutboundMessageKind.ChannelMessage: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    if (maybeSubject) {\n                        maybeSubject.next(message.message);\n                    }\n                    break;\n                }\n                case api_1.JobOutboundMessageKind.ChannelComplete: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    if (maybeSubject) {\n                        maybeSubject.complete();\n                        channelsSubject.delete(message.name);\n                    }\n                    break;\n                }\n                case api_1.JobOutboundMessageKind.ChannelError: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    if (maybeSubject) {\n                        maybeSubject.error(message.error);\n                        channelsSubject.delete(message.name);\n                    }\n                    break;\n                }\n            }\n        }, () => {\n            state = api_1.JobState.Errored;\n        }), \n        // Do output validation (might include default values so this might have side\n        // effects). We keep all messages in order.\n        (0, operators_1.concatMap)((message) => {\n            if (message.kind !== api_1.JobOutboundMessageKind.Output) {\n                return (0, rxjs_1.of)(message);\n            }\n            return handler.pipe((0, operators_1.switchMap)((handler) => {\n                if (handler === null) {\n                    throw new exception_1.JobDoesNotExistException(name);\n                }\n                else {\n                    return handler.outputV.pipe((0, operators_1.switchMap)((validate) => validate(message.value)), (0, operators_1.switchMap)((output) => {\n                        if (!output.success) {\n                            throw new JobOutputSchemaValidationError(output.errors);\n                        }\n                        return (0, rxjs_1.of)({\n                            ...message,\n                            output: output.data,\n                        });\n                    }));\n                }\n            }));\n        }), _jobShare());\n        const output = outboundBus.pipe((0, operators_1.filter)((x) => x.kind == api_1.JobOutboundMessageKind.Output), (0, operators_1.map)((x) => x.value), (0, operators_1.shareReplay)(1));\n        // Return the Job.\n        return {\n            get state() {\n                return state;\n            },\n            argument,\n            description: handler.pipe((0, operators_1.switchMap)((handler) => {\n                if (handler === null) {\n                    throw new exception_1.JobDoesNotExistException(name);\n                }\n                else {\n                    return (0, rxjs_1.of)(handler.jobDescription);\n                }\n            })),\n            output,\n            getChannel(name, schema = true) {\n                let maybeObservable = channels.get(name);\n                if (!maybeObservable) {\n                    const s = new rxjs_1.Subject();\n                    channelsSubject.set(name, s);\n                    channels.set(name, s.asObservable());\n                    maybeObservable = s.asObservable();\n                }\n                return maybeObservable.pipe(\n                // Keep the order of messages.\n                (0, operators_1.concatMap)((message) => {\n                    return schemaRegistry.compile(schema).pipe((0, operators_1.switchMap)((validate) => validate(message)), (0, operators_1.filter)((x) => x.success), (0, operators_1.map)((x) => x.data));\n                }));\n            },\n            ping() {\n                const id = pingId++;\n                inboundBus.next({ kind: api_1.JobInboundMessageKind.Ping, id });\n                return outboundBus.pipe((0, operators_1.filter)((x) => x.kind === api_1.JobOutboundMessageKind.Pong && x.id == id), (0, operators_1.first)(), (0, operators_1.ignoreElements)());\n            },\n            stop() {\n                inboundBus.next({ kind: api_1.JobInboundMessageKind.Stop });\n            },\n            input,\n            inboundBus,\n            outboundBus,\n        };\n    }\n    _scheduleJob(name, argument, options, waitable) {\n        // Get handler first, since this can error out if there's no handler for the job name.\n        const handler = this._getInternalDescription(name);\n        const optionsDeps = (options && options.dependencies) || [];\n        const dependencies = Array.isArray(optionsDeps) ? optionsDeps : [optionsDeps];\n        const inboundBus = new rxjs_1.Subject();\n        const outboundBus = (0, rxjs_1.concat)(\n        // Wait for dependencies, make sure to not report messages from dependencies. Subscribe to\n        // all dependencies at the same time so they run concurrently.\n        (0, rxjs_1.merge)(...dependencies.map((x) => x.outboundBus)).pipe((0, operators_1.ignoreElements)()), \n        // Wait for pause() to clear (if necessary).\n        waitable, (0, rxjs_1.from)(handler).pipe((0, operators_1.switchMap)((handler) => new rxjs_1.Observable((subscriber) => {\n            if (!handler) {\n                throw new exception_1.JobDoesNotExistException(name);\n            }\n            // Validate the argument.\n            return handler.argumentV\n                .pipe((0, operators_1.switchMap)((validate) => validate(argument)), (0, operators_1.switchMap)((output) => {\n                if (!output.success) {\n                    throw new JobArgumentSchemaValidationError(output.errors);\n                }\n                const argument = output.data;\n                const description = handler.jobDescription;\n                subscriber.next({ kind: api_1.JobOutboundMessageKind.OnReady, description });\n                const context = {\n                    description,\n                    dependencies: [...dependencies],\n                    inboundBus: inboundBus.asObservable(),\n                    scheduler: this,\n                };\n                return handler(argument, context);\n            }))\n                .subscribe(subscriber);\n        }))));\n        return this._createJob(name, argument, handler, inboundBus, outboundBus);\n    }\n}\nexports.SimpleScheduler = SimpleScheduler;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}