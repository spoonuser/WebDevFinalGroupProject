{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseJsonSchemaToOptions = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nfunction parseJsonSchemaToOptions(_x, _x2) {\n  return _parseJsonSchemaToOptions.apply(this, arguments);\n}\nfunction _parseJsonSchemaToOptions() {\n  _parseJsonSchemaToOptions = _asyncToGenerator(function* (registry, schema, interactive = true) {\n    const options = [];\n    function visitor(current, pointer, parentSchema) {\n      if (!parentSchema) {\n        // Ignore root.\n        return;\n      } else if (pointer.split(/\\/(?:properties|items|definitions)\\//g).length > 2) {\n        // Ignore subitems (objects or arrays).\n        return;\n      } else if (core_1.json.isJsonArray(current)) {\n        return;\n      }\n      if (pointer.indexOf('/not/') != -1) {\n        // We don't support anyOf/not.\n        throw new Error('The \"not\" keyword is not supported in JSON Schema.');\n      }\n      const ptr = core_1.json.schema.parseJsonPointer(pointer);\n      const name = ptr[ptr.length - 1];\n      if (ptr[ptr.length - 2] != 'properties') {\n        // Skip any non-property items.\n        return;\n      }\n      const typeSet = core_1.json.schema.getTypesOfSchema(current);\n      if (typeSet.size == 0) {\n        throw new Error('Cannot find type of schema.');\n      }\n      // We only support number, string or boolean (or array of those), so remove everything else.\n      const types = [...typeSet].filter(x => {\n        switch (x) {\n          case 'boolean':\n          case 'number':\n          case 'string':\n            return true;\n          case 'array':\n            // Only include arrays if they're boolean, string or number.\n            if (core_1.json.isJsonObject(current.items) && typeof current.items.type == 'string' && ['boolean', 'number', 'string'].includes(current.items.type)) {\n              return true;\n            }\n            return false;\n          default:\n            return false;\n        }\n      });\n      if (types.length == 0) {\n        // This means it's not usable on the command line. e.g. an Object.\n        return;\n      }\n      // Only keep enum values we support (booleans, numbers and strings).\n      const enumValues = (core_1.json.isJsonArray(current.enum) && current.enum || []).filter(x => {\n        switch (typeof x) {\n          case 'boolean':\n          case 'number':\n          case 'string':\n            return true;\n          default:\n            return false;\n        }\n      });\n      let defaultValue = undefined;\n      if (current.default !== undefined) {\n        switch (types[0]) {\n          case 'string':\n            if (typeof current.default == 'string') {\n              defaultValue = current.default;\n            }\n            break;\n          case 'number':\n            if (typeof current.default == 'number') {\n              defaultValue = current.default;\n            }\n            break;\n          case 'boolean':\n            if (typeof current.default == 'boolean') {\n              defaultValue = current.default;\n            }\n            break;\n        }\n      }\n      const type = types[0];\n      const $default = current.$default;\n      const $defaultIndex = core_1.json.isJsonObject($default) && $default['$source'] == 'argv' ? $default['index'] : undefined;\n      const positional = typeof $defaultIndex == 'number' ? $defaultIndex : undefined;\n      let required = core_1.json.isJsonArray(schema.required) ? schema.required.includes(name) : false;\n      if (required && interactive && current['x-prompt']) {\n        required = false;\n      }\n      const alias = core_1.json.isJsonArray(current.aliases) ? [...current.aliases].map(x => '' + x) : current.alias ? ['' + current.alias] : [];\n      const format = typeof current.format == 'string' ? current.format : undefined;\n      const visible = current.visible === undefined || current.visible === true;\n      const hidden = !!current.hidden || !visible;\n      const xUserAnalytics = current['x-user-analytics'];\n      const userAnalytics = typeof xUserAnalytics === 'string' ? xUserAnalytics : undefined;\n      // Deprecated is set only if it's true or a string.\n      const xDeprecated = current['x-deprecated'];\n      const deprecated = xDeprecated === true || typeof xDeprecated === 'string' ? xDeprecated : undefined;\n      const option = {\n        name,\n        description: '' + (current.description === undefined ? '' : current.description),\n        type,\n        default: defaultValue,\n        choices: enumValues.length ? enumValues : undefined,\n        required,\n        alias,\n        format,\n        hidden,\n        userAnalytics,\n        deprecated,\n        positional\n      };\n      options.push(option);\n    }\n    const flattenedSchema = yield registry.flatten(schema).toPromise();\n    core_1.json.schema.visitJsonSchema(flattenedSchema, visitor);\n    // Sort by positional and name.\n    return options.sort((a, b) => {\n      if (a.positional) {\n        return b.positional ? a.positional - b.positional : a.name.localeCompare(b.name);\n      } else if (b.positional) {\n        return -1;\n      }\n      return a.name.localeCompare(b.name);\n    });\n  });\n  return _parseJsonSchemaToOptions.apply(this, arguments);\n}\nexports.parseJsonSchemaToOptions = parseJsonSchemaToOptions;","map":{"version":3,"names":["Object","defineProperty","exports","value","parseJsonSchemaToOptions","core_1","require","registry","schema","interactive","options","visitor","current","pointer","parentSchema","split","length","json","isJsonArray","indexOf","Error","ptr","parseJsonPointer","name","typeSet","getTypesOfSchema","size","types","filter","x","isJsonObject","items","type","includes","enumValues","enum","defaultValue","undefined","default","$default","$defaultIndex","positional","required","alias","aliases","map","format","visible","hidden","xUserAnalytics","userAnalytics","xDeprecated","deprecated","option","description","choices","push","flattenedSchema","flatten","toPromise","visitJsonSchema","sort","a","b","localeCompare"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/src/command-builder/utilities/json-schema.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseJsonSchemaToOptions = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nasync function parseJsonSchemaToOptions(registry, schema, interactive = true) {\n    const options = [];\n    function visitor(current, pointer, parentSchema) {\n        if (!parentSchema) {\n            // Ignore root.\n            return;\n        }\n        else if (pointer.split(/\\/(?:properties|items|definitions)\\//g).length > 2) {\n            // Ignore subitems (objects or arrays).\n            return;\n        }\n        else if (core_1.json.isJsonArray(current)) {\n            return;\n        }\n        if (pointer.indexOf('/not/') != -1) {\n            // We don't support anyOf/not.\n            throw new Error('The \"not\" keyword is not supported in JSON Schema.');\n        }\n        const ptr = core_1.json.schema.parseJsonPointer(pointer);\n        const name = ptr[ptr.length - 1];\n        if (ptr[ptr.length - 2] != 'properties') {\n            // Skip any non-property items.\n            return;\n        }\n        const typeSet = core_1.json.schema.getTypesOfSchema(current);\n        if (typeSet.size == 0) {\n            throw new Error('Cannot find type of schema.');\n        }\n        // We only support number, string or boolean (or array of those), so remove everything else.\n        const types = [...typeSet].filter((x) => {\n            switch (x) {\n                case 'boolean':\n                case 'number':\n                case 'string':\n                    return true;\n                case 'array':\n                    // Only include arrays if they're boolean, string or number.\n                    if (core_1.json.isJsonObject(current.items) &&\n                        typeof current.items.type == 'string' &&\n                        ['boolean', 'number', 'string'].includes(current.items.type)) {\n                        return true;\n                    }\n                    return false;\n                default:\n                    return false;\n            }\n        });\n        if (types.length == 0) {\n            // This means it's not usable on the command line. e.g. an Object.\n            return;\n        }\n        // Only keep enum values we support (booleans, numbers and strings).\n        const enumValues = ((core_1.json.isJsonArray(current.enum) && current.enum) || []).filter((x) => {\n            switch (typeof x) {\n                case 'boolean':\n                case 'number':\n                case 'string':\n                    return true;\n                default:\n                    return false;\n            }\n        });\n        let defaultValue = undefined;\n        if (current.default !== undefined) {\n            switch (types[0]) {\n                case 'string':\n                    if (typeof current.default == 'string') {\n                        defaultValue = current.default;\n                    }\n                    break;\n                case 'number':\n                    if (typeof current.default == 'number') {\n                        defaultValue = current.default;\n                    }\n                    break;\n                case 'boolean':\n                    if (typeof current.default == 'boolean') {\n                        defaultValue = current.default;\n                    }\n                    break;\n            }\n        }\n        const type = types[0];\n        const $default = current.$default;\n        const $defaultIndex = core_1.json.isJsonObject($default) && $default['$source'] == 'argv' ? $default['index'] : undefined;\n        const positional = typeof $defaultIndex == 'number' ? $defaultIndex : undefined;\n        let required = core_1.json.isJsonArray(schema.required) ? schema.required.includes(name) : false;\n        if (required && interactive && current['x-prompt']) {\n            required = false;\n        }\n        const alias = core_1.json.isJsonArray(current.aliases)\n            ? [...current.aliases].map((x) => '' + x)\n            : current.alias\n                ? ['' + current.alias]\n                : [];\n        const format = typeof current.format == 'string' ? current.format : undefined;\n        const visible = current.visible === undefined || current.visible === true;\n        const hidden = !!current.hidden || !visible;\n        const xUserAnalytics = current['x-user-analytics'];\n        const userAnalytics = typeof xUserAnalytics === 'string' ? xUserAnalytics : undefined;\n        // Deprecated is set only if it's true or a string.\n        const xDeprecated = current['x-deprecated'];\n        const deprecated = xDeprecated === true || typeof xDeprecated === 'string' ? xDeprecated : undefined;\n        const option = {\n            name,\n            description: '' + (current.description === undefined ? '' : current.description),\n            type,\n            default: defaultValue,\n            choices: enumValues.length ? enumValues : undefined,\n            required,\n            alias,\n            format,\n            hidden,\n            userAnalytics,\n            deprecated,\n            positional,\n        };\n        options.push(option);\n    }\n    const flattenedSchema = await registry.flatten(schema).toPromise();\n    core_1.json.schema.visitJsonSchema(flattenedSchema, visitor);\n    // Sort by positional and name.\n    return options.sort((a, b) => {\n        if (a.positional) {\n            return b.positional ? a.positional - b.positional : a.name.localeCompare(b.name);\n        }\n        else if (b.positional) {\n            return -1;\n        }\n        return a.name.localeCompare(b.name);\n    });\n}\nexports.parseJsonSchemaToOptions = parseJsonSchemaToOptions;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}