{"ast":null,"code":"var util = require('util'),\n  Match = require('../match');\n\n/**\n * Binary search implementation (recursive)\n */\nfunction binarySearch(arr, searchValue) {\n  function find(arr, searchValue, left, right) {\n    if (right < left) return -1;\n\n    /*\n    int mid = mid = (left + right) / 2;\n    There is a bug in the above line;\n    Joshua Bloch suggests the following replacement:\n    */\n    var mid = Math.floor(left + right >>> 1);\n    if (searchValue > arr[mid]) return find(arr, searchValue, mid + 1, right);\n    if (searchValue < arr[mid]) return find(arr, searchValue, left, mid - 1);\n    return mid;\n  }\n  ;\n  return find(arr, searchValue, 0, arr.length - 1);\n}\n;\n\n// 'Character'  iterated character class.\n//    Recognizers for specific mbcs encodings make their 'characters' available\n//    by providing a nextChar() function that fills in an instance of iteratedChar\n//    with the next char from the input.\n//    The returned characters are not converted to Unicode, but remain as the raw\n//    bytes (concatenated into an int) from the codepage data.\n//\n//  For Asian charsets, use the raw input rather than the input that has been\n//   stripped of markup.  Detection only considers multi-byte chars, effectively\n//   stripping markup anyway, and double byte chars do occur in markup too.\n//\nfunction IteratedChar() {\n  this.charValue = 0; // 1-4 bytes from the raw input data\n  this.index = 0;\n  this.nextIndex = 0;\n  this.error = false;\n  this.done = false;\n  this.reset = function () {\n    this.charValue = 0;\n    this.index = -1;\n    this.nextIndex = 0;\n    this.error = false;\n    this.done = false;\n  };\n  this.nextByte = function (det) {\n    if (this.nextIndex >= det.fRawLength) {\n      this.done = true;\n      return -1;\n    }\n    var byteValue = det.fRawInput[this.nextIndex++] & 0x00ff;\n    return byteValue;\n  };\n}\n;\n\n/**\n * Asian double or multi-byte - charsets.\n * Match is determined mostly by the input data adhering to the\n * encoding scheme for the charset, and, optionally,\n * frequency-of-occurence of characters.\n */\n\nfunction mbcs() {}\n;\n\n/**\n * Test the match of this charset with the input text data\n *      which is obtained via the CharsetDetector object.\n *\n * @param det  The CharsetDetector, which contains the input text\n *             to be checked for being in this charset.\n * @return     Two values packed into one int  (Damn java, anyhow)\n *             bits 0-7:  the match confidence, ranging from 0-100\n *             bits 8-15: The match reason, an enum-like value.\n */\nmbcs.prototype.match = function (det) {\n  var singleByteCharCount = 0,\n    //TODO Do we really need this?\n    doubleByteCharCount = 0,\n    commonCharCount = 0,\n    badCharCount = 0,\n    totalCharCount = 0,\n    confidence = 0;\n  var iter = new IteratedChar();\n  detectBlock: {\n    for (iter.reset(); this.nextChar(iter, det);) {\n      totalCharCount++;\n      if (iter.error) {\n        badCharCount++;\n      } else {\n        var cv = iter.charValue & 0xFFFFFFFF;\n        if (cv <= 0xff) {\n          singleByteCharCount++;\n        } else {\n          doubleByteCharCount++;\n          if (this.commonChars != null) {\n            // NOTE: This assumes that there are no 4-byte common chars.\n            if (binarySearch(this.commonChars, cv) >= 0) {\n              commonCharCount++;\n            }\n          }\n        }\n      }\n      if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) {\n        // console.log('its here!')\n        // Bail out early if the byte data is not matching the encoding scheme.\n        break detectBlock;\n      }\n    }\n    if (doubleByteCharCount <= 10 && badCharCount == 0) {\n      // Not many multi-byte chars.\n      if (doubleByteCharCount == 0 && totalCharCount < 10) {\n        // There weren't any multibyte sequences, and there was a low density of non-ASCII single bytes.\n        // We don't have enough data to have any confidence.\n        // Statistical analysis of single byte non-ASCII charcters would probably help here.\n        confidence = 0;\n      } else {\n        //   ASCII or ISO file?  It's probably not our encoding,\n        //   but is not incompatible with our encoding, so don't give it a zero.\n        confidence = 10;\n      }\n      break detectBlock;\n    }\n\n    //\n    //  No match if there are too many characters that don't fit the encoding scheme.\n    //    (should we have zero tolerance for these?)\n    //\n    if (doubleByteCharCount < 20 * badCharCount) {\n      confidence = 0;\n      break detectBlock;\n    }\n    if (this.commonChars == null) {\n      // We have no statistics on frequently occuring characters.\n      //  Assess confidence purely on having a reasonable number of\n      //  multi-byte characters (the more the better\n      confidence = 30 + doubleByteCharCount - 20 * badCharCount;\n      if (confidence > 100) {\n        confidence = 100;\n      }\n    } else {\n      //\n      // Frequency of occurence statistics exist.\n      //\n      var maxVal = Math.log(parseFloat(doubleByteCharCount) / 4);\n      var scaleFactor = 90.0 / maxVal;\n      confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10);\n      confidence = Math.min(confidence, 100);\n    }\n  } // end of detectBlock:\n\n  return confidence == 0 ? null : new Match(det, this, confidence);\n};\n\n/**\n * Get the next character (however many bytes it is) from the input data\n *    Subclasses for specific charset encodings must implement this function\n *    to get characters according to the rules of their encoding scheme.\n *\n *  This function is not a method of class iteratedChar only because\n *   that would require a lot of extra derived classes, which is awkward.\n * @param it  The iteratedChar 'struct' into which the returned char is placed.\n * @param det The charset detector, which is needed to get at the input byte data\n *            being iterated over.\n * @return    True if a character was returned, false at end of input.\n */\n\nmbcs.prototype.nextChar = function (iter, det) {};\n\n/**\n * Shift-JIS charset recognizer.\n */\nmodule.exports.sjis = function () {\n  this.name = function () {\n    return 'Shift-JIS';\n  };\n  this.language = function () {\n    return 'ja';\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [0x8140, 0x8141, 0x8142, 0x8145, 0x815b, 0x8169, 0x816a, 0x8175, 0x8176, 0x82a0, 0x82a2, 0x82a4, 0x82a9, 0x82aa, 0x82ab, 0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5, 0x82b7, 0x82bd, 0x82be, 0x82c1, 0x82c4, 0x82c5, 0x82c6, 0x82c8, 0x82c9, 0x82cc, 0x82cd, 0x82dc, 0x82e0, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82f0, 0x82f1, 0x8341, 0x8343, 0x834e, 0x834f, 0x8358, 0x835e, 0x8362, 0x8367, 0x8375, 0x8376, 0x8389, 0x838a, 0x838b, 0x838d, 0x8393, 0x8e96, 0x93fa, 0x95aa];\n  this.nextChar = function (iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n    var firstByte;\n    firstByte = iter.charValue = iter.nextByte(det);\n    if (firstByte < 0) return false;\n    if (firstByte <= 0x7f || firstByte > 0xa0 && firstByte <= 0xdf) return true;\n    var secondByte = iter.nextByte(det);\n    if (secondByte < 0) return false;\n    iter.charValue = firstByte << 8 | secondByte;\n    if (!(secondByte >= 0x40 && secondByte <= 0x7f || secondByte >= 0x80 && secondByte <= 0xff)) {\n      // Illegal second byte value.\n      iter.error = true;\n    }\n    return true;\n  };\n};\nutil.inherits(module.exports.sjis, mbcs);\n\n/**\n *   Big5 charset recognizer.\n */\nmodule.exports.big5 = function () {\n  this.name = function () {\n    return 'Big5';\n  };\n  this.language = function () {\n    return 'zh';\n  };\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [0xa140, 0xa141, 0xa142, 0xa143, 0xa147, 0xa149, 0xa175, 0xa176, 0xa440, 0xa446, 0xa447, 0xa448, 0xa451, 0xa454, 0xa457, 0xa464, 0xa46a, 0xa46c, 0xa477, 0xa4a3, 0xa4a4, 0xa4a7, 0xa4c1, 0xa4ce, 0xa4d1, 0xa4df, 0xa4e8, 0xa4fd, 0xa540, 0xa548, 0xa558, 0xa569, 0xa5cd, 0xa5e7, 0xa657, 0xa661, 0xa662, 0xa668, 0xa670, 0xa6a8, 0xa6b3, 0xa6b9, 0xa6d3, 0xa6db, 0xa6e6, 0xa6f2, 0xa740, 0xa751, 0xa759, 0xa7da, 0xa8a3, 0xa8a5, 0xa8ad, 0xa8d1, 0xa8d3, 0xa8e4, 0xa8fc, 0xa9c0, 0xa9d2, 0xa9f3, 0xaa6b, 0xaaba, 0xaabe, 0xaacc, 0xaafc, 0xac47, 0xac4f, 0xacb0, 0xacd2, 0xad59, 0xaec9, 0xafe0, 0xb0ea, 0xb16f, 0xb2b3, 0xb2c4, 0xb36f, 0xb44c, 0xb44e, 0xb54c, 0xb5a5, 0xb5bd, 0xb5d0, 0xb5d8, 0xb671, 0xb7ed, 0xb867, 0xb944, 0xbad8, 0xbb44, 0xbba1, 0xbdd1, 0xc2c4, 0xc3b9, 0xc440, 0xc45f];\n  this.nextChar = function (iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n    var firstByte = iter.charValue = iter.nextByte(det);\n    if (firstByte < 0) return false;\n\n    // single byte character.\n    if (firstByte <= 0x7f || firstByte == 0xff) return true;\n    var secondByte = iter.nextByte(det);\n    if (secondByte < 0) return false;\n    iter.charValue = iter.charValue << 8 | secondByte;\n    if (secondByte < 0x40 || secondByte == 0x7f || secondByte == 0xff) iter.error = true;\n    return true;\n  };\n};\nutil.inherits(module.exports.big5, mbcs);\n\n/**\n *  EUC charset recognizers.  One abstract class that provides the common function\n *  for getting the next character according to the EUC encoding scheme,\n *  and nested derived classes for EUC_KR, EUC_JP, EUC_CN.\n *\n *  Get the next character value for EUC based encodings.\n *  Character 'value' is simply the raw bytes that make up the character\n *     packed into an int.\n */\nfunction eucNextChar(iter, det) {\n  iter.index = iter.nextIndex;\n  iter.error = false;\n  var firstByte = 0;\n  var secondByte = 0;\n  var thirdByte = 0;\n  //int fourthByte = 0;\n  buildChar: {\n    firstByte = iter.charValue = iter.nextByte(det);\n    if (firstByte < 0) {\n      // Ran off the end of the input data\n      iter.done = true;\n      break buildChar;\n    }\n    if (firstByte <= 0x8d) {\n      // single byte char\n      break buildChar;\n    }\n    secondByte = iter.nextByte(det);\n    iter.charValue = iter.charValue << 8 | secondByte;\n    if (firstByte >= 0xA1 && firstByte <= 0xfe) {\n      // Two byte Char\n      if (secondByte < 0xa1) {\n        iter.error = true;\n      }\n      break buildChar;\n    }\n    if (firstByte == 0x8e) {\n      // Code Set 2.\n      //   In EUC-JP, total char size is 2 bytes, only one byte of actual char value.\n      //   In EUC-TW, total char size is 4 bytes, three bytes contribute to char value.\n      // We don't know which we've got.\n      // Treat it like EUC-JP.  If the data really was EUC-TW, the following two\n      //   bytes will look like a well formed 2 byte char.\n      if (secondByte < 0xa1) {\n        iter.error = true;\n      }\n      break buildChar;\n    }\n    if (firstByte == 0x8f) {\n      // Code set 3.\n      // Three byte total char size, two bytes of actual char value.\n      thirdByte = iter.nextByte(det);\n      iter.charValue = iter.charValue << 8 | thirdByte;\n      if (thirdByte < 0xa1) {\n        iter.error = true;\n      }\n    }\n  }\n  return iter.done == false;\n}\n;\n\n/**\n * The charset recognize for EUC-JP.  A singleton instance of this class\n *    is created and kept by the public CharsetDetector class\n */\nmodule.exports.euc_jp = function () {\n  this.name = function () {\n    return 'EUC-JP';\n  };\n  this.language = function () {\n    return 'ja';\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [0xa1a1, 0xa1a2, 0xa1a3, 0xa1a6, 0xa1bc, 0xa1ca, 0xa1cb, 0xa1d6, 0xa1d7, 0xa4a2, 0xa4a4, 0xa4a6, 0xa4a8, 0xa4aa, 0xa4ab, 0xa4ac, 0xa4ad, 0xa4af, 0xa4b1, 0xa4b3, 0xa4b5, 0xa4b7, 0xa4b9, 0xa4bb, 0xa4bd, 0xa4bf, 0xa4c0, 0xa4c1, 0xa4c3, 0xa4c4, 0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca, 0xa4cb, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4de, 0xa4df, 0xa4e1, 0xa4e2, 0xa4e4, 0xa4e8, 0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ef, 0xa4f2, 0xa4f3, 0xa5a2, 0xa5a3, 0xa5a4, 0xa5a6, 0xa5a7, 0xa5aa, 0xa5ad, 0xa5af, 0xa5b0, 0xa5b3, 0xa5b5, 0xa5b7, 0xa5b8, 0xa5b9, 0xa5bf, 0xa5c3, 0xa5c6, 0xa5c7, 0xa5c8, 0xa5c9, 0xa5cb, 0xa5d0, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5de, 0xa5e0, 0xa5e1, 0xa5e5, 0xa5e9, 0xa5ea, 0xa5eb, 0xa5ec, 0xa5ed, 0xa5f3, 0xb8a9, 0xb9d4, 0xbaee, 0xbbc8, 0xbef0, 0xbfb7, 0xc4ea, 0xc6fc, 0xc7bd, 0xcab8, 0xcaf3, 0xcbdc, 0xcdd1];\n  this.nextChar = eucNextChar;\n};\nutil.inherits(module.exports.euc_jp, mbcs);\n\n/**\n * The charset recognize for EUC-KR.  A singleton instance of this class\n *    is created and kept by the public CharsetDetector class\n */\nmodule.exports.euc_kr = function () {\n  this.name = function () {\n    return 'EUC-KR';\n  };\n  this.language = function () {\n    return 'ko';\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [0xb0a1, 0xb0b3, 0xb0c5, 0xb0cd, 0xb0d4, 0xb0e6, 0xb0ed, 0xb0f8, 0xb0fa, 0xb0fc, 0xb1b8, 0xb1b9, 0xb1c7, 0xb1d7, 0xb1e2, 0xb3aa, 0xb3bb, 0xb4c2, 0xb4cf, 0xb4d9, 0xb4eb, 0xb5a5, 0xb5b5, 0xb5bf, 0xb5c7, 0xb5e9, 0xb6f3, 0xb7af, 0xb7c2, 0xb7ce, 0xb8a6, 0xb8ae, 0xb8b6, 0xb8b8, 0xb8bb, 0xb8e9, 0xb9ab, 0xb9ae, 0xb9cc, 0xb9ce, 0xb9fd, 0xbab8, 0xbace, 0xbad0, 0xbaf1, 0xbbe7, 0xbbf3, 0xbbfd, 0xbcad, 0xbcba, 0xbcd2, 0xbcf6, 0xbdba, 0xbdc0, 0xbdc3, 0xbdc5, 0xbec6, 0xbec8, 0xbedf, 0xbeee, 0xbef8, 0xbefa, 0xbfa1, 0xbfa9, 0xbfc0, 0xbfe4, 0xbfeb, 0xbfec, 0xbff8, 0xc0a7, 0xc0af, 0xc0b8, 0xc0ba, 0xc0bb, 0xc0bd, 0xc0c7, 0xc0cc, 0xc0ce, 0xc0cf, 0xc0d6, 0xc0da, 0xc0e5, 0xc0fb, 0xc0fc, 0xc1a4, 0xc1a6, 0xc1b6, 0xc1d6, 0xc1df, 0xc1f6, 0xc1f8, 0xc4a1, 0xc5cd, 0xc6ae, 0xc7cf, 0xc7d1, 0xc7d2, 0xc7d8, 0xc7e5, 0xc8ad];\n  this.nextChar = eucNextChar;\n};\nutil.inherits(module.exports.euc_kr, mbcs);\n\n/**\n *   GB-18030 recognizer. Uses simplified Chinese statistics.\n */\nmodule.exports.gb_18030 = function () {\n  this.name = function () {\n    return 'GB18030';\n  };\n  this.language = function () {\n    return 'zh';\n  };\n\n  /*\n   *  Get the next character value for EUC based encodings.\n   *  Character 'value' is simply the raw bytes that make up the character\n   *     packed into an int.\n   */\n  this.nextChar = function (iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n    var firstByte = 0;\n    var secondByte = 0;\n    var thirdByte = 0;\n    var fourthByte = 0;\n    buildChar: {\n      firstByte = iter.charValue = iter.nextByte(det);\n      if (firstByte < 0) {\n        // Ran off the end of the input data\n        iter.done = true;\n        break buildChar;\n      }\n      if (firstByte <= 0x80) {\n        // single byte char\n        break buildChar;\n      }\n      secondByte = iter.nextByte(det);\n      iter.charValue = iter.charValue << 8 | secondByte;\n      if (firstByte >= 0x81 && firstByte <= 0xFE) {\n        // Two byte Char\n        if (secondByte >= 0x40 && secondByte <= 0x7E || secondByte >= 80 && secondByte <= 0xFE) {\n          break buildChar;\n        }\n        // Four byte char\n        if (secondByte >= 0x30 && secondByte <= 0x39) {\n          thirdByte = iter.nextByte(det);\n          if (thirdByte >= 0x81 && thirdByte <= 0xFE) {\n            fourthByte = iter.nextByte(det);\n            if (fourthByte >= 0x30 && fourthByte <= 0x39) {\n              iter.charValue = iter.charValue << 16 | thirdByte << 8 | fourthByte;\n              break buildChar;\n            }\n          }\n        }\n        iter.error = true;\n        break buildChar;\n      }\n    }\n    return iter.done == false;\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [0xa1a1, 0xa1a2, 0xa1a3, 0xa1a4, 0xa1b0, 0xa1b1, 0xa1f1, 0xa1f3, 0xa3a1, 0xa3ac, 0xa3ba, 0xb1a8, 0xb1b8, 0xb1be, 0xb2bb, 0xb3c9, 0xb3f6, 0xb4f3, 0xb5bd, 0xb5c4, 0xb5e3, 0xb6af, 0xb6d4, 0xb6e0, 0xb7a2, 0xb7a8, 0xb7bd, 0xb7d6, 0xb7dd, 0xb8b4, 0xb8df, 0xb8f6, 0xb9ab, 0xb9c9, 0xb9d8, 0xb9fa, 0xb9fd, 0xbacd, 0xbba7, 0xbbd6, 0xbbe1, 0xbbfa, 0xbcbc, 0xbcdb, 0xbcfe, 0xbdcc, 0xbecd, 0xbedd, 0xbfb4, 0xbfc6, 0xbfc9, 0xc0b4, 0xc0ed, 0xc1cb, 0xc2db, 0xc3c7, 0xc4dc, 0xc4ea, 0xc5cc, 0xc6f7, 0xc7f8, 0xc8ab, 0xc8cb, 0xc8d5, 0xc8e7, 0xc9cf, 0xc9fa, 0xcab1, 0xcab5, 0xcac7, 0xcad0, 0xcad6, 0xcaf5, 0xcafd, 0xccec, 0xcdf8, 0xceaa, 0xcec4, 0xced2, 0xcee5, 0xcfb5, 0xcfc2, 0xcfd6, 0xd0c2, 0xd0c5, 0xd0d0, 0xd0d4, 0xd1a7, 0xd2aa, 0xd2b2, 0xd2b5, 0xd2bb, 0xd2d4, 0xd3c3, 0xd3d0, 0xd3fd, 0xd4c2, 0xd4da, 0xd5e2, 0xd6d0];\n};\nutil.inherits(module.exports.gb_18030, mbcs);","map":{"version":3,"names":["util","require","Match","binarySearch","arr","searchValue","find","left","right","mid","Math","floor","length","IteratedChar","charValue","index","nextIndex","error","done","reset","nextByte","det","fRawLength","byteValue","fRawInput","mbcs","prototype","match","singleByteCharCount","doubleByteCharCount","commonCharCount","badCharCount","totalCharCount","confidence","iter","detectBlock","nextChar","cv","commonChars","maxVal","log","parseFloat","scaleFactor","min","module","exports","sjis","name","language","firstByte","secondByte","inherits","big5","eucNextChar","thirdByte","buildChar","euc_jp","euc_kr","gb_18030","fourthByte"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/chardet/encoding/mbcs.js"],"sourcesContent":["var util = require('util'),\n  Match = require ('../match');\n\n/**\n * Binary search implementation (recursive)\n */\nfunction binarySearch(arr, searchValue) {\n  function find(arr, searchValue, left, right) {\n    if (right < left)\n      return -1;\n\n    /*\n    int mid = mid = (left + right) / 2;\n    There is a bug in the above line;\n    Joshua Bloch suggests the following replacement:\n    */\n    var mid = Math.floor((left + right) >>> 1);\n    if (searchValue > arr[mid])\n      return find(arr, searchValue, mid + 1, right);\n\n    if (searchValue < arr[mid])\n      return find(arr, searchValue, left, mid - 1);\n\n    return mid;\n  };\n\n  return find(arr, searchValue, 0, arr.length - 1);\n};\n\n// 'Character'  iterated character class.\n//    Recognizers for specific mbcs encodings make their 'characters' available\n//    by providing a nextChar() function that fills in an instance of iteratedChar\n//    with the next char from the input.\n//    The returned characters are not converted to Unicode, but remain as the raw\n//    bytes (concatenated into an int) from the codepage data.\n//\n//  For Asian charsets, use the raw input rather than the input that has been\n//   stripped of markup.  Detection only considers multi-byte chars, effectively\n//   stripping markup anyway, and double byte chars do occur in markup too.\n//\nfunction IteratedChar() {\n\n  this.charValue = 0; // 1-4 bytes from the raw input data\n  this.index     = 0;\n  this.nextIndex = 0;\n  this.error     = false;\n  this.done      = false;\n\n  this.reset = function() {\n    this.charValue = 0;\n    this.index     = -1;\n    this.nextIndex = 0;\n    this.error     = false;\n    this.done      = false;\n  };\n\n  this.nextByte = function(det) {\n    if (this.nextIndex >= det.fRawLength) {\n      this.done = true;\n      return -1;\n    }\n    var byteValue = det.fRawInput[this.nextIndex++] & 0x00ff;\n    return byteValue;\n  };\n};\n\n\n\n/**\n * Asian double or multi-byte - charsets.\n * Match is determined mostly by the input data adhering to the\n * encoding scheme for the charset, and, optionally,\n * frequency-of-occurence of characters.\n */\n\nfunction mbcs() {};\n\n/**\n * Test the match of this charset with the input text data\n *      which is obtained via the CharsetDetector object.\n *\n * @param det  The CharsetDetector, which contains the input text\n *             to be checked for being in this charset.\n * @return     Two values packed into one int  (Damn java, anyhow)\n *             bits 0-7:  the match confidence, ranging from 0-100\n *             bits 8-15: The match reason, an enum-like value.\n */\nmbcs.prototype.match = function(det) {\n\n  var singleByteCharCount = 0,  //TODO Do we really need this?\n    doubleByteCharCount = 0,\n    commonCharCount     = 0,\n    badCharCount        = 0,\n    totalCharCount      = 0,\n    confidence          = 0;\n\n  var iter = new IteratedChar();\n\n  detectBlock: {\n    for (iter.reset(); this.nextChar(iter, det);) {\n      totalCharCount++;\n      if (iter.error) {\n        badCharCount++;\n      } else {\n        var cv = iter.charValue & 0xFFFFFFFF;\n\n        if (cv <= 0xff) {\n          singleByteCharCount++;\n        } else {\n          doubleByteCharCount++;\n          if (this.commonChars != null) {\n            // NOTE: This assumes that there are no 4-byte common chars.\n            if (binarySearch(this.commonChars, cv) >= 0) {\n              commonCharCount++;\n            }\n          }\n        }\n      }\n      if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) {\n        // console.log('its here!')\n        // Bail out early if the byte data is not matching the encoding scheme.\n        break detectBlock;\n      }\n    }\n\n    if (doubleByteCharCount <= 10 && badCharCount== 0) {\n      // Not many multi-byte chars.\n      if (doubleByteCharCount == 0 && totalCharCount < 10) {\n        // There weren't any multibyte sequences, and there was a low density of non-ASCII single bytes.\n        // We don't have enough data to have any confidence.\n        // Statistical analysis of single byte non-ASCII charcters would probably help here.\n        confidence = 0;\n      }\n      else {\n        //   ASCII or ISO file?  It's probably not our encoding,\n        //   but is not incompatible with our encoding, so don't give it a zero.\n        confidence = 10;\n      }\n      break detectBlock;\n    }\n\n    //\n    //  No match if there are too many characters that don't fit the encoding scheme.\n    //    (should we have zero tolerance for these?)\n    //\n    if (doubleByteCharCount < 20 * badCharCount) {\n      confidence = 0;\n      break detectBlock;\n    }\n\n    if (this.commonChars == null) {\n      // We have no statistics on frequently occuring characters.\n      //  Assess confidence purely on having a reasonable number of\n      //  multi-byte characters (the more the better\n      confidence = 30 + doubleByteCharCount - 20 * badCharCount;\n      if (confidence > 100) {\n        confidence = 100;\n      }\n    } else {\n      //\n      // Frequency of occurence statistics exist.\n      //\n      var maxVal = Math.log(parseFloat(doubleByteCharCount) / 4);\n      var scaleFactor = 90.0 / maxVal;\n      confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10);\n      confidence = Math.min(confidence, 100);\n    }\n  }   // end of detectBlock:\n\n  return confidence == 0 ? null : new Match(det, this, confidence);\n};\n\n/**\n * Get the next character (however many bytes it is) from the input data\n *    Subclasses for specific charset encodings must implement this function\n *    to get characters according to the rules of their encoding scheme.\n *\n *  This function is not a method of class iteratedChar only because\n *   that would require a lot of extra derived classes, which is awkward.\n * @param it  The iteratedChar 'struct' into which the returned char is placed.\n * @param det The charset detector, which is needed to get at the input byte data\n *            being iterated over.\n * @return    True if a character was returned, false at end of input.\n */\n\nmbcs.prototype.nextChar = function(iter, det) {};\n\n\n\n/**\n * Shift-JIS charset recognizer.\n */\nmodule.exports.sjis = function() {\n  this.name = function() {\n    return 'Shift-JIS';\n  };\n  this.language = function() {\n    return 'ja';\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0x8140, 0x8141, 0x8142, 0x8145, 0x815b, 0x8169, 0x816a, 0x8175, 0x8176, 0x82a0,\n    0x82a2, 0x82a4, 0x82a9, 0x82aa, 0x82ab, 0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5,\n    0x82b7, 0x82bd, 0x82be, 0x82c1, 0x82c4, 0x82c5, 0x82c6, 0x82c8, 0x82c9, 0x82cc,\n    0x82cd, 0x82dc, 0x82e0, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82f0, 0x82f1, 0x8341,\n    0x8343, 0x834e, 0x834f, 0x8358, 0x835e, 0x8362, 0x8367, 0x8375, 0x8376, 0x8389,\n    0x838a, 0x838b, 0x838d, 0x8393, 0x8e96, 0x93fa, 0x95aa\n  ];\n\n  this.nextChar = function(iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n\n    var firstByte;\n    firstByte = iter.charValue = iter.nextByte(det);\n    if (firstByte < 0)\n      return false;\n\n    if (firstByte <= 0x7f || (firstByte > 0xa0 && firstByte <= 0xdf))\n      return true;\n\n    var secondByte = iter.nextByte(det);\n    if (secondByte < 0)\n      return false;\n\n    iter.charValue = (firstByte << 8) | secondByte;\n    if (! ((secondByte >= 0x40 && secondByte <= 0x7f) || (secondByte >= 0x80 && secondByte <= 0xff))) {\n      // Illegal second byte value.\n      iter.error = true;\n    }\n    return true;\n  };\n};\nutil.inherits(module.exports.sjis, mbcs);\n\n\n\n/**\n *   Big5 charset recognizer.\n */\nmodule.exports.big5 = function() {\n  this.name = function() {\n    return 'Big5';\n  };\n  this.language = function() {\n    return 'zh';\n  };\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0xa140, 0xa141, 0xa142, 0xa143, 0xa147, 0xa149, 0xa175, 0xa176, 0xa440, 0xa446,\n    0xa447, 0xa448, 0xa451, 0xa454, 0xa457, 0xa464, 0xa46a, 0xa46c, 0xa477, 0xa4a3,\n    0xa4a4, 0xa4a7, 0xa4c1, 0xa4ce, 0xa4d1, 0xa4df, 0xa4e8, 0xa4fd, 0xa540, 0xa548,\n    0xa558, 0xa569, 0xa5cd, 0xa5e7, 0xa657, 0xa661, 0xa662, 0xa668, 0xa670, 0xa6a8,\n    0xa6b3, 0xa6b9, 0xa6d3, 0xa6db, 0xa6e6, 0xa6f2, 0xa740, 0xa751, 0xa759, 0xa7da,\n    0xa8a3, 0xa8a5, 0xa8ad, 0xa8d1, 0xa8d3, 0xa8e4, 0xa8fc, 0xa9c0, 0xa9d2, 0xa9f3,\n    0xaa6b, 0xaaba, 0xaabe, 0xaacc, 0xaafc, 0xac47, 0xac4f, 0xacb0, 0xacd2, 0xad59,\n    0xaec9, 0xafe0, 0xb0ea, 0xb16f, 0xb2b3, 0xb2c4, 0xb36f, 0xb44c, 0xb44e, 0xb54c,\n    0xb5a5, 0xb5bd, 0xb5d0, 0xb5d8, 0xb671, 0xb7ed, 0xb867, 0xb944, 0xbad8, 0xbb44,\n    0xbba1, 0xbdd1, 0xc2c4, 0xc3b9, 0xc440, 0xc45f\n  ];\n  this.nextChar = function(iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n\n    var firstByte = iter.charValue = iter.nextByte(det);\n\n    if (firstByte < 0)\n      return false;\n\n    // single byte character.\n    if (firstByte <= 0x7f || firstByte == 0xff)\n      return true;\n\n    var secondByte = iter.nextByte(det);\n\n    if (secondByte < 0)\n      return false;\n\n    iter.charValue = (iter.charValue << 8) | secondByte;\n\n    if (secondByte < 0x40 || secondByte == 0x7f || secondByte == 0xff)\n      iter.error = true;\n\n    return true;\n  };\n};\nutil.inherits(module.exports.big5, mbcs);\n\n\n\n/**\n *  EUC charset recognizers.  One abstract class that provides the common function\n *  for getting the next character according to the EUC encoding scheme,\n *  and nested derived classes for EUC_KR, EUC_JP, EUC_CN.\n *\n *  Get the next character value for EUC based encodings.\n *  Character 'value' is simply the raw bytes that make up the character\n *     packed into an int.\n */\nfunction eucNextChar(iter, det) {\n  iter.index = iter.nextIndex;\n  iter.error = false;\n  var firstByte  = 0;\n  var secondByte = 0;\n  var thirdByte  = 0;\n  //int fourthByte = 0;\n  buildChar: {\n    firstByte = iter.charValue = iter.nextByte(det);\n    if (firstByte < 0) {\n      // Ran off the end of the input data\n      iter.done = true;\n      break buildChar;\n    }\n    if (firstByte <= 0x8d) {\n      // single byte char\n      break buildChar;\n    }\n    secondByte = iter.nextByte(det);\n    iter.charValue = (iter.charValue << 8) | secondByte;\n    if (firstByte >= 0xA1 && firstByte <= 0xfe) {\n      // Two byte Char\n      if (secondByte < 0xa1) {\n        iter.error = true;\n      }\n      break buildChar;\n    }\n    if (firstByte == 0x8e) {\n      // Code Set 2.\n      //   In EUC-JP, total char size is 2 bytes, only one byte of actual char value.\n      //   In EUC-TW, total char size is 4 bytes, three bytes contribute to char value.\n      // We don't know which we've got.\n      // Treat it like EUC-JP.  If the data really was EUC-TW, the following two\n      //   bytes will look like a well formed 2 byte char.\n      if (secondByte < 0xa1) {\n        iter.error = true;\n      }\n      break buildChar;\n    }\n    if (firstByte == 0x8f) {\n      // Code set 3.\n      // Three byte total char size, two bytes of actual char value.\n      thirdByte = iter.nextByte(det);\n      iter.charValue = (iter.charValue << 8) | thirdByte;\n      if (thirdByte < 0xa1) {\n        iter.error = true;\n      }\n    }\n  }\n  return iter.done == false;\n};\n\n\n\n/**\n * The charset recognize for EUC-JP.  A singleton instance of this class\n *    is created and kept by the public CharsetDetector class\n */\nmodule.exports.euc_jp = function() {\n  this.name = function() {\n    return 'EUC-JP';\n  };\n  this.language = function() {\n    return 'ja';\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0xa1a1, 0xa1a2, 0xa1a3, 0xa1a6, 0xa1bc, 0xa1ca, 0xa1cb, 0xa1d6, 0xa1d7, 0xa4a2,\n    0xa4a4, 0xa4a6, 0xa4a8, 0xa4aa, 0xa4ab, 0xa4ac, 0xa4ad, 0xa4af, 0xa4b1, 0xa4b3,\n    0xa4b5, 0xa4b7, 0xa4b9, 0xa4bb, 0xa4bd, 0xa4bf, 0xa4c0, 0xa4c1, 0xa4c3, 0xa4c4,\n    0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca, 0xa4cb, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4de,\n    0xa4df, 0xa4e1, 0xa4e2, 0xa4e4, 0xa4e8, 0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ef,\n    0xa4f2, 0xa4f3, 0xa5a2, 0xa5a3, 0xa5a4, 0xa5a6, 0xa5a7, 0xa5aa, 0xa5ad, 0xa5af,\n    0xa5b0, 0xa5b3, 0xa5b5, 0xa5b7, 0xa5b8, 0xa5b9, 0xa5bf, 0xa5c3, 0xa5c6, 0xa5c7,\n    0xa5c8, 0xa5c9, 0xa5cb, 0xa5d0, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5de, 0xa5e0, 0xa5e1,\n    0xa5e5, 0xa5e9, 0xa5ea, 0xa5eb, 0xa5ec, 0xa5ed, 0xa5f3, 0xb8a9, 0xb9d4, 0xbaee,\n    0xbbc8, 0xbef0, 0xbfb7, 0xc4ea, 0xc6fc, 0xc7bd, 0xcab8, 0xcaf3, 0xcbdc, 0xcdd1\n  ];\n\n  this.nextChar = eucNextChar;\n};\nutil.inherits(module.exports.euc_jp, mbcs);\n\n\n\n/**\n * The charset recognize for EUC-KR.  A singleton instance of this class\n *    is created and kept by the public CharsetDetector class\n */\nmodule.exports.euc_kr = function() {\n  this.name = function() {\n    return 'EUC-KR';\n  };\n  this.language = function() {\n    return 'ko';\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0xb0a1, 0xb0b3, 0xb0c5, 0xb0cd, 0xb0d4, 0xb0e6, 0xb0ed, 0xb0f8, 0xb0fa, 0xb0fc,\n    0xb1b8, 0xb1b9, 0xb1c7, 0xb1d7, 0xb1e2, 0xb3aa, 0xb3bb, 0xb4c2, 0xb4cf, 0xb4d9,\n    0xb4eb, 0xb5a5, 0xb5b5, 0xb5bf, 0xb5c7, 0xb5e9, 0xb6f3, 0xb7af, 0xb7c2, 0xb7ce,\n    0xb8a6, 0xb8ae, 0xb8b6, 0xb8b8, 0xb8bb, 0xb8e9, 0xb9ab, 0xb9ae, 0xb9cc, 0xb9ce,\n    0xb9fd, 0xbab8, 0xbace, 0xbad0, 0xbaf1, 0xbbe7, 0xbbf3, 0xbbfd, 0xbcad, 0xbcba,\n    0xbcd2, 0xbcf6, 0xbdba, 0xbdc0, 0xbdc3, 0xbdc5, 0xbec6, 0xbec8, 0xbedf, 0xbeee,\n    0xbef8, 0xbefa, 0xbfa1, 0xbfa9, 0xbfc0, 0xbfe4, 0xbfeb, 0xbfec, 0xbff8, 0xc0a7,\n    0xc0af, 0xc0b8, 0xc0ba, 0xc0bb, 0xc0bd, 0xc0c7, 0xc0cc, 0xc0ce, 0xc0cf, 0xc0d6,\n    0xc0da, 0xc0e5, 0xc0fb, 0xc0fc, 0xc1a4, 0xc1a6, 0xc1b6, 0xc1d6, 0xc1df, 0xc1f6,\n    0xc1f8, 0xc4a1, 0xc5cd, 0xc6ae, 0xc7cf, 0xc7d1, 0xc7d2, 0xc7d8, 0xc7e5, 0xc8ad\n  ];\n\n  this.nextChar = eucNextChar;\n};\nutil.inherits(module.exports.euc_kr, mbcs);\n\n\n\n/**\n *   GB-18030 recognizer. Uses simplified Chinese statistics.\n */\nmodule.exports.gb_18030 = function() {\n  this.name = function() {\n    return 'GB18030';\n  };\n  this.language = function() {\n    return 'zh';\n  };\n\n  /*\n   *  Get the next character value for EUC based encodings.\n   *  Character 'value' is simply the raw bytes that make up the character\n   *     packed into an int.\n   */\n  this.nextChar = function(iter, det) {\n    iter.index = iter.nextIndex;\n    iter.error = false;\n    var firstByte  = 0;\n    var secondByte = 0;\n    var thirdByte  = 0;\n    var fourthByte = 0;\n    buildChar: {\n      firstByte = iter.charValue = iter.nextByte(det);\n      if (firstByte < 0) {\n        // Ran off the end of the input data\n        iter.done = true;\n        break buildChar;\n      }\n      if (firstByte <= 0x80) {\n        // single byte char\n        break buildChar;\n      }\n      secondByte = iter.nextByte(det);\n      iter.charValue = (iter.charValue << 8) | secondByte;\n      if (firstByte >= 0x81 && firstByte <= 0xFE) {\n        // Two byte Char\n        if ((secondByte >= 0x40 && secondByte <= 0x7E) || (secondByte >=80 && secondByte <= 0xFE)) {\n          break buildChar;\n        }\n        // Four byte char\n        if (secondByte >= 0x30 && secondByte <= 0x39) {\n          thirdByte = iter.nextByte(det);\n          if (thirdByte >= 0x81 && thirdByte <= 0xFE) {\n            fourthByte = iter.nextByte(det);\n            if (fourthByte >= 0x30 && fourthByte <= 0x39) {\n              iter.charValue = (iter.charValue << 16) | (thirdByte << 8) | fourthByte;\n              break buildChar;\n            }\n          }\n        }\n        iter.error = true;\n        break buildChar;\n      }\n    }\n    return iter.done == false;\n  };\n\n  // TODO:  This set of data comes from the character frequency-\n  //        of-occurence analysis tool.  The data needs to be moved\n  //        into a resource and loaded from there.\n  this.commonChars = [\n    0xa1a1, 0xa1a2, 0xa1a3, 0xa1a4, 0xa1b0, 0xa1b1, 0xa1f1, 0xa1f3, 0xa3a1, 0xa3ac,\n    0xa3ba, 0xb1a8, 0xb1b8, 0xb1be, 0xb2bb, 0xb3c9, 0xb3f6, 0xb4f3, 0xb5bd, 0xb5c4,\n    0xb5e3, 0xb6af, 0xb6d4, 0xb6e0, 0xb7a2, 0xb7a8, 0xb7bd, 0xb7d6, 0xb7dd, 0xb8b4,\n    0xb8df, 0xb8f6, 0xb9ab, 0xb9c9, 0xb9d8, 0xb9fa, 0xb9fd, 0xbacd, 0xbba7, 0xbbd6,\n    0xbbe1, 0xbbfa, 0xbcbc, 0xbcdb, 0xbcfe, 0xbdcc, 0xbecd, 0xbedd, 0xbfb4, 0xbfc6,\n    0xbfc9, 0xc0b4, 0xc0ed, 0xc1cb, 0xc2db, 0xc3c7, 0xc4dc, 0xc4ea, 0xc5cc, 0xc6f7,\n    0xc7f8, 0xc8ab, 0xc8cb, 0xc8d5, 0xc8e7, 0xc9cf, 0xc9fa, 0xcab1, 0xcab5, 0xcac7,\n    0xcad0, 0xcad6, 0xcaf5, 0xcafd, 0xccec, 0xcdf8, 0xceaa, 0xcec4, 0xced2, 0xcee5,\n    0xcfb5, 0xcfc2, 0xcfd6, 0xd0c2, 0xd0c5, 0xd0d0, 0xd0d4, 0xd1a7, 0xd2aa, 0xd2b2,\n    0xd2b5, 0xd2bb, 0xd2d4, 0xd3c3, 0xd3d0, 0xd3fd, 0xd4c2, 0xd4da, 0xd5e2, 0xd6d0\n  ];\n};\nutil.inherits(module.exports.gb_18030, mbcs);\n"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;EACxBC,KAAK,GAAGD,OAAO,CAAE,UAAU,CAAC;;AAE9B;AACA;AACA;AACA,SAASE,YAAY,CAACC,GAAG,EAAEC,WAAW,EAAE;EACtC,SAASC,IAAI,CAACF,GAAG,EAAEC,WAAW,EAAEE,IAAI,EAAEC,KAAK,EAAE;IAC3C,IAAIA,KAAK,GAAGD,IAAI,EACd,OAAO,CAAC,CAAC;;IAEX;AACJ;AACA;AACA;AACA;IACI,IAAIE,GAAG,GAAGC,IAAI,CAACC,KAAK,CAAEJ,IAAI,GAAGC,KAAK,KAAM,CAAC,CAAC;IAC1C,IAAIH,WAAW,GAAGD,GAAG,CAACK,GAAG,CAAC,EACxB,OAAOH,IAAI,CAACF,GAAG,EAAEC,WAAW,EAAEI,GAAG,GAAG,CAAC,EAAED,KAAK,CAAC;IAE/C,IAAIH,WAAW,GAAGD,GAAG,CAACK,GAAG,CAAC,EACxB,OAAOH,IAAI,CAACF,GAAG,EAAEC,WAAW,EAAEE,IAAI,EAAEE,GAAG,GAAG,CAAC,CAAC;IAE9C,OAAOA,GAAG;EACZ;EAAC;EAED,OAAOH,IAAI,CAACF,GAAG,EAAEC,WAAW,EAAE,CAAC,EAAED,GAAG,CAACQ,MAAM,GAAG,CAAC,CAAC;AAClD;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAY,GAAG;EAEtB,IAAI,CAACC,SAAS,GAAG,CAAC,CAAC,CAAC;EACpB,IAAI,CAACC,KAAK,GAAO,CAAC;EAClB,IAAI,CAACC,SAAS,GAAG,CAAC;EAClB,IAAI,CAACC,KAAK,GAAO,KAAK;EACtB,IAAI,CAACC,IAAI,GAAQ,KAAK;EAEtB,IAAI,CAACC,KAAK,GAAG,YAAW;IACtB,IAAI,CAACL,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,KAAK,GAAO,CAAC,CAAC;IACnB,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,KAAK,GAAO,KAAK;IACtB,IAAI,CAACC,IAAI,GAAQ,KAAK;EACxB,CAAC;EAED,IAAI,CAACE,QAAQ,GAAG,UAASC,GAAG,EAAE;IAC5B,IAAI,IAAI,CAACL,SAAS,IAAIK,GAAG,CAACC,UAAU,EAAE;MACpC,IAAI,CAACJ,IAAI,GAAG,IAAI;MAChB,OAAO,CAAC,CAAC;IACX;IACA,IAAIK,SAAS,GAAGF,GAAG,CAACG,SAAS,CAAC,IAAI,CAACR,SAAS,EAAE,CAAC,GAAG,MAAM;IACxD,OAAOO,SAAS;EAClB,CAAC;AACH;AAAC;;AAID;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASE,IAAI,GAAG,CAAC;AAAC;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,IAAI,CAACC,SAAS,CAACC,KAAK,GAAG,UAASN,GAAG,EAAE;EAEnC,IAAIO,mBAAmB,GAAG,CAAC;IAAG;IAC5BC,mBAAmB,GAAG,CAAC;IACvBC,eAAe,GAAO,CAAC;IACvBC,YAAY,GAAU,CAAC;IACvBC,cAAc,GAAQ,CAAC;IACvBC,UAAU,GAAY,CAAC;EAEzB,IAAIC,IAAI,GAAG,IAAIrB,YAAY,EAAE;EAE7BsB,WAAW,EAAE;IACX,KAAKD,IAAI,CAACf,KAAK,EAAE,EAAE,IAAI,CAACiB,QAAQ,CAACF,IAAI,EAAEb,GAAG,CAAC,GAAG;MAC5CW,cAAc,EAAE;MAChB,IAAIE,IAAI,CAACjB,KAAK,EAAE;QACdc,YAAY,EAAE;MAChB,CAAC,MAAM;QACL,IAAIM,EAAE,GAAGH,IAAI,CAACpB,SAAS,GAAG,UAAU;QAEpC,IAAIuB,EAAE,IAAI,IAAI,EAAE;UACdT,mBAAmB,EAAE;QACvB,CAAC,MAAM;UACLC,mBAAmB,EAAE;UACrB,IAAI,IAAI,CAACS,WAAW,IAAI,IAAI,EAAE;YAC5B;YACA,IAAInC,YAAY,CAAC,IAAI,CAACmC,WAAW,EAAED,EAAE,CAAC,IAAI,CAAC,EAAE;cAC3CP,eAAe,EAAE;YACnB;UACF;QACF;MACF;MACA,IAAIC,YAAY,IAAI,CAAC,IAAIA,YAAY,GAAG,CAAC,IAAIF,mBAAmB,EAAE;QAChE;QACA;QACA,MAAMM,WAAW;MACnB;IACF;IAEA,IAAIN,mBAAmB,IAAI,EAAE,IAAIE,YAAY,IAAG,CAAC,EAAE;MACjD;MACA,IAAIF,mBAAmB,IAAI,CAAC,IAAIG,cAAc,GAAG,EAAE,EAAE;QACnD;QACA;QACA;QACAC,UAAU,GAAG,CAAC;MAChB,CAAC,MACI;QACH;QACA;QACAA,UAAU,GAAG,EAAE;MACjB;MACA,MAAME,WAAW;IACnB;;IAEA;IACA;IACA;IACA;IACA,IAAIN,mBAAmB,GAAG,EAAE,GAAGE,YAAY,EAAE;MAC3CE,UAAU,GAAG,CAAC;MACd,MAAME,WAAW;IACnB;IAEA,IAAI,IAAI,CAACG,WAAW,IAAI,IAAI,EAAE;MAC5B;MACA;MACA;MACAL,UAAU,GAAG,EAAE,GAAGJ,mBAAmB,GAAG,EAAE,GAAGE,YAAY;MACzD,IAAIE,UAAU,GAAG,GAAG,EAAE;QACpBA,UAAU,GAAG,GAAG;MAClB;IACF,CAAC,MAAM;MACL;MACA;MACA;MACA,IAAIM,MAAM,GAAG7B,IAAI,CAAC8B,GAAG,CAACC,UAAU,CAACZ,mBAAmB,CAAC,GAAG,CAAC,CAAC;MAC1D,IAAIa,WAAW,GAAG,IAAI,GAAGH,MAAM;MAC/BN,UAAU,GAAGvB,IAAI,CAACC,KAAK,CAACD,IAAI,CAAC8B,GAAG,CAACV,eAAe,GAAG,CAAC,CAAC,GAAGY,WAAW,GAAG,EAAE,CAAC;MACzET,UAAU,GAAGvB,IAAI,CAACiC,GAAG,CAACV,UAAU,EAAE,GAAG,CAAC;IACxC;EACF,CAAC,CAAG;;EAEJ,OAAOA,UAAU,IAAI,CAAC,GAAG,IAAI,GAAG,IAAI/B,KAAK,CAACmB,GAAG,EAAE,IAAI,EAAEY,UAAU,CAAC;AAClE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAR,IAAI,CAACC,SAAS,CAACU,QAAQ,GAAG,UAASF,IAAI,EAAEb,GAAG,EAAE,CAAC,CAAC;;AAIhD;AACA;AACA;AACAuB,MAAM,CAACC,OAAO,CAACC,IAAI,GAAG,YAAW;EAC/B,IAAI,CAACC,IAAI,GAAG,YAAW;IACrB,OAAO,WAAW;EACpB,CAAC;EACD,IAAI,CAACC,QAAQ,GAAG,YAAW;IACzB,OAAO,IAAI;EACb,CAAC;;EAED;EACA;EACA;EACA,IAAI,CAACV,WAAW,GAAG,CACjB,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CACvD;EAED,IAAI,CAACF,QAAQ,GAAG,UAASF,IAAI,EAAEb,GAAG,EAAE;IAClCa,IAAI,CAACnB,KAAK,GAAGmB,IAAI,CAAClB,SAAS;IAC3BkB,IAAI,CAACjB,KAAK,GAAG,KAAK;IAElB,IAAIgC,SAAS;IACbA,SAAS,GAAGf,IAAI,CAACpB,SAAS,GAAGoB,IAAI,CAACd,QAAQ,CAACC,GAAG,CAAC;IAC/C,IAAI4B,SAAS,GAAG,CAAC,EACf,OAAO,KAAK;IAEd,IAAIA,SAAS,IAAI,IAAI,IAAKA,SAAS,GAAG,IAAI,IAAIA,SAAS,IAAI,IAAK,EAC9D,OAAO,IAAI;IAEb,IAAIC,UAAU,GAAGhB,IAAI,CAACd,QAAQ,CAACC,GAAG,CAAC;IACnC,IAAI6B,UAAU,GAAG,CAAC,EAChB,OAAO,KAAK;IAEdhB,IAAI,CAACpB,SAAS,GAAImC,SAAS,IAAI,CAAC,GAAIC,UAAU;IAC9C,IAAI,EAAIA,UAAU,IAAI,IAAI,IAAIA,UAAU,IAAI,IAAI,IAAMA,UAAU,IAAI,IAAI,IAAIA,UAAU,IAAI,IAAK,CAAC,EAAE;MAChG;MACAhB,IAAI,CAACjB,KAAK,GAAG,IAAI;IACnB;IACA,OAAO,IAAI;EACb,CAAC;AACH,CAAC;AACDjB,IAAI,CAACmD,QAAQ,CAACP,MAAM,CAACC,OAAO,CAACC,IAAI,EAAErB,IAAI,CAAC;;AAIxC;AACA;AACA;AACAmB,MAAM,CAACC,OAAO,CAACO,IAAI,GAAG,YAAW;EAC/B,IAAI,CAACL,IAAI,GAAG,YAAW;IACrB,OAAO,MAAM;EACf,CAAC;EACD,IAAI,CAACC,QAAQ,GAAG,YAAW;IACzB,OAAO,IAAI;EACb,CAAC;EACD;EACA;EACA;EACA,IAAI,CAACV,WAAW,GAAG,CACjB,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAC/C;EACD,IAAI,CAACF,QAAQ,GAAG,UAASF,IAAI,EAAEb,GAAG,EAAE;IAClCa,IAAI,CAACnB,KAAK,GAAGmB,IAAI,CAAClB,SAAS;IAC3BkB,IAAI,CAACjB,KAAK,GAAG,KAAK;IAElB,IAAIgC,SAAS,GAAGf,IAAI,CAACpB,SAAS,GAAGoB,IAAI,CAACd,QAAQ,CAACC,GAAG,CAAC;IAEnD,IAAI4B,SAAS,GAAG,CAAC,EACf,OAAO,KAAK;;IAEd;IACA,IAAIA,SAAS,IAAI,IAAI,IAAIA,SAAS,IAAI,IAAI,EACxC,OAAO,IAAI;IAEb,IAAIC,UAAU,GAAGhB,IAAI,CAACd,QAAQ,CAACC,GAAG,CAAC;IAEnC,IAAI6B,UAAU,GAAG,CAAC,EAChB,OAAO,KAAK;IAEdhB,IAAI,CAACpB,SAAS,GAAIoB,IAAI,CAACpB,SAAS,IAAI,CAAC,GAAIoC,UAAU;IAEnD,IAAIA,UAAU,GAAG,IAAI,IAAIA,UAAU,IAAI,IAAI,IAAIA,UAAU,IAAI,IAAI,EAC/DhB,IAAI,CAACjB,KAAK,GAAG,IAAI;IAEnB,OAAO,IAAI;EACb,CAAC;AACH,CAAC;AACDjB,IAAI,CAACmD,QAAQ,CAACP,MAAM,CAACC,OAAO,CAACO,IAAI,EAAE3B,IAAI,CAAC;;AAIxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS4B,WAAW,CAACnB,IAAI,EAAEb,GAAG,EAAE;EAC9Ba,IAAI,CAACnB,KAAK,GAAGmB,IAAI,CAAClB,SAAS;EAC3BkB,IAAI,CAACjB,KAAK,GAAG,KAAK;EAClB,IAAIgC,SAAS,GAAI,CAAC;EAClB,IAAIC,UAAU,GAAG,CAAC;EAClB,IAAII,SAAS,GAAI,CAAC;EAClB;EACAC,SAAS,EAAE;IACTN,SAAS,GAAGf,IAAI,CAACpB,SAAS,GAAGoB,IAAI,CAACd,QAAQ,CAACC,GAAG,CAAC;IAC/C,IAAI4B,SAAS,GAAG,CAAC,EAAE;MACjB;MACAf,IAAI,CAAChB,IAAI,GAAG,IAAI;MAChB,MAAMqC,SAAS;IACjB;IACA,IAAIN,SAAS,IAAI,IAAI,EAAE;MACrB;MACA,MAAMM,SAAS;IACjB;IACAL,UAAU,GAAGhB,IAAI,CAACd,QAAQ,CAACC,GAAG,CAAC;IAC/Ba,IAAI,CAACpB,SAAS,GAAIoB,IAAI,CAACpB,SAAS,IAAI,CAAC,GAAIoC,UAAU;IACnD,IAAID,SAAS,IAAI,IAAI,IAAIA,SAAS,IAAI,IAAI,EAAE;MAC1C;MACA,IAAIC,UAAU,GAAG,IAAI,EAAE;QACrBhB,IAAI,CAACjB,KAAK,GAAG,IAAI;MACnB;MACA,MAAMsC,SAAS;IACjB;IACA,IAAIN,SAAS,IAAI,IAAI,EAAE;MACrB;MACA;MACA;MACA;MACA;MACA;MACA,IAAIC,UAAU,GAAG,IAAI,EAAE;QACrBhB,IAAI,CAACjB,KAAK,GAAG,IAAI;MACnB;MACA,MAAMsC,SAAS;IACjB;IACA,IAAIN,SAAS,IAAI,IAAI,EAAE;MACrB;MACA;MACAK,SAAS,GAAGpB,IAAI,CAACd,QAAQ,CAACC,GAAG,CAAC;MAC9Ba,IAAI,CAACpB,SAAS,GAAIoB,IAAI,CAACpB,SAAS,IAAI,CAAC,GAAIwC,SAAS;MAClD,IAAIA,SAAS,GAAG,IAAI,EAAE;QACpBpB,IAAI,CAACjB,KAAK,GAAG,IAAI;MACnB;IACF;EACF;EACA,OAAOiB,IAAI,CAAChB,IAAI,IAAI,KAAK;AAC3B;AAAC;;AAID;AACA;AACA;AACA;AACA0B,MAAM,CAACC,OAAO,CAACW,MAAM,GAAG,YAAW;EACjC,IAAI,CAACT,IAAI,GAAG,YAAW;IACrB,OAAO,QAAQ;EACjB,CAAC;EACD,IAAI,CAACC,QAAQ,GAAG,YAAW;IACzB,OAAO,IAAI;EACb,CAAC;;EAED;EACA;EACA;EACA,IAAI,CAACV,WAAW,GAAG,CACjB,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAC/E;EAED,IAAI,CAACF,QAAQ,GAAGiB,WAAW;AAC7B,CAAC;AACDrD,IAAI,CAACmD,QAAQ,CAACP,MAAM,CAACC,OAAO,CAACW,MAAM,EAAE/B,IAAI,CAAC;;AAI1C;AACA;AACA;AACA;AACAmB,MAAM,CAACC,OAAO,CAACY,MAAM,GAAG,YAAW;EACjC,IAAI,CAACV,IAAI,GAAG,YAAW;IACrB,OAAO,QAAQ;EACjB,CAAC;EACD,IAAI,CAACC,QAAQ,GAAG,YAAW;IACzB,OAAO,IAAI;EACb,CAAC;;EAED;EACA;EACA;EACA,IAAI,CAACV,WAAW,GAAG,CACjB,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAC/E;EAED,IAAI,CAACF,QAAQ,GAAGiB,WAAW;AAC7B,CAAC;AACDrD,IAAI,CAACmD,QAAQ,CAACP,MAAM,CAACC,OAAO,CAACY,MAAM,EAAEhC,IAAI,CAAC;;AAI1C;AACA;AACA;AACAmB,MAAM,CAACC,OAAO,CAACa,QAAQ,GAAG,YAAW;EACnC,IAAI,CAACX,IAAI,GAAG,YAAW;IACrB,OAAO,SAAS;EAClB,CAAC;EACD,IAAI,CAACC,QAAQ,GAAG,YAAW;IACzB,OAAO,IAAI;EACb,CAAC;;EAED;AACF;AACA;AACA;AACA;EACE,IAAI,CAACZ,QAAQ,GAAG,UAASF,IAAI,EAAEb,GAAG,EAAE;IAClCa,IAAI,CAACnB,KAAK,GAAGmB,IAAI,CAAClB,SAAS;IAC3BkB,IAAI,CAACjB,KAAK,GAAG,KAAK;IAClB,IAAIgC,SAAS,GAAI,CAAC;IAClB,IAAIC,UAAU,GAAG,CAAC;IAClB,IAAII,SAAS,GAAI,CAAC;IAClB,IAAIK,UAAU,GAAG,CAAC;IAClBJ,SAAS,EAAE;MACTN,SAAS,GAAGf,IAAI,CAACpB,SAAS,GAAGoB,IAAI,CAACd,QAAQ,CAACC,GAAG,CAAC;MAC/C,IAAI4B,SAAS,GAAG,CAAC,EAAE;QACjB;QACAf,IAAI,CAAChB,IAAI,GAAG,IAAI;QAChB,MAAMqC,SAAS;MACjB;MACA,IAAIN,SAAS,IAAI,IAAI,EAAE;QACrB;QACA,MAAMM,SAAS;MACjB;MACAL,UAAU,GAAGhB,IAAI,CAACd,QAAQ,CAACC,GAAG,CAAC;MAC/Ba,IAAI,CAACpB,SAAS,GAAIoB,IAAI,CAACpB,SAAS,IAAI,CAAC,GAAIoC,UAAU;MACnD,IAAID,SAAS,IAAI,IAAI,IAAIA,SAAS,IAAI,IAAI,EAAE;QAC1C;QACA,IAAKC,UAAU,IAAI,IAAI,IAAIA,UAAU,IAAI,IAAI,IAAMA,UAAU,IAAG,EAAE,IAAIA,UAAU,IAAI,IAAK,EAAE;UACzF,MAAMK,SAAS;QACjB;QACA;QACA,IAAIL,UAAU,IAAI,IAAI,IAAIA,UAAU,IAAI,IAAI,EAAE;UAC5CI,SAAS,GAAGpB,IAAI,CAACd,QAAQ,CAACC,GAAG,CAAC;UAC9B,IAAIiC,SAAS,IAAI,IAAI,IAAIA,SAAS,IAAI,IAAI,EAAE;YAC1CK,UAAU,GAAGzB,IAAI,CAACd,QAAQ,CAACC,GAAG,CAAC;YAC/B,IAAIsC,UAAU,IAAI,IAAI,IAAIA,UAAU,IAAI,IAAI,EAAE;cAC5CzB,IAAI,CAACpB,SAAS,GAAIoB,IAAI,CAACpB,SAAS,IAAI,EAAE,GAAKwC,SAAS,IAAI,CAAE,GAAGK,UAAU;cACvE,MAAMJ,SAAS;YACjB;UACF;QACF;QACArB,IAAI,CAACjB,KAAK,GAAG,IAAI;QACjB,MAAMsC,SAAS;MACjB;IACF;IACA,OAAOrB,IAAI,CAAChB,IAAI,IAAI,KAAK;EAC3B,CAAC;;EAED;EACA;EACA;EACA,IAAI,CAACoB,WAAW,GAAG,CACjB,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9E,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAC/E;AACH,CAAC;AACDtC,IAAI,CAACmD,QAAQ,CAACP,MAAM,CAACC,OAAO,CAACa,QAAQ,EAAEjC,IAAI,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}