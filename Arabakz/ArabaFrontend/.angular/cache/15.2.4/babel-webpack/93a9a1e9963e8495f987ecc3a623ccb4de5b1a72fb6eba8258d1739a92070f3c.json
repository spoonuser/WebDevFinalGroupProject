{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst boolError = {\n  message: \"boolean schema is false\"\n};\nfunction topBoolOrEmptySchema(it) {\n  const {\n    gen,\n    schema,\n    validateName\n  } = it;\n  if (schema === false) {\n    falseSchemaError(it, false);\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(names_1.default.data);\n  } else {\n    gen.assign((0, codegen_1._)`${validateName}.errors`, null);\n    gen.return(true);\n  }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n  const {\n    gen,\n    schema\n  } = it;\n  if (schema === false) {\n    gen.var(valid, false); // TODO var\n    falseSchemaError(it);\n  } else {\n    gen.var(valid, true); // TODO var\n  }\n}\n\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n  const {\n    gen,\n    data\n  } = it;\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it\n  };\n  (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","boolOrEmptySchema","topBoolOrEmptySchema","errors_1","require","codegen_1","names_1","boolError","message","it","gen","schema","validateName","falseSchemaError","$async","return","default","data","assign","_","valid","var","overrideAllErrors","cxt","keyword","schemaCode","schemaValue","params","reportError","undefined"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/ajv/dist/compile/validate/boolSchema.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,iBAAiB,GAAGF,OAAO,CAACG,oBAAoB,GAAG,KAAK,CAAC;AACjE,MAAMC,QAAQ,GAAGC,OAAO,CAAC,WAAW,CAAC;AACrC,MAAMC,SAAS,GAAGD,OAAO,CAAC,YAAY,CAAC;AACvC,MAAME,OAAO,GAAGF,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMG,SAAS,GAAG;EACdC,OAAO,EAAE;AACb,CAAC;AACD,SAASN,oBAAoB,CAACO,EAAE,EAAE;EAC9B,MAAM;IAAEC,GAAG;IAAEC,MAAM;IAAEC;EAAa,CAAC,GAAGH,EAAE;EACxC,IAAIE,MAAM,KAAK,KAAK,EAAE;IAClBE,gBAAgB,CAACJ,EAAE,EAAE,KAAK,CAAC;EAC/B,CAAC,MACI,IAAI,OAAOE,MAAM,IAAI,QAAQ,IAAIA,MAAM,CAACG,MAAM,KAAK,IAAI,EAAE;IAC1DJ,GAAG,CAACK,MAAM,CAACT,OAAO,CAACU,OAAO,CAACC,IAAI,CAAC;EACpC,CAAC,MACI;IACDP,GAAG,CAACQ,MAAM,CAAC,CAAC,CAAC,EAAEb,SAAS,CAACc,CAAC,CAAG,GAAEP,YAAa,SAAQ,EAAE,IAAI,CAAC;IAC3DF,GAAG,CAACK,MAAM,CAAC,IAAI,CAAC;EACpB;AACJ;AACAhB,OAAO,CAACG,oBAAoB,GAAGA,oBAAoB;AACnD,SAASD,iBAAiB,CAACQ,EAAE,EAAEW,KAAK,EAAE;EAClC,MAAM;IAAEV,GAAG;IAAEC;EAAO,CAAC,GAAGF,EAAE;EAC1B,IAAIE,MAAM,KAAK,KAAK,EAAE;IAClBD,GAAG,CAACW,GAAG,CAACD,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;IACvBP,gBAAgB,CAACJ,EAAE,CAAC;EACxB,CAAC,MACI;IACDC,GAAG,CAACW,GAAG,CAACD,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC;EAC1B;AACJ;;AACArB,OAAO,CAACE,iBAAiB,GAAGA,iBAAiB;AAC7C,SAASY,gBAAgB,CAACJ,EAAE,EAAEa,iBAAiB,EAAE;EAC7C,MAAM;IAAEZ,GAAG;IAAEO;EAAK,CAAC,GAAGR,EAAE;EACxB;EACA,MAAMc,GAAG,GAAG;IACRb,GAAG;IACHc,OAAO,EAAE,cAAc;IACvBP,IAAI;IACJN,MAAM,EAAE,KAAK;IACbc,UAAU,EAAE,KAAK;IACjBC,WAAW,EAAE,KAAK;IAClBC,MAAM,EAAE,CAAC,CAAC;IACVlB;EACJ,CAAC;EACD,CAAC,CAAC,EAAEN,QAAQ,CAACyB,WAAW,EAAEL,GAAG,EAAEhB,SAAS,EAAEsB,SAAS,EAAEP,iBAAiB,CAAC;AAC3E"},"metadata":{},"sourceType":"script","externalDependencies":[]}