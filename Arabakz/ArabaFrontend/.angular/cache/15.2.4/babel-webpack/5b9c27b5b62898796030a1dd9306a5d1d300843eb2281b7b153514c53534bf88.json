{"ast":null,"code":"'use strict';\n\nconst util = require('./readline');\nconst cliWidth = require('cli-width');\nconst wrapAnsi = require('wrap-ansi');\nconst stripAnsi = require('strip-ansi');\nconst stringWidth = require('string-width');\nconst ora = require('ora');\nfunction height(content) {\n  return content.split('\\n').length;\n}\n\n/** @param {string} content */\nfunction lastLine(content) {\n  return content.split('\\n').pop();\n}\nclass ScreenManager {\n  constructor(rl) {\n    // These variables are keeping information to allow correct prompt re-rendering\n    this.height = 0;\n    this.extraLinesUnderPrompt = 0;\n    this.rl = rl;\n  }\n  renderWithSpinner(content, bottomContent) {\n    if (this.spinnerId) {\n      clearInterval(this.spinnerId);\n    }\n    let spinner;\n    let contentFunc;\n    let bottomContentFunc;\n    if (bottomContent) {\n      spinner = ora(bottomContent);\n      contentFunc = () => content;\n      bottomContentFunc = () => spinner.frame();\n    } else {\n      spinner = ora(content);\n      contentFunc = () => spinner.frame();\n      bottomContentFunc = () => '';\n    }\n    this.spinnerId = setInterval(() => this.render(contentFunc(), bottomContentFunc(), true), spinner.interval);\n  }\n  render(content, bottomContent, spinning = false) {\n    if (this.spinnerId && !spinning) {\n      clearInterval(this.spinnerId);\n    }\n    this.rl.output.unmute();\n    this.clean(this.extraLinesUnderPrompt);\n\n    /**\n     * Write message to screen and setPrompt to control backspace\n     */\n\n    const promptLine = lastLine(content);\n    const rawPromptLine = stripAnsi(promptLine);\n\n    // Remove the rl.line from our prompt. We can't rely on the content of\n    // rl.line (mainly because of the password prompt), so just rely on it's\n    // length.\n    let prompt = rawPromptLine;\n    if (this.rl.line.length) {\n      prompt = prompt.slice(0, -this.rl.line.length);\n    }\n    this.rl.setPrompt(prompt);\n\n    // SetPrompt will change cursor position, now we can get correct value\n    const cursorPos = this.rl._getCursorPos();\n    const width = this.normalizedCliWidth();\n    content = this.forceLineReturn(content, width);\n    if (bottomContent) {\n      bottomContent = this.forceLineReturn(bottomContent, width);\n    }\n\n    // Manually insert an extra line if we're at the end of the line.\n    // This prevent the cursor from appearing at the beginning of the\n    // current line.\n    if (rawPromptLine.length % width === 0) {\n      content += '\\n';\n    }\n    const fullContent = content + (bottomContent ? '\\n' + bottomContent : '');\n    this.rl.output.write(fullContent);\n\n    /**\n     * Re-adjust the cursor at the correct position.\n     */\n\n    // We need to consider parts of the prompt under the cursor as part of the bottom\n    // content in order to correctly cleanup and re-render.\n    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - cursorPos.rows;\n    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);\n    if (bottomContentHeight > 0) {\n      util.up(this.rl, bottomContentHeight);\n    }\n\n    // Reset cursor at the beginning of the line\n    util.left(this.rl, stringWidth(lastLine(fullContent)));\n\n    // Adjust cursor on the right\n    if (cursorPos.cols > 0) {\n      util.right(this.rl, cursorPos.cols);\n    }\n\n    /**\n     * Set up state for next re-rendering\n     */\n    this.extraLinesUnderPrompt = bottomContentHeight;\n    this.height = height(fullContent);\n    this.rl.output.mute();\n  }\n  clean(extraLines) {\n    if (extraLines > 0) {\n      util.down(this.rl, extraLines);\n    }\n    util.clearLine(this.rl, this.height);\n  }\n  done() {\n    this.rl.setPrompt('');\n    this.rl.output.unmute();\n    this.rl.output.write('\\n');\n  }\n  releaseCursor() {\n    if (this.extraLinesUnderPrompt > 0) {\n      util.down(this.rl, this.extraLinesUnderPrompt);\n    }\n  }\n  normalizedCliWidth() {\n    const width = cliWidth({\n      defaultWidth: 80,\n      output: this.rl.output\n    });\n    return width;\n  }\n\n  /**\n   * @param {string[]} lines\n   */\n  breakLines(lines, width = this.normalizedCliWidth()) {\n    // Break lines who're longer than the cli width so we can normalize the natural line\n    // returns behavior across terminals.\n    // re: trim: false; by default, `wrap-ansi` trims whitespace, which\n    // is not what we want.\n    // re: hard: true; by default', `wrap-ansi` does soft wrapping\n    return lines.map(line => wrapAnsi(line, width, {\n      trim: false,\n      hard: true\n    }).split('\\n'));\n  }\n\n  /**\n   * @param {string} content\n   */\n  forceLineReturn(content, width = this.normalizedCliWidth()) {\n    return this.breakLines(content.split('\\n'), width).flat().join('\\n');\n  }\n}\nmodule.exports = ScreenManager;","map":{"version":3,"names":["util","require","cliWidth","wrapAnsi","stripAnsi","stringWidth","ora","height","content","split","length","lastLine","pop","ScreenManager","constructor","rl","extraLinesUnderPrompt","renderWithSpinner","bottomContent","spinnerId","clearInterval","spinner","contentFunc","bottomContentFunc","frame","setInterval","render","interval","spinning","output","unmute","clean","promptLine","rawPromptLine","prompt","line","slice","setPrompt","cursorPos","_getCursorPos","width","normalizedCliWidth","forceLineReturn","fullContent","write","promptLineUpDiff","Math","floor","rows","bottomContentHeight","up","left","cols","right","mute","extraLines","down","clearLine","done","releaseCursor","defaultWidth","breakLines","lines","map","trim","hard","flat","join","module","exports"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/inquirer/lib/utils/screen-manager.js"],"sourcesContent":["'use strict';\nconst util = require('./readline');\nconst cliWidth = require('cli-width');\nconst wrapAnsi = require('wrap-ansi');\nconst stripAnsi = require('strip-ansi');\nconst stringWidth = require('string-width');\nconst ora = require('ora');\n\nfunction height(content) {\n  return content.split('\\n').length;\n}\n\n/** @param {string} content */\nfunction lastLine(content) {\n  return content.split('\\n').pop();\n}\n\nclass ScreenManager {\n  constructor(rl) {\n    // These variables are keeping information to allow correct prompt re-rendering\n    this.height = 0;\n    this.extraLinesUnderPrompt = 0;\n\n    this.rl = rl;\n  }\n\n  renderWithSpinner(content, bottomContent) {\n    if (this.spinnerId) {\n      clearInterval(this.spinnerId);\n    }\n\n    let spinner;\n    let contentFunc;\n    let bottomContentFunc;\n\n    if (bottomContent) {\n      spinner = ora(bottomContent);\n      contentFunc = () => content;\n      bottomContentFunc = () => spinner.frame();\n    } else {\n      spinner = ora(content);\n      contentFunc = () => spinner.frame();\n      bottomContentFunc = () => '';\n    }\n\n    this.spinnerId = setInterval(\n      () => this.render(contentFunc(), bottomContentFunc(), true),\n      spinner.interval\n    );\n  }\n\n  render(content, bottomContent, spinning = false) {\n    if (this.spinnerId && !spinning) {\n      clearInterval(this.spinnerId);\n    }\n\n    this.rl.output.unmute();\n    this.clean(this.extraLinesUnderPrompt);\n\n    /**\n     * Write message to screen and setPrompt to control backspace\n     */\n\n    const promptLine = lastLine(content);\n    const rawPromptLine = stripAnsi(promptLine);\n\n    // Remove the rl.line from our prompt. We can't rely on the content of\n    // rl.line (mainly because of the password prompt), so just rely on it's\n    // length.\n    let prompt = rawPromptLine;\n    if (this.rl.line.length) {\n      prompt = prompt.slice(0, -this.rl.line.length);\n    }\n\n    this.rl.setPrompt(prompt);\n\n    // SetPrompt will change cursor position, now we can get correct value\n    const cursorPos = this.rl._getCursorPos();\n    const width = this.normalizedCliWidth();\n\n    content = this.forceLineReturn(content, width);\n    if (bottomContent) {\n      bottomContent = this.forceLineReturn(bottomContent, width);\n    }\n\n    // Manually insert an extra line if we're at the end of the line.\n    // This prevent the cursor from appearing at the beginning of the\n    // current line.\n    if (rawPromptLine.length % width === 0) {\n      content += '\\n';\n    }\n\n    const fullContent = content + (bottomContent ? '\\n' + bottomContent : '');\n    this.rl.output.write(fullContent);\n\n    /**\n     * Re-adjust the cursor at the correct position.\n     */\n\n    // We need to consider parts of the prompt under the cursor as part of the bottom\n    // content in order to correctly cleanup and re-render.\n    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - cursorPos.rows;\n    const bottomContentHeight =\n      promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);\n    if (bottomContentHeight > 0) {\n      util.up(this.rl, bottomContentHeight);\n    }\n\n    // Reset cursor at the beginning of the line\n    util.left(this.rl, stringWidth(lastLine(fullContent)));\n\n    // Adjust cursor on the right\n    if (cursorPos.cols > 0) {\n      util.right(this.rl, cursorPos.cols);\n    }\n\n    /**\n     * Set up state for next re-rendering\n     */\n    this.extraLinesUnderPrompt = bottomContentHeight;\n    this.height = height(fullContent);\n\n    this.rl.output.mute();\n  }\n\n  clean(extraLines) {\n    if (extraLines > 0) {\n      util.down(this.rl, extraLines);\n    }\n\n    util.clearLine(this.rl, this.height);\n  }\n\n  done() {\n    this.rl.setPrompt('');\n    this.rl.output.unmute();\n    this.rl.output.write('\\n');\n  }\n\n  releaseCursor() {\n    if (this.extraLinesUnderPrompt > 0) {\n      util.down(this.rl, this.extraLinesUnderPrompt);\n    }\n  }\n\n  normalizedCliWidth() {\n    const width = cliWidth({\n      defaultWidth: 80,\n      output: this.rl.output,\n    });\n    return width;\n  }\n\n  /**\n   * @param {string[]} lines\n   */\n  breakLines(lines, width = this.normalizedCliWidth()) {\n    // Break lines who're longer than the cli width so we can normalize the natural line\n    // returns behavior across terminals.\n    // re: trim: false; by default, `wrap-ansi` trims whitespace, which\n    // is not what we want.\n    // re: hard: true; by default', `wrap-ansi` does soft wrapping\n    return lines.map((line) =>\n      wrapAnsi(line, width, { trim: false, hard: true }).split('\\n')\n    );\n  }\n\n  /**\n   * @param {string} content\n   */\n  forceLineReturn(content, width = this.normalizedCliWidth()) {\n    return this.breakLines(content.split('\\n'), width).flat().join('\\n');\n  }\n}\n\nmodule.exports = ScreenManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}