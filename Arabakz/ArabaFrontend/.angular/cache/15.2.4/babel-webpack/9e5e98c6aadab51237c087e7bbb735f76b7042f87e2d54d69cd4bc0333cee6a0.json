{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CordHost = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst exception_1 = require(\"../../exception\");\nconst memory_1 = require(\"./memory\");\n/**\n * A Host that records changes to the underlying Host, while keeping a record of Create, Overwrite,\n * Rename and Delete of files.\n *\n * This is fully compatible with Host, but will keep a staging of every changes asked. That staging\n * follows the principle of the Tree (e.g. can create a file that already exists).\n *\n * Using `create()` and `overwrite()` will force those operations, but using `write` will add\n * the create/overwrite records IIF the files does/doesn't already exist.\n */\nclass CordHost extends memory_1.SimpleMemoryHost {\n  constructor(_back) {\n    super();\n    this._back = _back;\n    this._filesToCreate = new Set();\n    this._filesToRename = new Map();\n    this._filesToRenameRevert = new Map();\n    this._filesToDelete = new Set();\n    this._filesToOverwrite = new Set();\n  }\n  get backend() {\n    return this._back;\n  }\n  get capabilities() {\n    // Our own host is always Synchronous, but the backend might not be.\n    return {\n      synchronous: this._back.capabilities.synchronous\n    };\n  }\n  /**\n   * Create a copy of this host, including all actions made.\n   * @returns {CordHost} The carbon copy.\n   */\n  clone() {\n    const dolly = new CordHost(this._back);\n    dolly._cache = new Map(this._cache);\n    dolly._filesToCreate = new Set(this._filesToCreate);\n    dolly._filesToRename = new Map(this._filesToRename);\n    dolly._filesToRenameRevert = new Map(this._filesToRenameRevert);\n    dolly._filesToDelete = new Set(this._filesToDelete);\n    dolly._filesToOverwrite = new Set(this._filesToOverwrite);\n    return dolly;\n  }\n  /**\n   * Commit the changes recorded to a Host. It is assumed that the host does have the same structure\n   * as the host that was used for backend (could be the same host).\n   * @param host The host to create/delete/rename/overwrite files to.\n   * @param force Whether to skip existence checks when creating/overwriting. This is\n   *   faster but might lead to incorrect states. Because Hosts natively don't support creation\n   *   versus overwriting (it's only writing), we check for existence before completing a request.\n   * @returns An observable that completes when done, or error if an error occured.\n   */\n  commit(host, force = false) {\n    // Really commit everything to the actual host.\n    return (0, rxjs_1.from)(this.records()).pipe((0, operators_1.concatMap)(record => {\n      switch (record.kind) {\n        case 'delete':\n          return host.delete(record.path);\n        case 'rename':\n          return host.rename(record.from, record.to);\n        case 'create':\n          return host.exists(record.path).pipe((0, operators_1.switchMap)(exists => {\n            if (exists && !force) {\n              return (0, rxjs_1.throwError)(new exception_1.FileAlreadyExistException(record.path));\n            } else {\n              return host.write(record.path, record.content);\n            }\n          }));\n        case 'overwrite':\n          return host.exists(record.path).pipe((0, operators_1.switchMap)(exists => {\n            if (!exists && !force) {\n              return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(record.path));\n            } else {\n              return host.write(record.path, record.content);\n            }\n          }));\n      }\n    }), (0, operators_1.reduce)(() => {}));\n  }\n  records() {\n    return [...[...this._filesToDelete.values()].map(path => ({\n      kind: 'delete',\n      path\n    })), ...[...this._filesToRename.entries()].map(([from, to]) => ({\n      kind: 'rename',\n      from,\n      to\n    })), ...[...this._filesToCreate.values()].map(path => ({\n      kind: 'create',\n      path,\n      content: this._read(path)\n    })), ...[...this._filesToOverwrite.values()].map(path => ({\n      kind: 'overwrite',\n      path,\n      content: this._read(path)\n    }))];\n  }\n  /**\n   * Specialized version of {@link CordHost#write} which forces the creation of a file whether it\n   * exists or not.\n   * @param {} path\n   * @param {FileBuffer} content\n   * @returns {Observable<void>}\n   */\n  create(path, content) {\n    if (super._exists(path)) {\n      throw new exception_1.FileAlreadyExistException(path);\n    }\n    if (this._filesToDelete.has(path)) {\n      this._filesToDelete.delete(path);\n      this._filesToOverwrite.add(path);\n    } else {\n      this._filesToCreate.add(path);\n    }\n    return super.write(path, content);\n  }\n  overwrite(path, content) {\n    return this.isDirectory(path).pipe((0, operators_1.switchMap)(isDir => {\n      if (isDir) {\n        return (0, rxjs_1.throwError)(new exception_1.PathIsDirectoryException(path));\n      }\n      return this.exists(path);\n    }), (0, operators_1.switchMap)(exists => {\n      if (!exists) {\n        return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(path));\n      }\n      if (!this._filesToCreate.has(path)) {\n        this._filesToOverwrite.add(path);\n      }\n      return super.write(path, content);\n    }));\n  }\n  write(path, content) {\n    return this.exists(path).pipe((0, operators_1.switchMap)(exists => {\n      if (exists) {\n        // It exists, but might be being renamed or deleted. In that case we want to create it.\n        if (this.willRename(path) || this.willDelete(path)) {\n          return this.create(path, content);\n        } else {\n          return this.overwrite(path, content);\n        }\n      } else {\n        return this.create(path, content);\n      }\n    }));\n  }\n  read(path) {\n    if (this._exists(path)) {\n      return super.read(path);\n    }\n    return this._back.read(path);\n  }\n  delete(path) {\n    if (this._exists(path)) {\n      if (this._filesToCreate.has(path)) {\n        this._filesToCreate.delete(path);\n      } else if (this._filesToOverwrite.has(path)) {\n        this._filesToOverwrite.delete(path);\n        this._filesToDelete.add(path);\n      } else {\n        const maybeOrigin = this._filesToRenameRevert.get(path);\n        if (maybeOrigin) {\n          this._filesToRenameRevert.delete(path);\n          this._filesToRename.delete(maybeOrigin);\n          this._filesToDelete.add(maybeOrigin);\n        } else {\n          return (0, rxjs_1.throwError)(new exception_1.UnknownException(`This should never happen. Path: ${JSON.stringify(path)}.`));\n        }\n      }\n      return super.delete(path);\n    } else {\n      return this._back.exists(path).pipe((0, operators_1.switchMap)(exists => {\n        if (exists) {\n          this._filesToDelete.add(path);\n          return (0, rxjs_1.of)();\n        } else {\n          return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(path));\n        }\n      }));\n    }\n  }\n  rename(from, to) {\n    return (0, rxjs_1.concat)(this.exists(to), this.exists(from)).pipe((0, operators_1.toArray)(), (0, operators_1.switchMap)(([existTo, existFrom]) => {\n      if (!existFrom) {\n        return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(from));\n      }\n      if (from === to) {\n        return rxjs_1.EMPTY;\n      }\n      if (existTo) {\n        return (0, rxjs_1.throwError)(new exception_1.FileAlreadyExistException(to));\n      }\n      // If we're renaming a file that's been created, shortcircuit to creating the `to` path.\n      if (this._filesToCreate.has(from)) {\n        this._filesToCreate.delete(from);\n        this._filesToCreate.add(to);\n        return super.rename(from, to);\n      }\n      if (this._filesToOverwrite.has(from)) {\n        this._filesToOverwrite.delete(from);\n        // Recursively call this function. This is so we don't repeat the bottom logic. This\n        // if will be by-passed because we just deleted the `from` path from files to overwrite.\n        return (0, rxjs_1.concat)(this.rename(from, to), new rxjs_1.Observable(x => {\n          this._filesToOverwrite.add(to);\n          x.complete();\n        }));\n      }\n      if (this._filesToDelete.has(to)) {\n        this._filesToDelete.delete(to);\n        this._filesToDelete.add(from);\n        this._filesToOverwrite.add(to);\n        // We need to delete the original and write the new one.\n        return this.read(from).pipe((0, operators_1.map)(content => this._write(to, content)));\n      }\n      const maybeTo1 = this._filesToRenameRevert.get(from);\n      if (maybeTo1) {\n        // We already renamed to this file (A => from), let's rename the former to the new\n        // path (A => to).\n        this._filesToRename.delete(maybeTo1);\n        this._filesToRenameRevert.delete(from);\n        from = maybeTo1;\n      }\n      this._filesToRename.set(from, to);\n      this._filesToRenameRevert.set(to, from);\n      // If the file is part of our data, just rename it internally.\n      if (this._exists(from)) {\n        return super.rename(from, to);\n      } else {\n        // Create a file with the same content.\n        return this._back.read(from).pipe((0, operators_1.switchMap)(content => super.write(to, content)));\n      }\n    }));\n  }\n  list(path) {\n    return (0, rxjs_1.concat)(super.list(path), this._back.list(path)).pipe((0, operators_1.reduce)((list, curr) => {\n      curr.forEach(elem => list.add(elem));\n      return list;\n    }, new Set()), (0, operators_1.map)(set => [...set]));\n  }\n  exists(path) {\n    return this._exists(path) ? (0, rxjs_1.of)(true) : this.willDelete(path) || this.willRename(path) ? (0, rxjs_1.of)(false) : this._back.exists(path);\n  }\n  isDirectory(path) {\n    return this._exists(path) ? super.isDirectory(path) : this._back.isDirectory(path);\n  }\n  isFile(path) {\n    return this._exists(path) ? super.isFile(path) : this.willDelete(path) || this.willRename(path) ? (0, rxjs_1.of)(false) : this._back.isFile(path);\n  }\n  stat(path) {\n    return this._exists(path) ? super.stat(path) : this.willDelete(path) || this.willRename(path) ? (0, rxjs_1.of)(null) : this._back.stat(path);\n  }\n  watch(path, options) {\n    // Watching not supported.\n    return null;\n  }\n  willCreate(path) {\n    return this._filesToCreate.has(path);\n  }\n  willOverwrite(path) {\n    return this._filesToOverwrite.has(path);\n  }\n  willDelete(path) {\n    return this._filesToDelete.has(path);\n  }\n  willRename(path) {\n    return this._filesToRename.has(path);\n  }\n  willRenameTo(path, to) {\n    return this._filesToRename.get(path) === to;\n  }\n}\nexports.CordHost = CordHost;","map":{"version":3,"names":["Object","defineProperty","exports","value","CordHost","rxjs_1","require","operators_1","exception_1","memory_1","SimpleMemoryHost","constructor","_back","_filesToCreate","Set","_filesToRename","Map","_filesToRenameRevert","_filesToDelete","_filesToOverwrite","backend","capabilities","synchronous","clone","dolly","_cache","commit","host","force","from","records","pipe","concatMap","record","kind","delete","path","rename","to","exists","switchMap","throwError","FileAlreadyExistException","write","content","FileDoesNotExistException","reduce","values","map","entries","_read","create","_exists","has","add","overwrite","isDirectory","isDir","PathIsDirectoryException","willRename","willDelete","read","maybeOrigin","get","UnknownException","JSON","stringify","of","concat","toArray","existTo","existFrom","EMPTY","Observable","x","complete","_write","maybeTo1","set","list","curr","forEach","elem","isFile","stat","watch","options","willCreate","willOverwrite","willRenameTo"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/node_modules/@angular-devkit/core/src/virtual-fs/host/record.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CordHost = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst exception_1 = require(\"../../exception\");\nconst memory_1 = require(\"./memory\");\n/**\n * A Host that records changes to the underlying Host, while keeping a record of Create, Overwrite,\n * Rename and Delete of files.\n *\n * This is fully compatible with Host, but will keep a staging of every changes asked. That staging\n * follows the principle of the Tree (e.g. can create a file that already exists).\n *\n * Using `create()` and `overwrite()` will force those operations, but using `write` will add\n * the create/overwrite records IIF the files does/doesn't already exist.\n */\nclass CordHost extends memory_1.SimpleMemoryHost {\n    constructor(_back) {\n        super();\n        this._back = _back;\n        this._filesToCreate = new Set();\n        this._filesToRename = new Map();\n        this._filesToRenameRevert = new Map();\n        this._filesToDelete = new Set();\n        this._filesToOverwrite = new Set();\n    }\n    get backend() {\n        return this._back;\n    }\n    get capabilities() {\n        // Our own host is always Synchronous, but the backend might not be.\n        return {\n            synchronous: this._back.capabilities.synchronous,\n        };\n    }\n    /**\n     * Create a copy of this host, including all actions made.\n     * @returns {CordHost} The carbon copy.\n     */\n    clone() {\n        const dolly = new CordHost(this._back);\n        dolly._cache = new Map(this._cache);\n        dolly._filesToCreate = new Set(this._filesToCreate);\n        dolly._filesToRename = new Map(this._filesToRename);\n        dolly._filesToRenameRevert = new Map(this._filesToRenameRevert);\n        dolly._filesToDelete = new Set(this._filesToDelete);\n        dolly._filesToOverwrite = new Set(this._filesToOverwrite);\n        return dolly;\n    }\n    /**\n     * Commit the changes recorded to a Host. It is assumed that the host does have the same structure\n     * as the host that was used for backend (could be the same host).\n     * @param host The host to create/delete/rename/overwrite files to.\n     * @param force Whether to skip existence checks when creating/overwriting. This is\n     *   faster but might lead to incorrect states. Because Hosts natively don't support creation\n     *   versus overwriting (it's only writing), we check for existence before completing a request.\n     * @returns An observable that completes when done, or error if an error occured.\n     */\n    commit(host, force = false) {\n        // Really commit everything to the actual host.\n        return (0, rxjs_1.from)(this.records()).pipe((0, operators_1.concatMap)((record) => {\n            switch (record.kind) {\n                case 'delete':\n                    return host.delete(record.path);\n                case 'rename':\n                    return host.rename(record.from, record.to);\n                case 'create':\n                    return host.exists(record.path).pipe((0, operators_1.switchMap)((exists) => {\n                        if (exists && !force) {\n                            return (0, rxjs_1.throwError)(new exception_1.FileAlreadyExistException(record.path));\n                        }\n                        else {\n                            return host.write(record.path, record.content);\n                        }\n                    }));\n                case 'overwrite':\n                    return host.exists(record.path).pipe((0, operators_1.switchMap)((exists) => {\n                        if (!exists && !force) {\n                            return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(record.path));\n                        }\n                        else {\n                            return host.write(record.path, record.content);\n                        }\n                    }));\n            }\n        }), (0, operators_1.reduce)(() => { }));\n    }\n    records() {\n        return [\n            ...[...this._filesToDelete.values()].map((path) => ({\n                kind: 'delete',\n                path,\n            })),\n            ...[...this._filesToRename.entries()].map(([from, to]) => ({\n                kind: 'rename',\n                from,\n                to,\n            })),\n            ...[...this._filesToCreate.values()].map((path) => ({\n                kind: 'create',\n                path,\n                content: this._read(path),\n            })),\n            ...[...this._filesToOverwrite.values()].map((path) => ({\n                kind: 'overwrite',\n                path,\n                content: this._read(path),\n            })),\n        ];\n    }\n    /**\n     * Specialized version of {@link CordHost#write} which forces the creation of a file whether it\n     * exists or not.\n     * @param {} path\n     * @param {FileBuffer} content\n     * @returns {Observable<void>}\n     */\n    create(path, content) {\n        if (super._exists(path)) {\n            throw new exception_1.FileAlreadyExistException(path);\n        }\n        if (this._filesToDelete.has(path)) {\n            this._filesToDelete.delete(path);\n            this._filesToOverwrite.add(path);\n        }\n        else {\n            this._filesToCreate.add(path);\n        }\n        return super.write(path, content);\n    }\n    overwrite(path, content) {\n        return this.isDirectory(path).pipe((0, operators_1.switchMap)((isDir) => {\n            if (isDir) {\n                return (0, rxjs_1.throwError)(new exception_1.PathIsDirectoryException(path));\n            }\n            return this.exists(path);\n        }), (0, operators_1.switchMap)((exists) => {\n            if (!exists) {\n                return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(path));\n            }\n            if (!this._filesToCreate.has(path)) {\n                this._filesToOverwrite.add(path);\n            }\n            return super.write(path, content);\n        }));\n    }\n    write(path, content) {\n        return this.exists(path).pipe((0, operators_1.switchMap)((exists) => {\n            if (exists) {\n                // It exists, but might be being renamed or deleted. In that case we want to create it.\n                if (this.willRename(path) || this.willDelete(path)) {\n                    return this.create(path, content);\n                }\n                else {\n                    return this.overwrite(path, content);\n                }\n            }\n            else {\n                return this.create(path, content);\n            }\n        }));\n    }\n    read(path) {\n        if (this._exists(path)) {\n            return super.read(path);\n        }\n        return this._back.read(path);\n    }\n    delete(path) {\n        if (this._exists(path)) {\n            if (this._filesToCreate.has(path)) {\n                this._filesToCreate.delete(path);\n            }\n            else if (this._filesToOverwrite.has(path)) {\n                this._filesToOverwrite.delete(path);\n                this._filesToDelete.add(path);\n            }\n            else {\n                const maybeOrigin = this._filesToRenameRevert.get(path);\n                if (maybeOrigin) {\n                    this._filesToRenameRevert.delete(path);\n                    this._filesToRename.delete(maybeOrigin);\n                    this._filesToDelete.add(maybeOrigin);\n                }\n                else {\n                    return (0, rxjs_1.throwError)(new exception_1.UnknownException(`This should never happen. Path: ${JSON.stringify(path)}.`));\n                }\n            }\n            return super.delete(path);\n        }\n        else {\n            return this._back.exists(path).pipe((0, operators_1.switchMap)((exists) => {\n                if (exists) {\n                    this._filesToDelete.add(path);\n                    return (0, rxjs_1.of)();\n                }\n                else {\n                    return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(path));\n                }\n            }));\n        }\n    }\n    rename(from, to) {\n        return (0, rxjs_1.concat)(this.exists(to), this.exists(from)).pipe((0, operators_1.toArray)(), (0, operators_1.switchMap)(([existTo, existFrom]) => {\n            if (!existFrom) {\n                return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(from));\n            }\n            if (from === to) {\n                return rxjs_1.EMPTY;\n            }\n            if (existTo) {\n                return (0, rxjs_1.throwError)(new exception_1.FileAlreadyExistException(to));\n            }\n            // If we're renaming a file that's been created, shortcircuit to creating the `to` path.\n            if (this._filesToCreate.has(from)) {\n                this._filesToCreate.delete(from);\n                this._filesToCreate.add(to);\n                return super.rename(from, to);\n            }\n            if (this._filesToOverwrite.has(from)) {\n                this._filesToOverwrite.delete(from);\n                // Recursively call this function. This is so we don't repeat the bottom logic. This\n                // if will be by-passed because we just deleted the `from` path from files to overwrite.\n                return (0, rxjs_1.concat)(this.rename(from, to), new rxjs_1.Observable((x) => {\n                    this._filesToOverwrite.add(to);\n                    x.complete();\n                }));\n            }\n            if (this._filesToDelete.has(to)) {\n                this._filesToDelete.delete(to);\n                this._filesToDelete.add(from);\n                this._filesToOverwrite.add(to);\n                // We need to delete the original and write the new one.\n                return this.read(from).pipe((0, operators_1.map)((content) => this._write(to, content)));\n            }\n            const maybeTo1 = this._filesToRenameRevert.get(from);\n            if (maybeTo1) {\n                // We already renamed to this file (A => from), let's rename the former to the new\n                // path (A => to).\n                this._filesToRename.delete(maybeTo1);\n                this._filesToRenameRevert.delete(from);\n                from = maybeTo1;\n            }\n            this._filesToRename.set(from, to);\n            this._filesToRenameRevert.set(to, from);\n            // If the file is part of our data, just rename it internally.\n            if (this._exists(from)) {\n                return super.rename(from, to);\n            }\n            else {\n                // Create a file with the same content.\n                return this._back.read(from).pipe((0, operators_1.switchMap)((content) => super.write(to, content)));\n            }\n        }));\n    }\n    list(path) {\n        return (0, rxjs_1.concat)(super.list(path), this._back.list(path)).pipe((0, operators_1.reduce)((list, curr) => {\n            curr.forEach((elem) => list.add(elem));\n            return list;\n        }, new Set()), (0, operators_1.map)((set) => [...set]));\n    }\n    exists(path) {\n        return this._exists(path)\n            ? (0, rxjs_1.of)(true)\n            : this.willDelete(path) || this.willRename(path)\n                ? (0, rxjs_1.of)(false)\n                : this._back.exists(path);\n    }\n    isDirectory(path) {\n        return this._exists(path) ? super.isDirectory(path) : this._back.isDirectory(path);\n    }\n    isFile(path) {\n        return this._exists(path)\n            ? super.isFile(path)\n            : this.willDelete(path) || this.willRename(path)\n                ? (0, rxjs_1.of)(false)\n                : this._back.isFile(path);\n    }\n    stat(path) {\n        return this._exists(path)\n            ? super.stat(path)\n            : this.willDelete(path) || this.willRename(path)\n                ? (0, rxjs_1.of)(null)\n                : this._back.stat(path);\n    }\n    watch(path, options) {\n        // Watching not supported.\n        return null;\n    }\n    willCreate(path) {\n        return this._filesToCreate.has(path);\n    }\n    willOverwrite(path) {\n        return this._filesToOverwrite.has(path);\n    }\n    willDelete(path) {\n        return this._filesToDelete.has(path);\n    }\n    willRename(path) {\n        return this._filesToRename.has(path);\n    }\n    willRenameTo(path, to) {\n        return this._filesToRename.get(path) === to;\n    }\n}\nexports.CordHost = CordHost;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}