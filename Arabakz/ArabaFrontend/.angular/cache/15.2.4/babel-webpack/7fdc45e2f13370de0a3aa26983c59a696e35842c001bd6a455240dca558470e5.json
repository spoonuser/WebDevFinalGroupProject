{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.schematic = exports.externalSchematic = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst interface_1 = require(\"../tree/interface\");\nconst static_1 = require(\"../tree/static\");\n/**\n * Run a schematic from a separate collection.\n *\n * @param collectionName The name of the collection that contains the schematic to run.\n * @param schematicName The name of the schematic to run.\n * @param options The options to pass as input to the RuleFactory.\n */\nfunction externalSchematic(collectionName, schematicName, options, executionOptions) {\n  return (input, context) => {\n    const collection = context.engine.createCollection(collectionName, context.schematic.collection);\n    const schematic = collection.createSchematic(schematicName);\n    return schematic.call(options, (0, rxjs_1.of)((0, static_1.branch)(input)), context, executionOptions).pipe((0, operators_1.last)(), (0, operators_1.map)(x => {\n      input.merge(x, interface_1.MergeStrategy.AllowOverwriteConflict);\n      return input;\n    }));\n  };\n}\nexports.externalSchematic = externalSchematic;\n/**\n * Run a schematic from the same collection.\n *\n * @param schematicName The name of the schematic to run.\n * @param options The options to pass as input to the RuleFactory.\n */\nfunction schematic(schematicName, options, executionOptions) {\n  return (input, context) => {\n    const collection = context.schematic.collection;\n    const schematic = collection.createSchematic(schematicName, true);\n    return schematic.call(options, (0, rxjs_1.of)((0, static_1.branch)(input)), context, executionOptions).pipe((0, operators_1.last)(), (0, operators_1.map)(x => {\n      // We allow overwrite conflict here because they're the only merge conflict we particularly\n      // don't want to deal with; the input tree might have an OVERWRITE which the sub\n      input.merge(x, interface_1.MergeStrategy.AllowOverwriteConflict);\n      return input;\n    }));\n  };\n}\nexports.schematic = schematic;","map":{"version":3,"names":["Object","defineProperty","exports","value","schematic","externalSchematic","rxjs_1","require","operators_1","interface_1","static_1","collectionName","schematicName","options","executionOptions","input","context","collection","engine","createCollection","createSchematic","call","of","branch","pipe","last","map","x","merge","MergeStrategy","AllowOverwriteConflict"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular-devkit/schematics/src/rules/schematic.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.schematic = exports.externalSchematic = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst interface_1 = require(\"../tree/interface\");\nconst static_1 = require(\"../tree/static\");\n/**\n * Run a schematic from a separate collection.\n *\n * @param collectionName The name of the collection that contains the schematic to run.\n * @param schematicName The name of the schematic to run.\n * @param options The options to pass as input to the RuleFactory.\n */\nfunction externalSchematic(collectionName, schematicName, options, executionOptions) {\n    return (input, context) => {\n        const collection = context.engine.createCollection(collectionName, context.schematic.collection);\n        const schematic = collection.createSchematic(schematicName);\n        return schematic.call(options, (0, rxjs_1.of)((0, static_1.branch)(input)), context, executionOptions).pipe((0, operators_1.last)(), (0, operators_1.map)((x) => {\n            input.merge(x, interface_1.MergeStrategy.AllowOverwriteConflict);\n            return input;\n        }));\n    };\n}\nexports.externalSchematic = externalSchematic;\n/**\n * Run a schematic from the same collection.\n *\n * @param schematicName The name of the schematic to run.\n * @param options The options to pass as input to the RuleFactory.\n */\nfunction schematic(schematicName, options, executionOptions) {\n    return (input, context) => {\n        const collection = context.schematic.collection;\n        const schematic = collection.createSchematic(schematicName, true);\n        return schematic.call(options, (0, rxjs_1.of)((0, static_1.branch)(input)), context, executionOptions).pipe((0, operators_1.last)(), (0, operators_1.map)((x) => {\n            // We allow overwrite conflict here because they're the only merge conflict we particularly\n            // don't want to deal with; the input tree might have an OVERWRITE which the sub\n            input.merge(x, interface_1.MergeStrategy.AllowOverwriteConflict);\n            return input;\n        }));\n    };\n}\nexports.schematic = schematic;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,SAAS,GAAGF,OAAO,CAACG,iBAAiB,GAAG,KAAK,CAAC;AACtD,MAAMC,MAAM,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC9B,MAAMC,WAAW,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAC7C,MAAME,WAAW,GAAGF,OAAO,CAAC,mBAAmB,CAAC;AAChD,MAAMG,QAAQ,GAAGH,OAAO,CAAC,gBAAgB,CAAC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASF,iBAAiB,CAACM,cAAc,EAAEC,aAAa,EAAEC,OAAO,EAAEC,gBAAgB,EAAE;EACjF,OAAO,CAACC,KAAK,EAAEC,OAAO,KAAK;IACvB,MAAMC,UAAU,GAAGD,OAAO,CAACE,MAAM,CAACC,gBAAgB,CAACR,cAAc,EAAEK,OAAO,CAACZ,SAAS,CAACa,UAAU,CAAC;IAChG,MAAMb,SAAS,GAAGa,UAAU,CAACG,eAAe,CAACR,aAAa,CAAC;IAC3D,OAAOR,SAAS,CAACiB,IAAI,CAACR,OAAO,EAAE,CAAC,CAAC,EAAEP,MAAM,CAACgB,EAAE,EAAE,CAAC,CAAC,EAAEZ,QAAQ,CAACa,MAAM,EAAER,KAAK,CAAC,CAAC,EAAEC,OAAO,EAAEF,gBAAgB,CAAC,CAACU,IAAI,CAAC,CAAC,CAAC,EAAEhB,WAAW,CAACiB,IAAI,GAAG,EAAE,CAAC,CAAC,EAAEjB,WAAW,CAACkB,GAAG,EAAGC,CAAC,IAAK;MAC7JZ,KAAK,CAACa,KAAK,CAACD,CAAC,EAAElB,WAAW,CAACoB,aAAa,CAACC,sBAAsB,CAAC;MAChE,OAAOf,KAAK;IAChB,CAAC,CAAC,CAAC;EACP,CAAC;AACL;AACAb,OAAO,CAACG,iBAAiB,GAAGA,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,SAAS,CAACQ,aAAa,EAAEC,OAAO,EAAEC,gBAAgB,EAAE;EACzD,OAAO,CAACC,KAAK,EAAEC,OAAO,KAAK;IACvB,MAAMC,UAAU,GAAGD,OAAO,CAACZ,SAAS,CAACa,UAAU;IAC/C,MAAMb,SAAS,GAAGa,UAAU,CAACG,eAAe,CAACR,aAAa,EAAE,IAAI,CAAC;IACjE,OAAOR,SAAS,CAACiB,IAAI,CAACR,OAAO,EAAE,CAAC,CAAC,EAAEP,MAAM,CAACgB,EAAE,EAAE,CAAC,CAAC,EAAEZ,QAAQ,CAACa,MAAM,EAAER,KAAK,CAAC,CAAC,EAAEC,OAAO,EAAEF,gBAAgB,CAAC,CAACU,IAAI,CAAC,CAAC,CAAC,EAAEhB,WAAW,CAACiB,IAAI,GAAG,EAAE,CAAC,CAAC,EAAEjB,WAAW,CAACkB,GAAG,EAAGC,CAAC,IAAK;MAC7J;MACA;MACAZ,KAAK,CAACa,KAAK,CAACD,CAAC,EAAElB,WAAW,CAACoB,aAAa,CAACC,sBAAsB,CAAC;MAChE,OAAOf,KAAK;IAChB,CAAC,CAAC,CAAC;EACP,CAAC;AACL;AACAb,OAAO,CAACE,SAAS,GAAGA,SAAS"},"metadata":{},"sourceType":"script","externalDependencies":[]}