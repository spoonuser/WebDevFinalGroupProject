{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateTuple = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst def = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt) {\n    const {\n      schema,\n      it\n    } = cxt;\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema);\n    it.items = true;\n    if ((0, util_1.alwaysValidSchema)(it, schema)) return;\n    cxt.ok((0, code_1.validateArray)(cxt));\n  }\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n  const {\n    gen,\n    parentSchema,\n    data,\n    keyword,\n    it\n  } = cxt;\n  checkStrictTuple(parentSchema);\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n  }\n  const valid = gen.name(\"valid\");\n  const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n  schArr.forEach((sch, i) => {\n    if ((0, util_1.alwaysValidSchema)(it, sch)) return;\n    gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({\n      keyword,\n      schemaProp: i,\n      dataProp: i\n    }, valid));\n    cxt.ok(valid);\n  });\n  function checkStrictTuple(sch) {\n    const {\n      opts,\n      errSchemaPath\n    } = it;\n    const l = schArr.length;\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n      (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n    }\n  }\n}\nexports.validateTuple = validateTuple;\nexports.default = def;","map":{"version":3,"names":["Object","defineProperty","exports","value","validateTuple","codegen_1","require","util_1","code_1","def","keyword","type","schemaType","before","code","cxt","schema","it","Array","isArray","items","alwaysValidSchema","ok","validateArray","extraItems","schArr","gen","parentSchema","data","checkStrictTuple","opts","unevaluated","length","mergeEvaluated","valid","name","len","const","_","forEach","sch","i","if","subschema","schemaProp","dataProp","errSchemaPath","l","fullTuple","minItems","maxItems","strictTuples","msg","checkStrictMode","default"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/ajv/dist/vocabularies/applicator/items.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateTuple = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports.default = def;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}