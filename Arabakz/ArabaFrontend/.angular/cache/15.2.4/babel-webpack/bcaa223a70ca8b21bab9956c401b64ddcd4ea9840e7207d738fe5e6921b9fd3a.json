{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst validation_error_1 = require(\"../runtime/validation_error\");\nconst names_1 = require(\"./names\");\nconst resolve_1 = require(\"./resolve\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nclass SchemaEnv {\n  constructor(env) {\n    var _a;\n    this.refs = {};\n    this.dynamicAnchors = {};\n    let schema;\n    if (typeof env.schema == \"object\") schema = env.schema;\n    this.schema = env.schema;\n    this.schemaId = env.schemaId;\n    this.root = env.root || this;\n    this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n    this.schemaPath = env.schemaPath;\n    this.localRefs = env.localRefs;\n    this.meta = env.meta;\n    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n    this.refs = {};\n  }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch);\n  if (_sch) return _sch;\n  const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n  const {\n    es5,\n    lines\n  } = this.opts.code;\n  const {\n    ownProperties\n  } = this.opts;\n  const gen = new codegen_1.CodeGen(this.scope, {\n    es5,\n    lines,\n    ownProperties\n  });\n  let _ValidationError;\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: validation_error_1.default,\n      code: (0, codegen_1._)`require(\"ajv/dist/runtime/validation_error\").default`\n    });\n  }\n  const validateName = gen.scopeName(\"validate\");\n  sch.validateName = validateName;\n  const schemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: names_1.default.data,\n    parentData: names_1.default.parentData,\n    parentDataProperty: names_1.default.parentDataProperty,\n    dataNames: [names_1.default.data],\n    dataPathArr: [codegen_1.nil],\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set(),\n    topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true ? {\n      ref: sch.schema,\n      code: (0, codegen_1.stringify)(sch.schema)\n    } : {\n      ref: sch.schema\n    }),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: (0, codegen_1._)`\"\"`,\n    opts: this.opts,\n    self: this\n  };\n  let sourceCode;\n  try {\n    this._compilations.add(sch);\n    (0, validate_1.validateFunctionCode)(schemaCxt);\n    gen.optimize(this.opts.code.optimize);\n    // gen.optimize(1)\n    const validateCode = gen.toString();\n    sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n    const validate = makeValidate(this, this.scope.get());\n    this.scope.value(validateName, {\n      ref: validate\n    });\n    validate.errors = null;\n    validate.schema = sch.schema;\n    validate.schemaEnv = sch;\n    if (sch.$async) validate.$async = true;\n    if (this.opts.code.source === true) {\n      validate.source = {\n        validateName,\n        validateCode,\n        scopeValues: gen._values\n      };\n    }\n    if (this.opts.unevaluated) {\n      const {\n        props,\n        items\n      } = schemaCxt;\n      validate.evaluated = {\n        props: props instanceof codegen_1.Name ? undefined : props,\n        items: items instanceof codegen_1.Name ? undefined : items,\n        dynamicProps: props instanceof codegen_1.Name,\n        dynamicItems: items instanceof codegen_1.Name\n      };\n      if (validate.source) validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n    }\n    sch.validate = validate;\n    return sch;\n  } catch (e) {\n    delete sch.validate;\n    delete sch.validateName;\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e;\n  } finally {\n    this._compilations.delete(sch);\n  }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n  var _a;\n  ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n  const schOrFunc = root.refs[ref];\n  if (schOrFunc) return schOrFunc;\n  let _sch = resolve.call(this, root, ref);\n  if (_sch === undefined) {\n    const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n    const {\n      schemaId\n    } = this.opts;\n    if (schema) _sch = new SchemaEnv({\n      schema,\n      schemaId,\n      root,\n      baseId\n    });\n  }\n  if (_sch === undefined) return;\n  return root.refs[ref] = inlineOrCompile.call(this, _sch);\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n  if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;\n  return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch;\n  }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root,\n// information about the root schema for the current schema\nref // reference to resolve\n) {\n  let sch;\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch;\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root,\n// root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n  const p = this.opts.uriResolver.parse(ref);\n  const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n  let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root);\n  }\n  const id = (0, resolve_1.normalizeId)(refPath);\n  const schOrRef = this.refs[id] || this.schemas[id];\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef);\n    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\") return;\n    return getJsonPointer.call(this, p, sch);\n  }\n  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\") return;\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef);\n  if (id === (0, resolve_1.normalizeId)(ref)) {\n    const {\n      schema\n    } = schOrRef;\n    const {\n      schemaId\n    } = this.opts;\n    const schId = schema[schemaId];\n    if (schId) baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n    return new SchemaEnv({\n      schema,\n      schemaId,\n      root,\n      baseId\n    });\n  }\n  return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\"properties\", \"patternProperties\", \"enum\", \"dependencies\", \"definitions\"]);\nfunction getJsonPointer(parsedRef, {\n  baseId,\n  schema,\n  root\n}) {\n  var _a;\n  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\") return;\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return;\n    const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n    if (partSchema === undefined) return;\n    schema = partSchema;\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n    }\n  }\n  let env;\n  if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n    const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n    env = resolveSchema.call(this, root, $ref);\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {\n    schemaId\n  } = this.opts;\n  env = env || new SchemaEnv({\n    schema,\n    schemaId,\n    root,\n    baseId\n  });\n  if (env.schema !== env.root.schema) return env;\n  return undefined;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","resolveSchema","getCompilingSchema","resolveRef","compileSchema","SchemaEnv","codegen_1","require","validation_error_1","names_1","resolve_1","util_1","validate_1","constructor","env","_a","refs","dynamicAnchors","schema","schemaId","root","baseId","normalizeId","schemaPath","localRefs","meta","$async","sch","_sch","call","rootId","getFullPath","opts","uriResolver","es5","lines","code","ownProperties","gen","CodeGen","scope","_ValidationError","scopeValue","ref","default","_","validateName","scopeName","schemaCxt","allErrors","data","parentData","parentDataProperty","dataNames","dataPathArr","nil","dataLevel","dataTypes","definedProperties","Set","topSchemaRef","source","stringify","ValidationError","schemaEnv","errSchemaPath","jtd","errorPath","self","sourceCode","_compilations","add","validateFunctionCode","optimize","validateCode","toString","scopeRefs","process","makeValidate","Function","validate","get","errors","scopeValues","_values","unevaluated","props","items","evaluated","Name","undefined","dynamicProps","dynamicItems","e","logger","error","delete","resolveUrl","schOrFunc","resolve","inlineOrCompile","inlineRef","inlineRefs","schEnv","sameSchemaEnv","s1","s2","schemas","p","parse","refPath","_getFullPath","keys","length","getJsonPointer","id","schOrRef","schId","PREVENT_SCOPE_CHANGE","parsedRef","fragment","part","slice","split","partSchema","unescapeFragment","has","$ref","schemaHasRulesButRef","RULES"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/ajv/dist/compile/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst validation_error_1 = require(\"../runtime/validation_error\");\nconst names_1 = require(\"./names\");\nconst resolve_1 = require(\"./resolve\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil],\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._) `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}