{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as formatter from './impl/format';\nimport * as edit from './impl/edit';\nimport * as scanner from './impl/scanner';\nimport * as parser from './impl/parser';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport const createScanner = scanner.createScanner;\nexport var ScanError;\n(function (ScanError) {\n  ScanError[ScanError[\"None\"] = 0] = \"None\";\n  ScanError[ScanError[\"UnexpectedEndOfComment\"] = 1] = \"UnexpectedEndOfComment\";\n  ScanError[ScanError[\"UnexpectedEndOfString\"] = 2] = \"UnexpectedEndOfString\";\n  ScanError[ScanError[\"UnexpectedEndOfNumber\"] = 3] = \"UnexpectedEndOfNumber\";\n  ScanError[ScanError[\"InvalidUnicode\"] = 4] = \"InvalidUnicode\";\n  ScanError[ScanError[\"InvalidEscapeCharacter\"] = 5] = \"InvalidEscapeCharacter\";\n  ScanError[ScanError[\"InvalidCharacter\"] = 6] = \"InvalidCharacter\";\n})(ScanError || (ScanError = {}));\nexport var SyntaxKind;\n(function (SyntaxKind) {\n  SyntaxKind[SyntaxKind[\"OpenBraceToken\"] = 1] = \"OpenBraceToken\";\n  SyntaxKind[SyntaxKind[\"CloseBraceToken\"] = 2] = \"CloseBraceToken\";\n  SyntaxKind[SyntaxKind[\"OpenBracketToken\"] = 3] = \"OpenBracketToken\";\n  SyntaxKind[SyntaxKind[\"CloseBracketToken\"] = 4] = \"CloseBracketToken\";\n  SyntaxKind[SyntaxKind[\"CommaToken\"] = 5] = \"CommaToken\";\n  SyntaxKind[SyntaxKind[\"ColonToken\"] = 6] = \"ColonToken\";\n  SyntaxKind[SyntaxKind[\"NullKeyword\"] = 7] = \"NullKeyword\";\n  SyntaxKind[SyntaxKind[\"TrueKeyword\"] = 8] = \"TrueKeyword\";\n  SyntaxKind[SyntaxKind[\"FalseKeyword\"] = 9] = \"FalseKeyword\";\n  SyntaxKind[SyntaxKind[\"StringLiteral\"] = 10] = \"StringLiteral\";\n  SyntaxKind[SyntaxKind[\"NumericLiteral\"] = 11] = \"NumericLiteral\";\n  SyntaxKind[SyntaxKind[\"LineCommentTrivia\"] = 12] = \"LineCommentTrivia\";\n  SyntaxKind[SyntaxKind[\"BlockCommentTrivia\"] = 13] = \"BlockCommentTrivia\";\n  SyntaxKind[SyntaxKind[\"LineBreakTrivia\"] = 14] = \"LineBreakTrivia\";\n  SyntaxKind[SyntaxKind[\"Trivia\"] = 15] = \"Trivia\";\n  SyntaxKind[SyntaxKind[\"Unknown\"] = 16] = \"Unknown\";\n  SyntaxKind[SyntaxKind[\"EOF\"] = 17] = \"EOF\";\n})(SyntaxKind || (SyntaxKind = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport const getLocation = parser.getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore, always check the errors list to find out if the input was valid.\n */\nexport const parse = parser.parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport const parseTree = parser.parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport const findNodeAtLocation = parser.findNodeAtLocation;\n/**\n * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport const findNodeAtOffset = parser.findNodeAtOffset;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport const getNodePath = parser.getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport const getNodeValue = parser.getNodeValue;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport const visit = parser.visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport const stripComments = parser.stripComments;\nexport var ParseErrorCode;\n(function (ParseErrorCode) {\n  ParseErrorCode[ParseErrorCode[\"InvalidSymbol\"] = 1] = \"InvalidSymbol\";\n  ParseErrorCode[ParseErrorCode[\"InvalidNumberFormat\"] = 2] = \"InvalidNumberFormat\";\n  ParseErrorCode[ParseErrorCode[\"PropertyNameExpected\"] = 3] = \"PropertyNameExpected\";\n  ParseErrorCode[ParseErrorCode[\"ValueExpected\"] = 4] = \"ValueExpected\";\n  ParseErrorCode[ParseErrorCode[\"ColonExpected\"] = 5] = \"ColonExpected\";\n  ParseErrorCode[ParseErrorCode[\"CommaExpected\"] = 6] = \"CommaExpected\";\n  ParseErrorCode[ParseErrorCode[\"CloseBraceExpected\"] = 7] = \"CloseBraceExpected\";\n  ParseErrorCode[ParseErrorCode[\"CloseBracketExpected\"] = 8] = \"CloseBracketExpected\";\n  ParseErrorCode[ParseErrorCode[\"EndOfFileExpected\"] = 9] = \"EndOfFileExpected\";\n  ParseErrorCode[ParseErrorCode[\"InvalidCommentToken\"] = 10] = \"InvalidCommentToken\";\n  ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfComment\"] = 11] = \"UnexpectedEndOfComment\";\n  ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfString\"] = 12] = \"UnexpectedEndOfString\";\n  ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfNumber\"] = 13] = \"UnexpectedEndOfNumber\";\n  ParseErrorCode[ParseErrorCode[\"InvalidUnicode\"] = 14] = \"InvalidUnicode\";\n  ParseErrorCode[ParseErrorCode[\"InvalidEscapeCharacter\"] = 15] = \"InvalidEscapeCharacter\";\n  ParseErrorCode[ParseErrorCode[\"InvalidCharacter\"] = 16] = \"InvalidCharacter\";\n})(ParseErrorCode || (ParseErrorCode = {}));\nexport function printParseErrorCode(code) {\n  switch (code) {\n    case 1 /* ParseErrorCode.InvalidSymbol */:\n      return 'InvalidSymbol';\n    case 2 /* ParseErrorCode.InvalidNumberFormat */:\n      return 'InvalidNumberFormat';\n    case 3 /* ParseErrorCode.PropertyNameExpected */:\n      return 'PropertyNameExpected';\n    case 4 /* ParseErrorCode.ValueExpected */:\n      return 'ValueExpected';\n    case 5 /* ParseErrorCode.ColonExpected */:\n      return 'ColonExpected';\n    case 6 /* ParseErrorCode.CommaExpected */:\n      return 'CommaExpected';\n    case 7 /* ParseErrorCode.CloseBraceExpected */:\n      return 'CloseBraceExpected';\n    case 8 /* ParseErrorCode.CloseBracketExpected */:\n      return 'CloseBracketExpected';\n    case 9 /* ParseErrorCode.EndOfFileExpected */:\n      return 'EndOfFileExpected';\n    case 10 /* ParseErrorCode.InvalidCommentToken */:\n      return 'InvalidCommentToken';\n    case 11 /* ParseErrorCode.UnexpectedEndOfComment */:\n      return 'UnexpectedEndOfComment';\n    case 12 /* ParseErrorCode.UnexpectedEndOfString */:\n      return 'UnexpectedEndOfString';\n    case 13 /* ParseErrorCode.UnexpectedEndOfNumber */:\n      return 'UnexpectedEndOfNumber';\n    case 14 /* ParseErrorCode.InvalidUnicode */:\n      return 'InvalidUnicode';\n    case 15 /* ParseErrorCode.InvalidEscapeCharacter */:\n      return 'InvalidEscapeCharacter';\n    case 16 /* ParseErrorCode.InvalidCharacter */:\n      return 'InvalidCharacter';\n  }\n  return '<unknown ParseErrorCode>';\n}\n/**\n * Computes the edit operations needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns The edit operations describing the formatting changes to the original document following the format described in {@linkcode EditResult}.\n * To apply the edit operations to the input, use {@linkcode applyEdits}.\n */\nexport function format(documentText, range, options) {\n  return formatter.format(documentText, range, options);\n}\n/**\n * Computes the edit operations needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns The edit operations describing the changes to the original document, following the format described in {@linkcode EditResult}.\n * To apply the edit operations to the input, use {@linkcode applyEdits}.\n */\nexport function modify(text, path, value, options) {\n  return edit.setProperty(text, path, value, options);\n}\n/**\n * Applies edits to an input string.\n * @param text The input text\n * @param edits Edit operations following the format described in {@linkcode EditResult}.\n * @returns The text with the applied edits.\n * @throws An error if the edit operations are not well-formed as described in {@linkcode EditResult}.\n */\nexport function applyEdits(text, edits) {\n  let sortedEdits = edits.slice(0).sort((a, b) => {\n    const diff = a.offset - b.offset;\n    if (diff === 0) {\n      return a.length - b.length;\n    }\n    return diff;\n  });\n  let lastModifiedOffset = text.length;\n  for (let i = sortedEdits.length - 1; i >= 0; i--) {\n    let e = sortedEdits[i];\n    if (e.offset + e.length <= lastModifiedOffset) {\n      text = edit.applyEdit(text, e);\n    } else {\n      throw new Error('Overlapping edit');\n    }\n    lastModifiedOffset = e.offset;\n  }\n  return text;\n}","map":{"version":3,"names":["formatter","edit","scanner","parser","createScanner","ScanError","SyntaxKind","getLocation","parse","parseTree","findNodeAtLocation","findNodeAtOffset","getNodePath","getNodeValue","visit","stripComments","ParseErrorCode","printParseErrorCode","code","format","documentText","range","options","modify","text","path","value","setProperty","applyEdits","edits","sortedEdits","slice","sort","a","b","diff","offset","length","lastModifiedOffset","i","e","applyEdit","Error"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/jsonc-parser/lib/esm/main.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\nimport * as formatter from './impl/format';\nimport * as edit from './impl/edit';\nimport * as scanner from './impl/scanner';\nimport * as parser from './impl/parser';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport const createScanner = scanner.createScanner;\nexport var ScanError;\n(function (ScanError) {\n    ScanError[ScanError[\"None\"] = 0] = \"None\";\n    ScanError[ScanError[\"UnexpectedEndOfComment\"] = 1] = \"UnexpectedEndOfComment\";\n    ScanError[ScanError[\"UnexpectedEndOfString\"] = 2] = \"UnexpectedEndOfString\";\n    ScanError[ScanError[\"UnexpectedEndOfNumber\"] = 3] = \"UnexpectedEndOfNumber\";\n    ScanError[ScanError[\"InvalidUnicode\"] = 4] = \"InvalidUnicode\";\n    ScanError[ScanError[\"InvalidEscapeCharacter\"] = 5] = \"InvalidEscapeCharacter\";\n    ScanError[ScanError[\"InvalidCharacter\"] = 6] = \"InvalidCharacter\";\n})(ScanError || (ScanError = {}));\nexport var SyntaxKind;\n(function (SyntaxKind) {\n    SyntaxKind[SyntaxKind[\"OpenBraceToken\"] = 1] = \"OpenBraceToken\";\n    SyntaxKind[SyntaxKind[\"CloseBraceToken\"] = 2] = \"CloseBraceToken\";\n    SyntaxKind[SyntaxKind[\"OpenBracketToken\"] = 3] = \"OpenBracketToken\";\n    SyntaxKind[SyntaxKind[\"CloseBracketToken\"] = 4] = \"CloseBracketToken\";\n    SyntaxKind[SyntaxKind[\"CommaToken\"] = 5] = \"CommaToken\";\n    SyntaxKind[SyntaxKind[\"ColonToken\"] = 6] = \"ColonToken\";\n    SyntaxKind[SyntaxKind[\"NullKeyword\"] = 7] = \"NullKeyword\";\n    SyntaxKind[SyntaxKind[\"TrueKeyword\"] = 8] = \"TrueKeyword\";\n    SyntaxKind[SyntaxKind[\"FalseKeyword\"] = 9] = \"FalseKeyword\";\n    SyntaxKind[SyntaxKind[\"StringLiteral\"] = 10] = \"StringLiteral\";\n    SyntaxKind[SyntaxKind[\"NumericLiteral\"] = 11] = \"NumericLiteral\";\n    SyntaxKind[SyntaxKind[\"LineCommentTrivia\"] = 12] = \"LineCommentTrivia\";\n    SyntaxKind[SyntaxKind[\"BlockCommentTrivia\"] = 13] = \"BlockCommentTrivia\";\n    SyntaxKind[SyntaxKind[\"LineBreakTrivia\"] = 14] = \"LineBreakTrivia\";\n    SyntaxKind[SyntaxKind[\"Trivia\"] = 15] = \"Trivia\";\n    SyntaxKind[SyntaxKind[\"Unknown\"] = 16] = \"Unknown\";\n    SyntaxKind[SyntaxKind[\"EOF\"] = 17] = \"EOF\";\n})(SyntaxKind || (SyntaxKind = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport const getLocation = parser.getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore, always check the errors list to find out if the input was valid.\n */\nexport const parse = parser.parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport const parseTree = parser.parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport const findNodeAtLocation = parser.findNodeAtLocation;\n/**\n * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport const findNodeAtOffset = parser.findNodeAtOffset;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport const getNodePath = parser.getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\nexport const getNodeValue = parser.getNodeValue;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport const visit = parser.visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport const stripComments = parser.stripComments;\nexport var ParseErrorCode;\n(function (ParseErrorCode) {\n    ParseErrorCode[ParseErrorCode[\"InvalidSymbol\"] = 1] = \"InvalidSymbol\";\n    ParseErrorCode[ParseErrorCode[\"InvalidNumberFormat\"] = 2] = \"InvalidNumberFormat\";\n    ParseErrorCode[ParseErrorCode[\"PropertyNameExpected\"] = 3] = \"PropertyNameExpected\";\n    ParseErrorCode[ParseErrorCode[\"ValueExpected\"] = 4] = \"ValueExpected\";\n    ParseErrorCode[ParseErrorCode[\"ColonExpected\"] = 5] = \"ColonExpected\";\n    ParseErrorCode[ParseErrorCode[\"CommaExpected\"] = 6] = \"CommaExpected\";\n    ParseErrorCode[ParseErrorCode[\"CloseBraceExpected\"] = 7] = \"CloseBraceExpected\";\n    ParseErrorCode[ParseErrorCode[\"CloseBracketExpected\"] = 8] = \"CloseBracketExpected\";\n    ParseErrorCode[ParseErrorCode[\"EndOfFileExpected\"] = 9] = \"EndOfFileExpected\";\n    ParseErrorCode[ParseErrorCode[\"InvalidCommentToken\"] = 10] = \"InvalidCommentToken\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfComment\"] = 11] = \"UnexpectedEndOfComment\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfString\"] = 12] = \"UnexpectedEndOfString\";\n    ParseErrorCode[ParseErrorCode[\"UnexpectedEndOfNumber\"] = 13] = \"UnexpectedEndOfNumber\";\n    ParseErrorCode[ParseErrorCode[\"InvalidUnicode\"] = 14] = \"InvalidUnicode\";\n    ParseErrorCode[ParseErrorCode[\"InvalidEscapeCharacter\"] = 15] = \"InvalidEscapeCharacter\";\n    ParseErrorCode[ParseErrorCode[\"InvalidCharacter\"] = 16] = \"InvalidCharacter\";\n})(ParseErrorCode || (ParseErrorCode = {}));\nexport function printParseErrorCode(code) {\n    switch (code) {\n        case 1 /* ParseErrorCode.InvalidSymbol */: return 'InvalidSymbol';\n        case 2 /* ParseErrorCode.InvalidNumberFormat */: return 'InvalidNumberFormat';\n        case 3 /* ParseErrorCode.PropertyNameExpected */: return 'PropertyNameExpected';\n        case 4 /* ParseErrorCode.ValueExpected */: return 'ValueExpected';\n        case 5 /* ParseErrorCode.ColonExpected */: return 'ColonExpected';\n        case 6 /* ParseErrorCode.CommaExpected */: return 'CommaExpected';\n        case 7 /* ParseErrorCode.CloseBraceExpected */: return 'CloseBraceExpected';\n        case 8 /* ParseErrorCode.CloseBracketExpected */: return 'CloseBracketExpected';\n        case 9 /* ParseErrorCode.EndOfFileExpected */: return 'EndOfFileExpected';\n        case 10 /* ParseErrorCode.InvalidCommentToken */: return 'InvalidCommentToken';\n        case 11 /* ParseErrorCode.UnexpectedEndOfComment */: return 'UnexpectedEndOfComment';\n        case 12 /* ParseErrorCode.UnexpectedEndOfString */: return 'UnexpectedEndOfString';\n        case 13 /* ParseErrorCode.UnexpectedEndOfNumber */: return 'UnexpectedEndOfNumber';\n        case 14 /* ParseErrorCode.InvalidUnicode */: return 'InvalidUnicode';\n        case 15 /* ParseErrorCode.InvalidEscapeCharacter */: return 'InvalidEscapeCharacter';\n        case 16 /* ParseErrorCode.InvalidCharacter */: return 'InvalidCharacter';\n    }\n    return '<unknown ParseErrorCode>';\n}\n/**\n * Computes the edit operations needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns The edit operations describing the formatting changes to the original document following the format described in {@linkcode EditResult}.\n * To apply the edit operations to the input, use {@linkcode applyEdits}.\n */\nexport function format(documentText, range, options) {\n    return formatter.format(documentText, range, options);\n}\n/**\n * Computes the edit operations needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns The edit operations describing the changes to the original document, following the format described in {@linkcode EditResult}.\n * To apply the edit operations to the input, use {@linkcode applyEdits}.\n */\nexport function modify(text, path, value, options) {\n    return edit.setProperty(text, path, value, options);\n}\n/**\n * Applies edits to an input string.\n * @param text The input text\n * @param edits Edit operations following the format described in {@linkcode EditResult}.\n * @returns The text with the applied edits.\n * @throws An error if the edit operations are not well-formed as described in {@linkcode EditResult}.\n */\nexport function applyEdits(text, edits) {\n    let sortedEdits = edits.slice(0).sort((a, b) => {\n        const diff = a.offset - b.offset;\n        if (diff === 0) {\n            return a.length - b.length;\n        }\n        return diff;\n    });\n    let lastModifiedOffset = text.length;\n    for (let i = sortedEdits.length - 1; i >= 0; i--) {\n        let e = sortedEdits[i];\n        if (e.offset + e.length <= lastModifiedOffset) {\n            text = edit.applyEdit(text, e);\n        }\n        else {\n            throw new Error('Overlapping edit');\n        }\n        lastModifiedOffset = e.offset;\n    }\n    return text;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}