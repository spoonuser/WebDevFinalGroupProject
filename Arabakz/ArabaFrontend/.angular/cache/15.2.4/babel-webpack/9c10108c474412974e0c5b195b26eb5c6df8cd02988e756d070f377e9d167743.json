{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = require(\"../rules\");\nconst applicability_1 = require(\"./applicability\");\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nvar DataType;\n(function (DataType) {\n  DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n  DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType = exports.DataType || (exports.DataType = {}));\nfunction getSchemaTypes(schema) {\n  const types = getJSONTypes(schema.type);\n  const hasNull = types.includes(\"null\");\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\");\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"');\n    }\n    if (schema.nullable === true) types.push(\"null\");\n  }\n  return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\nfunction getJSONTypes(ts) {\n  const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n  if (types.every(rules_1.isJSONType)) return types;\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n  const {\n    gen,\n    data,\n    opts\n  } = it;\n  const coerceTo = coerceToTypes(types, opts.coerceTypes);\n  const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo);else reportTypeError(it);\n    });\n  }\n  return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n  return coerceTypes ? types.filter(t => COERCIBLE.has(t) || coerceTypes === \"array\" && t === \"array\") : [];\n}\nfunction coerceData(it, types, coerceTo) {\n  const {\n    gen,\n    data,\n    opts\n  } = it;\n  const dataType = gen.let(\"dataType\", (0, codegen_1._)`typeof ${data}`);\n  const coerced = gen.let(\"coerced\", (0, codegen_1._)`undefined`);\n  if (opts.coerceTypes === \"array\") {\n    gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n  }\n  gen.if((0, codegen_1._)`${coerced} !== undefined`);\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || t === \"array\" && opts.coerceTypes === \"array\") {\n      coerceSpecificType(t);\n    }\n  }\n  gen.else();\n  reportTypeError(it);\n  gen.endIf();\n  gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced);\n    assignParentData(it, coerced);\n  });\n  function coerceSpecificType(t) {\n    switch (t) {\n      case \"string\":\n        gen.elseIf((0, codegen_1._)`${dataType} == \"number\" || ${dataType} == \"boolean\"`).assign(coerced, (0, codegen_1._)`\"\" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`\"\"`);\n        return;\n      case \"number\":\n        gen.elseIf((0, codegen_1._)`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);\n        return;\n      case \"integer\":\n        gen.elseIf((0, codegen_1._)`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);\n        return;\n      case \"boolean\":\n        gen.elseIf((0, codegen_1._)`${data} === \"false\" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === \"true\" || ${data} === 1`).assign(coerced, true);\n        return;\n      case \"null\":\n        gen.elseIf((0, codegen_1._)`${data} === \"\" || ${data} === 0 || ${data} === false`);\n        gen.assign(coerced, null);\n        return;\n      case \"array\":\n        gen.elseIf((0, codegen_1._)`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);\n    }\n  }\n}\nfunction assignParentData({\n  gen,\n  parentData,\n  parentDataProperty\n}, expr) {\n  // TODO use gen.property\n  gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n  const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n  let cond;\n  switch (dataType) {\n    case \"null\":\n      return (0, codegen_1._)`${data} ${EQ} null`;\n    case \"array\":\n      cond = (0, codegen_1._)`Array.isArray(${data})`;\n      break;\n    case \"object\":\n      cond = (0, codegen_1._)`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n      break;\n    case \"integer\":\n      cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);\n      break;\n    case \"number\":\n      cond = numCond();\n      break;\n    default:\n      return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;\n  }\n  return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n  function numCond(_cond = codegen_1.nil) {\n    return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);\n  }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct);\n  }\n  let cond;\n  const types = (0, util_1.toHash)(dataTypes);\n  if (types.array && types.object) {\n    const notObj = (0, codegen_1._)`typeof ${data} != \"object\"`;\n    cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;\n    delete types.null;\n    delete types.array;\n    delete types.object;\n  } else {\n    cond = codegen_1.nil;\n  }\n  if (types.number) delete types.integer;\n  for (const t in types) cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n  return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n  message: ({\n    schema\n  }) => `must be ${schema}`,\n  params: ({\n    schema,\n    schemaValue\n  }) => typeof schema == \"string\" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`\n};\nfunction reportTypeError(it) {\n  const cxt = getTypeErrorContext(it);\n  (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n  const {\n    gen,\n    data,\n    schema\n  } = it;\n  const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","reportTypeError","checkDataTypes","checkDataType","coerceAndCheckDataType","getJSONTypes","getSchemaTypes","DataType","rules_1","require","applicability_1","errors_1","codegen_1","util_1","schema","types","type","hasNull","includes","nullable","Error","length","undefined","push","ts","Array","isArray","every","isJSONType","join","it","gen","data","opts","coerceTo","coerceToTypes","coerceTypes","checkTypes","schemaHasRulesForType","wrongType","strictNumbers","Wrong","if","coerceData","COERCIBLE","Set","filter","t","has","dataType","let","_","coerced","assign","coerceSpecificType","else","endIf","assignParentData","elseIf","parentData","parentDataProperty","expr","strictNums","correct","Correct","EQ","operators","NEQ","cond","numCond","not","_cond","nil","and","dataTypes","toHash","array","object","notObj","null","number","integer","typeError","message","params","schemaValue","cxt","getTypeErrorContext","reportError","schemaCode","schemaRefOrVal","keyword","parentSchema"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/ajv/dist/compile/validate/dataType.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = require(\"../rules\");\nconst applicability_1 = require(\"./applicability\");\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n    DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType = exports.DataType || (exports.DataType = {}));\nfunction getSchemaTypes(schema) {\n    const types = getJSONTypes(schema.type);\n    const hasNull = types.includes(\"null\");\n    if (hasNull) {\n        if (schema.nullable === false)\n            throw new Error(\"type: null contradicts nullable: false\");\n    }\n    else {\n        if (!types.length && schema.nullable !== undefined) {\n            throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n            types.push(\"null\");\n    }\n    return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\nfunction getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n    if (types.every(rules_1.isJSONType))\n        return types;\n    throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n    const { gen, data, opts } = it;\n    const coerceTo = coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 &&\n        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n            if (coerceTo.length)\n                coerceData(it, types, coerceTo);\n            else\n                reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n    return coerceTypes\n        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n        : [];\n}\nfunction coerceData(it, types, coerceTo) {\n    const { gen, data, opts } = it;\n    const dataType = gen.let(\"dataType\", (0, codegen_1._) `typeof ${data}`);\n    const coerced = gen.let(\"coerced\", (0, codegen_1._) `undefined`);\n    if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen\n            .assign(data, (0, codegen_1._) `${data}[0]`)\n            .assign(dataType, (0, codegen_1._) `typeof ${data}`)\n            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n    }\n    gen.if((0, codegen_1._) `${coerced} !== undefined`);\n    for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n            coerceSpecificType(t);\n        }\n    }\n    gen.else();\n    reportTypeError(it);\n    gen.endIf();\n    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch (t) {\n            case \"string\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n                    .assign(coerced, (0, codegen_1._) `\"\" + ${data}`)\n                    .elseIf((0, codegen_1._) `${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `\"\"`);\n                return;\n            case \"number\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"integer\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"boolean\":\n                gen\n                    .elseIf((0, codegen_1._) `${data} === \"false\" || ${data} === 0 || ${data} === null`)\n                    .assign(coerced, false)\n                    .elseIf((0, codegen_1._) `${data} === \"true\" || ${data} === 1`)\n                    .assign(coerced, true);\n                return;\n            case \"null\":\n                gen.elseIf((0, codegen_1._) `${data} === \"\" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case \"array\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `[${data}]`);\n        }\n    }\n}\nfunction assignParentData({ gen, parentData, parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n    let cond;\n    switch (dataType) {\n        case \"null\":\n            return (0, codegen_1._) `${data} ${EQ} null`;\n        case \"array\":\n            cond = (0, codegen_1._) `Array.isArray(${data})`;\n            break;\n        case \"object\":\n            cond = (0, codegen_1._) `${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n            break;\n        case \"integer\":\n            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case \"number\":\n            cond = numCond();\n            break;\n        default:\n            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n    function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);\n    }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n    }\n    let cond;\n    const types = (0, util_1.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, codegen_1._) `typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    }\n    else {\n        cond = codegen_1.nil;\n    }\n    if (types.number)\n        delete types.integer;\n    for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n    message: ({ schema }) => `must be ${schema}`,\n    params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,\n};\nfunction reportTypeError(it) {\n    const cxt = getTypeErrorContext(it);\n    (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n    const { gen, data, schema } = it;\n    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n    return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}