{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeJsonWorkspace = void 0;\nconst jsonc_parser_1 = require(\"jsonc-parser\");\nconst metadata_1 = require(\"./metadata\");\nfunction writeJsonWorkspace(_x, _x2, _x3) {\n  return _writeJsonWorkspace.apply(this, arguments);\n}\nfunction _writeJsonWorkspace() {\n  _writeJsonWorkspace = _asyncToGenerator(function* (workspace, host, path, options = {}) {\n    const metadata = workspace[metadata_1.JsonWorkspaceSymbol];\n    if (metadata) {\n      if (!metadata.hasChanges) {\n        return;\n      }\n      // update existing JSON workspace\n      const data = updateJsonWorkspace(metadata);\n      return host.writeFile(path !== null && path !== void 0 ? path : metadata.filePath, data);\n    } else {\n      // serialize directly\n      if (!path) {\n        throw new Error('path option is required');\n      }\n      const obj = convertJsonWorkspace(workspace, options.schema);\n      const data = JSON.stringify(obj, null, 2);\n      return host.writeFile(path, data);\n    }\n  });\n  return _writeJsonWorkspace.apply(this, arguments);\n}\nexports.writeJsonWorkspace = writeJsonWorkspace;\nfunction convertJsonWorkspace(workspace, schema) {\n  const obj = {\n    $schema: schema || './node_modules/@angular/cli/lib/config/schema.json',\n    version: 1,\n    ...workspace.extensions,\n    ...(isEmpty(workspace.projects) ? {} : {\n      projects: convertJsonProjectCollection(workspace.projects)\n    })\n  };\n  return obj;\n}\nfunction convertJsonProjectCollection(collection) {\n  const projects = Object.create(null);\n  for (const [projectName, project] of collection) {\n    projects[projectName] = convertJsonProject(project);\n  }\n  return projects;\n}\nfunction convertJsonProject(project) {\n  let targets;\n  if (project.targets.size > 0) {\n    targets = Object.create(null);\n    for (const [targetName, target] of project.targets) {\n      targets[targetName] = convertJsonTarget(target);\n    }\n  }\n  const obj = {\n    ...project.extensions,\n    root: project.root,\n    ...(project.sourceRoot === undefined ? {} : {\n      sourceRoot: project.sourceRoot\n    }),\n    ...(project.prefix === undefined ? {} : {\n      prefix: project.prefix\n    }),\n    ...(targets === undefined ? {} : {\n      architect: targets\n    })\n  };\n  return obj;\n}\nfunction isEmpty(obj) {\n  return obj === undefined || Object.keys(obj).length === 0;\n}\nfunction convertJsonTarget(target) {\n  return {\n    builder: target.builder,\n    ...(isEmpty(target.options) ? {} : {\n      options: target.options\n    }),\n    ...(isEmpty(target.configurations) ? {} : {\n      configurations: target.configurations\n    }),\n    ...(target.defaultConfiguration === undefined ? {} : {\n      defaultConfiguration: target.defaultConfiguration\n    })\n  };\n}\nfunction convertJsonTargetCollection(collection) {\n  const targets = Object.create(null);\n  for (const [projectName, target] of collection) {\n    targets[projectName] = convertJsonTarget(target);\n  }\n  return targets;\n}\nfunction normalizeValue(value, type) {\n  if (value === undefined) {\n    return undefined;\n  }\n  switch (type) {\n    case 'project':\n      return convertJsonProject(value);\n    case 'projectcollection':\n      const projects = convertJsonProjectCollection(value);\n      return isEmpty(projects) ? undefined : projects;\n    case 'target':\n      return convertJsonTarget(value);\n    case 'targetcollection':\n      const targets = convertJsonTargetCollection(value);\n      return isEmpty(targets) ? undefined : targets;\n    default:\n      return value;\n  }\n}\nfunction updateJsonWorkspace(metadata) {\n  let {\n    raw: content\n  } = metadata;\n  const {\n    changes,\n    hasLegacyTargetsName\n  } = metadata;\n  for (const {\n    jsonPath,\n    value,\n    type\n  } of changes.values()) {\n    // Determine which key to use if (architect or targets)\n    if (hasLegacyTargetsName && jsonPath[2] === 'targets') {\n      jsonPath[2] = 'architect';\n    }\n    // TODO: `modify` re-parses the content every time.\n    // See: https://github.com/microsoft/node-jsonc-parser/blob/35d94cd71bd48f9784453b2439262c938e21d49b/src/impl/edit.ts#L18\n    // Ideally this should accept a string or an AST to avoid the potentially expensive repeat parsing operation.\n    const edits = (0, jsonc_parser_1.modify)(content, jsonPath, normalizeValue(value, type), {\n      formattingOptions: {\n        insertSpaces: true,\n        tabSize: 2\n      }\n    });\n    content = (0, jsonc_parser_1.applyEdits)(content, edits);\n  }\n  return content;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","writeJsonWorkspace","jsonc_parser_1","require","metadata_1","workspace","host","path","options","metadata","JsonWorkspaceSymbol","hasChanges","data","updateJsonWorkspace","writeFile","filePath","Error","obj","convertJsonWorkspace","schema","JSON","stringify","$schema","version","extensions","isEmpty","projects","convertJsonProjectCollection","collection","create","projectName","project","convertJsonProject","targets","size","targetName","target","convertJsonTarget","root","sourceRoot","undefined","prefix","architect","keys","length","builder","configurations","defaultConfiguration","convertJsonTargetCollection","normalizeValue","type","raw","content","changes","hasLegacyTargetsName","jsonPath","values","edits","modify","formattingOptions","insertSpaces","tabSize","applyEdits"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/node_modules/@angular-devkit/core/src/workspace/json/writer.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.writeJsonWorkspace = void 0;\nconst jsonc_parser_1 = require(\"jsonc-parser\");\nconst metadata_1 = require(\"./metadata\");\nasync function writeJsonWorkspace(workspace, host, path, options = {}) {\n    const metadata = workspace[metadata_1.JsonWorkspaceSymbol];\n    if (metadata) {\n        if (!metadata.hasChanges) {\n            return;\n        }\n        // update existing JSON workspace\n        const data = updateJsonWorkspace(metadata);\n        return host.writeFile(path !== null && path !== void 0 ? path : metadata.filePath, data);\n    }\n    else {\n        // serialize directly\n        if (!path) {\n            throw new Error('path option is required');\n        }\n        const obj = convertJsonWorkspace(workspace, options.schema);\n        const data = JSON.stringify(obj, null, 2);\n        return host.writeFile(path, data);\n    }\n}\nexports.writeJsonWorkspace = writeJsonWorkspace;\nfunction convertJsonWorkspace(workspace, schema) {\n    const obj = {\n        $schema: schema || './node_modules/@angular/cli/lib/config/schema.json',\n        version: 1,\n        ...workspace.extensions,\n        ...(isEmpty(workspace.projects)\n            ? {}\n            : { projects: convertJsonProjectCollection(workspace.projects) }),\n    };\n    return obj;\n}\nfunction convertJsonProjectCollection(collection) {\n    const projects = Object.create(null);\n    for (const [projectName, project] of collection) {\n        projects[projectName] = convertJsonProject(project);\n    }\n    return projects;\n}\nfunction convertJsonProject(project) {\n    let targets;\n    if (project.targets.size > 0) {\n        targets = Object.create(null);\n        for (const [targetName, target] of project.targets) {\n            targets[targetName] = convertJsonTarget(target);\n        }\n    }\n    const obj = {\n        ...project.extensions,\n        root: project.root,\n        ...(project.sourceRoot === undefined ? {} : { sourceRoot: project.sourceRoot }),\n        ...(project.prefix === undefined ? {} : { prefix: project.prefix }),\n        ...(targets === undefined ? {} : { architect: targets }),\n    };\n    return obj;\n}\nfunction isEmpty(obj) {\n    return obj === undefined || Object.keys(obj).length === 0;\n}\nfunction convertJsonTarget(target) {\n    return {\n        builder: target.builder,\n        ...(isEmpty(target.options) ? {} : { options: target.options }),\n        ...(isEmpty(target.configurations)\n            ? {}\n            : { configurations: target.configurations }),\n        ...(target.defaultConfiguration === undefined\n            ? {}\n            : { defaultConfiguration: target.defaultConfiguration }),\n    };\n}\nfunction convertJsonTargetCollection(collection) {\n    const targets = Object.create(null);\n    for (const [projectName, target] of collection) {\n        targets[projectName] = convertJsonTarget(target);\n    }\n    return targets;\n}\nfunction normalizeValue(value, type) {\n    if (value === undefined) {\n        return undefined;\n    }\n    switch (type) {\n        case 'project':\n            return convertJsonProject(value);\n        case 'projectcollection':\n            const projects = convertJsonProjectCollection(value);\n            return isEmpty(projects) ? undefined : projects;\n        case 'target':\n            return convertJsonTarget(value);\n        case 'targetcollection':\n            const targets = convertJsonTargetCollection(value);\n            return isEmpty(targets) ? undefined : targets;\n        default:\n            return value;\n    }\n}\nfunction updateJsonWorkspace(metadata) {\n    let { raw: content } = metadata;\n    const { changes, hasLegacyTargetsName } = metadata;\n    for (const { jsonPath, value, type } of changes.values()) {\n        // Determine which key to use if (architect or targets)\n        if (hasLegacyTargetsName && jsonPath[2] === 'targets') {\n            jsonPath[2] = 'architect';\n        }\n        // TODO: `modify` re-parses the content every time.\n        // See: https://github.com/microsoft/node-jsonc-parser/blob/35d94cd71bd48f9784453b2439262c938e21d49b/src/impl/edit.ts#L18\n        // Ideally this should accept a string or an AST to avoid the potentially expensive repeat parsing operation.\n        const edits = (0, jsonc_parser_1.modify)(content, jsonPath, normalizeValue(value, type), {\n            formattingOptions: {\n                insertSpaces: true,\n                tabSize: 2,\n            },\n        });\n        content = (0, jsonc_parser_1.applyEdits)(content, edits);\n    }\n    return content;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}