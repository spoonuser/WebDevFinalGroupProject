{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLoggerJob = exports.createJobFactory = exports.createJobHandler = exports.ChannelAlreadyExistException = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst api_1 = require(\"./api\");\nclass ChannelAlreadyExistException extends core_1.BaseException {\n  constructor(name) {\n    super(`Channel ${JSON.stringify(name)} already exist.`);\n  }\n}\nexports.ChannelAlreadyExistException = ChannelAlreadyExistException;\n/**\n * Make a simple job handler that sets start and end from a function that's synchronous.\n *\n * @param fn The function to create a handler for.\n * @param options An optional set of properties to set on the handler. Some fields might be\n *   required by registry or schedulers.\n */\nfunction createJobHandler(fn, options = {}) {\n  const handler = (argument, context) => {\n    const description = context.description;\n    const inboundBus = context.inboundBus;\n    const inputChannel = new rxjs_1.Subject();\n    let subscription;\n    return new rxjs_1.Observable(subject => {\n      function complete() {\n        if (subscription) {\n          subscription.unsubscribe();\n        }\n        subject.next({\n          kind: api_1.JobOutboundMessageKind.End,\n          description\n        });\n        subject.complete();\n        inputChannel.complete();\n      }\n      // Handle input.\n      const inboundSub = inboundBus.subscribe(message => {\n        switch (message.kind) {\n          case api_1.JobInboundMessageKind.Ping:\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.Pong,\n              description,\n              id: message.id\n            });\n            break;\n          case api_1.JobInboundMessageKind.Stop:\n            // There's no way to cancel a promise or a synchronous function, but we do cancel\n            // observables where possible.\n            complete();\n            break;\n          case api_1.JobInboundMessageKind.Input:\n            inputChannel.next(message.value);\n            break;\n        }\n      });\n      // Execute the function with the additional context.\n      const channels = new Map();\n      const newContext = {\n        ...context,\n        input: inputChannel.asObservable(),\n        createChannel(name) {\n          if (channels.has(name)) {\n            throw new ChannelAlreadyExistException(name);\n          }\n          const channelSubject = new rxjs_1.Subject();\n          const channelSub = channelSubject.subscribe(message => {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelMessage,\n              description,\n              name,\n              message\n            });\n          }, error => {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelError,\n              description,\n              name,\n              error\n            });\n            // This can be reopened.\n            channels.delete(name);\n          }, () => {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelComplete,\n              description,\n              name\n            });\n            // This can be reopened.\n            channels.delete(name);\n          });\n          channels.set(name, channelSubject);\n          if (subscription) {\n            subscription.add(channelSub);\n          }\n          return channelSubject;\n        }\n      };\n      subject.next({\n        kind: api_1.JobOutboundMessageKind.Start,\n        description\n      });\n      let result = fn(argument, newContext);\n      // If the result is a promise, simply wait for it to complete before reporting the result.\n      if ((0, core_1.isPromise)(result)) {\n        result = (0, rxjs_1.from)(result);\n      } else if (!(0, rxjs_1.isObservable)(result)) {\n        result = (0, rxjs_1.of)(result);\n      }\n      subscription = result.subscribe(value => subject.next({\n        kind: api_1.JobOutboundMessageKind.Output,\n        description,\n        value\n      }), error => subject.error(error), () => complete());\n      subscription.add(inboundSub);\n      return subscription;\n    });\n  };\n  return Object.assign(handler, {\n    jobDescription: options\n  });\n}\nexports.createJobHandler = createJobHandler;\n/**\n * Lazily create a job using a function.\n * @param loader A factory function that returns a promise/observable of a JobHandler.\n * @param options Same options as createJob.\n */\nfunction createJobFactory(loader, options = {}) {\n  const handler = (argument, context) => {\n    return (0, rxjs_1.from)(loader()).pipe((0, operators_1.switchMap)(fn => fn(argument, context)));\n  };\n  return Object.assign(handler, {\n    jobDescription: options\n  });\n}\nexports.createJobFactory = createJobFactory;\n/**\n * Creates a job that logs out input/output messages of another Job. The messages are still\n * propagated to the other job.\n */\nfunction createLoggerJob(job, logger) {\n  const handler = (argument, context) => {\n    context.inboundBus.pipe((0, operators_1.tap)(message => logger.info(`Input: ${JSON.stringify(message)}`))).subscribe();\n    return job(argument, context).pipe((0, operators_1.tap)(message => logger.info(`Message: ${JSON.stringify(message)}`), error => logger.warn(`Error: ${JSON.stringify(error)}`), () => logger.info(`Completed`)));\n  };\n  return Object.assign(handler, job);\n}\nexports.createLoggerJob = createLoggerJob;","map":{"version":3,"names":["Object","defineProperty","exports","value","createLoggerJob","createJobFactory","createJobHandler","ChannelAlreadyExistException","core_1","require","rxjs_1","operators_1","api_1","BaseException","constructor","name","JSON","stringify","fn","options","handler","argument","context","description","inboundBus","inputChannel","Subject","subscription","Observable","subject","complete","unsubscribe","next","kind","JobOutboundMessageKind","End","inboundSub","subscribe","message","JobInboundMessageKind","Ping","Pong","id","Stop","Input","channels","Map","newContext","input","asObservable","createChannel","has","channelSubject","channelSub","ChannelMessage","error","ChannelError","delete","ChannelComplete","set","add","Start","result","isPromise","from","isObservable","of","Output","assign","jobDescription","loader","pipe","switchMap","job","logger","tap","info","warn"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/node_modules/@angular-devkit/architect/src/jobs/create-job-handler.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createLoggerJob = exports.createJobFactory = exports.createJobHandler = exports.ChannelAlreadyExistException = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst api_1 = require(\"./api\");\nclass ChannelAlreadyExistException extends core_1.BaseException {\n    constructor(name) {\n        super(`Channel ${JSON.stringify(name)} already exist.`);\n    }\n}\nexports.ChannelAlreadyExistException = ChannelAlreadyExistException;\n/**\n * Make a simple job handler that sets start and end from a function that's synchronous.\n *\n * @param fn The function to create a handler for.\n * @param options An optional set of properties to set on the handler. Some fields might be\n *   required by registry or schedulers.\n */\nfunction createJobHandler(fn, options = {}) {\n    const handler = (argument, context) => {\n        const description = context.description;\n        const inboundBus = context.inboundBus;\n        const inputChannel = new rxjs_1.Subject();\n        let subscription;\n        return new rxjs_1.Observable((subject) => {\n            function complete() {\n                if (subscription) {\n                    subscription.unsubscribe();\n                }\n                subject.next({ kind: api_1.JobOutboundMessageKind.End, description });\n                subject.complete();\n                inputChannel.complete();\n            }\n            // Handle input.\n            const inboundSub = inboundBus.subscribe((message) => {\n                switch (message.kind) {\n                    case api_1.JobInboundMessageKind.Ping:\n                        subject.next({ kind: api_1.JobOutboundMessageKind.Pong, description, id: message.id });\n                        break;\n                    case api_1.JobInboundMessageKind.Stop:\n                        // There's no way to cancel a promise or a synchronous function, but we do cancel\n                        // observables where possible.\n                        complete();\n                        break;\n                    case api_1.JobInboundMessageKind.Input:\n                        inputChannel.next(message.value);\n                        break;\n                }\n            });\n            // Execute the function with the additional context.\n            const channels = new Map();\n            const newContext = {\n                ...context,\n                input: inputChannel.asObservable(),\n                createChannel(name) {\n                    if (channels.has(name)) {\n                        throw new ChannelAlreadyExistException(name);\n                    }\n                    const channelSubject = new rxjs_1.Subject();\n                    const channelSub = channelSubject.subscribe((message) => {\n                        subject.next({\n                            kind: api_1.JobOutboundMessageKind.ChannelMessage,\n                            description,\n                            name,\n                            message,\n                        });\n                    }, (error) => {\n                        subject.next({ kind: api_1.JobOutboundMessageKind.ChannelError, description, name, error });\n                        // This can be reopened.\n                        channels.delete(name);\n                    }, () => {\n                        subject.next({ kind: api_1.JobOutboundMessageKind.ChannelComplete, description, name });\n                        // This can be reopened.\n                        channels.delete(name);\n                    });\n                    channels.set(name, channelSubject);\n                    if (subscription) {\n                        subscription.add(channelSub);\n                    }\n                    return channelSubject;\n                },\n            };\n            subject.next({ kind: api_1.JobOutboundMessageKind.Start, description });\n            let result = fn(argument, newContext);\n            // If the result is a promise, simply wait for it to complete before reporting the result.\n            if ((0, core_1.isPromise)(result)) {\n                result = (0, rxjs_1.from)(result);\n            }\n            else if (!(0, rxjs_1.isObservable)(result)) {\n                result = (0, rxjs_1.of)(result);\n            }\n            subscription = result.subscribe((value) => subject.next({ kind: api_1.JobOutboundMessageKind.Output, description, value }), (error) => subject.error(error), () => complete());\n            subscription.add(inboundSub);\n            return subscription;\n        });\n    };\n    return Object.assign(handler, { jobDescription: options });\n}\nexports.createJobHandler = createJobHandler;\n/**\n * Lazily create a job using a function.\n * @param loader A factory function that returns a promise/observable of a JobHandler.\n * @param options Same options as createJob.\n */\nfunction createJobFactory(loader, options = {}) {\n    const handler = (argument, context) => {\n        return (0, rxjs_1.from)(loader()).pipe((0, operators_1.switchMap)((fn) => fn(argument, context)));\n    };\n    return Object.assign(handler, { jobDescription: options });\n}\nexports.createJobFactory = createJobFactory;\n/**\n * Creates a job that logs out input/output messages of another Job. The messages are still\n * propagated to the other job.\n */\nfunction createLoggerJob(job, logger) {\n    const handler = (argument, context) => {\n        context.inboundBus\n            .pipe((0, operators_1.tap)((message) => logger.info(`Input: ${JSON.stringify(message)}`)))\n            .subscribe();\n        return job(argument, context).pipe((0, operators_1.tap)((message) => logger.info(`Message: ${JSON.stringify(message)}`), (error) => logger.warn(`Error: ${JSON.stringify(error)}`), () => logger.info(`Completed`)));\n    };\n    return Object.assign(handler, job);\n}\nexports.createLoggerJob = createLoggerJob;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}