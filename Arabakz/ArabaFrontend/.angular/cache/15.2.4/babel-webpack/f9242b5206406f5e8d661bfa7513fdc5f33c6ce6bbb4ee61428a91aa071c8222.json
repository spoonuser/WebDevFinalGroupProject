{"ast":null,"code":"/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.URI = global.URI || {});\n})(this, function (exports) {\n  'use strict';\n\n  function merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n      sets[_key] = arguments[_key];\n    }\n    if (sets.length > 1) {\n      sets[0] = sets[0].slice(0, -1);\n      var xl = sets.length - 1;\n      for (var x = 1; x < xl; ++x) {\n        sets[x] = sets[x].slice(1, -1);\n      }\n      sets[xl] = sets[xl].slice(1);\n      return sets.join('');\n    } else {\n      return sets[0];\n    }\n  }\n  function subexp(str) {\n    return \"(?:\" + str + \")\";\n  }\n  function typeOf(o) {\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n  }\n  function toUpperCase(str) {\n    return str.toUpperCase();\n  }\n  function toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n  }\n  function assign(target, source) {\n    var obj = target;\n    if (source) {\n      for (var key in source) {\n        obj[key] = source[key];\n      }\n    }\n    return obj;\n  }\n  function buildExps(isIRI) {\n    var ALPHA$$ = \"[A-Za-z]\",\n      CR$ = \"[\\\\x0D]\",\n      DIGIT$$ = \"[0-9]\",\n      DQUOTE$$ = \"[\\\\x22]\",\n      HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n      //case-insensitive\n      LF$$ = \"[\\\\x0A]\",\n      SP$$ = \"[\\\\x20]\",\n      PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n      //expanded\n      GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n      SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n      RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n      UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n      //subset, excludes bidi control characters\n      IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n      //subset\n      UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n      SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n      USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n      DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n      DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n      //relaxed parsing rules\n      IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n      H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n      LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n      IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n      //                           6( h16 \":\" ) ls32\n      IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n      //                      \"::\" 5( h16 \":\" ) ls32\n      IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n      //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n      IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n      //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n      IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n      //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n      IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n      //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n      IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n      //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n      IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n      //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n      IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n      //[ *6( h16 \":\" ) h16 ] \"::\"\n      IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n      ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n      //RFC 6874\n      IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n      //RFC 6874\n      IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n      //RFC 6874, with relaxed parsing rules\n      IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n      IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n      //RFC 6874\n      REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n      HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n      PORT$ = subexp(DIGIT$$ + \"*\"),\n      AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n      PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n      SEGMENT$ = subexp(PCHAR$ + \"*\"),\n      SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n      SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n      PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n      PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n      //simplified\n      PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n      //simplified\n      PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n      //simplified\n      PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n      PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n      QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n      FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n      HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n      URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n      RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n      RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n      URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n      ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n      GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n      RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n      ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n      SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n      AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n    return {\n      NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n      NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n      NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n      ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n      UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n      OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n      PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n      IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n      IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n    };\n  }\n\n  var URI_PROTOCOL = buildExps(false);\n  var IRI_PROTOCOL = buildExps(true);\n  var slicedToArray = function () {\n    function sliceIterator(arr, i) {\n      var _arr = [];\n      var _n = true;\n      var _d = false;\n      var _e = undefined;\n      try {\n        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n          _arr.push(_s.value);\n          if (i && _arr.length === i) break;\n        }\n      } catch (err) {\n        _d = true;\n        _e = err;\n      } finally {\n        try {\n          if (!_n && _i[\"return\"]) _i[\"return\"]();\n        } finally {\n          if (_d) throw _e;\n        }\n      }\n      return _arr;\n    }\n    return function (arr, i) {\n      if (Array.isArray(arr)) {\n        return arr;\n      } else if (Symbol.iterator in Object(arr)) {\n        return sliceIterator(arr, i);\n      } else {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n    };\n  }();\n  var toConsumableArray = function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n\n  /** Highest positive signed 32-bit float value */\n\n  var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n  /** Bootstring parameters */\n  var base = 36;\n  var tMin = 1;\n  var tMax = 26;\n  var skew = 38;\n  var damp = 700;\n  var initialBias = 72;\n  var initialN = 128; // 0x80\n  var delimiter = '-'; // '\\x2D'\n\n  /** Regular expressions */\n  var regexPunycode = /^xn--/;\n  var regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\n  var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n  /** Error messages */\n  var errors = {\n    'overflow': 'Overflow: input needs wider integers to process',\n    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n    'invalid-input': 'Invalid input'\n  };\n\n  /** Convenience shortcuts */\n  var baseMinusTMin = base - tMin;\n  var floor = Math.floor;\n  var stringFromCharCode = String.fromCharCode;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A generic error utility function.\n   * @private\n   * @param {String} type The error type.\n   * @returns {Error} Throws a `RangeError` with the applicable error message.\n   */\n  function error$1(type) {\n    throw new RangeError(errors[type]);\n  }\n\n  /**\n   * A generic `Array#map` utility function.\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} callback The function that gets called for every array\n   * item.\n   * @returns {Array} A new array of values returned by the callback function.\n   */\n  function map(array, fn) {\n    var result = [];\n    var length = array.length;\n    while (length--) {\n      result[length] = fn(array[length]);\n    }\n    return result;\n  }\n\n  /**\n   * A simple `Array#map`-like wrapper to work with domain name strings or email\n   * addresses.\n   * @private\n   * @param {String} domain The domain name or email address.\n   * @param {Function} callback The function that gets called for every\n   * character.\n   * @returns {Array} A new string of characters returned by the callback\n   * function.\n   */\n  function mapDomain(string, fn) {\n    var parts = string.split('@');\n    var result = '';\n    if (parts.length > 1) {\n      // In email addresses, only the domain name should be punycoded. Leave\n      // the local part (i.e. everything up to `@`) intact.\n      result = parts[0] + '@';\n      string = parts[1];\n    }\n    // Avoid `split(regex)` for IE8 compatibility. See #17.\n    string = string.replace(regexSeparators, '\\x2E');\n    var labels = string.split('.');\n    var encoded = map(labels, fn).join('.');\n    return result + encoded;\n  }\n\n  /**\n   * Creates an array containing the numeric code points of each Unicode\n   * character in the string. While JavaScript uses UCS-2 internally,\n   * this function will convert a pair of surrogate halves (each of which\n   * UCS-2 exposes as separate characters) into a single code point,\n   * matching UTF-16.\n   * @see `punycode.ucs2.encode`\n   * @see <https://mathiasbynens.be/notes/javascript-encoding>\n   * @memberOf punycode.ucs2\n   * @name decode\n   * @param {String} string The Unicode input string (UCS-2).\n   * @returns {Array} The new array of code points.\n   */\n  function ucs2decode(string) {\n    var output = [];\n    var counter = 0;\n    var length = string.length;\n    while (counter < length) {\n      var value = string.charCodeAt(counter++);\n      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n        // It's a high surrogate, and there is a next character.\n        var extra = string.charCodeAt(counter++);\n        if ((extra & 0xFC00) == 0xDC00) {\n          // Low surrogate.\n          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n        } else {\n          // It's an unmatched surrogate; only append this code unit, in case the\n          // next code unit is the high surrogate of a surrogate pair.\n          output.push(value);\n          counter--;\n        }\n      } else {\n        output.push(value);\n      }\n    }\n    return output;\n  }\n\n  /**\n   * Creates a string based on an array of numeric code points.\n   * @see `punycode.ucs2.decode`\n   * @memberOf punycode.ucs2\n   * @name encode\n   * @param {Array} codePoints The array of numeric code points.\n   * @returns {String} The new Unicode string (UCS-2).\n   */\n  var ucs2encode = function ucs2encode(array) {\n    return String.fromCodePoint.apply(String, toConsumableArray(array));\n  };\n\n  /**\n   * Converts a basic code point into a digit/integer.\n   * @see `digitToBasic()`\n   * @private\n   * @param {Number} codePoint The basic numeric code point value.\n   * @returns {Number} The numeric value of a basic code point (for use in\n   * representing integers) in the range `0` to `base - 1`, or `base` if\n   * the code point does not represent a value.\n   */\n  var basicToDigit = function basicToDigit(codePoint) {\n    if (codePoint - 0x30 < 0x0A) {\n      return codePoint - 0x16;\n    }\n    if (codePoint - 0x41 < 0x1A) {\n      return codePoint - 0x41;\n    }\n    if (codePoint - 0x61 < 0x1A) {\n      return codePoint - 0x61;\n    }\n    return base;\n  };\n\n  /**\n   * Converts a digit/integer into a basic code point.\n   * @see `basicToDigit()`\n   * @private\n   * @param {Number} digit The numeric value of a basic code point.\n   * @returns {Number} The basic code point whose value (when used for\n   * representing integers) is `digit`, which needs to be in the range\n   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n   * used; else, the lowercase form is used. The behavior is undefined\n   * if `flag` is non-zero and `digit` has no uppercase form.\n   */\n  var digitToBasic = function digitToBasic(digit, flag) {\n    //  0..25 map to ASCII a..z or A..Z\n    // 26..35 map to ASCII 0..9\n    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n  };\n\n  /**\n   * Bias adaptation function as per section 3.4 of RFC 3492.\n   * https://tools.ietf.org/html/rfc3492#section-3.4\n   * @private\n   */\n  var adapt = function adapt(delta, numPoints, firstTime) {\n    var k = 0;\n    delta = firstTime ? floor(delta / damp) : delta >> 1;\n    delta += floor(delta / numPoints);\n    for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n      delta = floor(delta / baseMinusTMin);\n    }\n    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n  };\n\n  /**\n   * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n   * symbols.\n   * @memberOf punycode\n   * @param {String} input The Punycode string of ASCII-only symbols.\n   * @returns {String} The resulting string of Unicode symbols.\n   */\n  var decode = function decode(input) {\n    // Don't use UCS-2.\n    var output = [];\n    var inputLength = input.length;\n    var i = 0;\n    var n = initialN;\n    var bias = initialBias;\n\n    // Handle the basic code points: let `basic` be the number of input code\n    // points before the last delimiter, or `0` if there is none, then copy\n    // the first basic code points to the output.\n\n    var basic = input.lastIndexOf(delimiter);\n    if (basic < 0) {\n      basic = 0;\n    }\n    for (var j = 0; j < basic; ++j) {\n      // if it's not a basic code point\n      if (input.charCodeAt(j) >= 0x80) {\n        error$1('not-basic');\n      }\n      output.push(input.charCodeAt(j));\n    }\n\n    // Main decoding loop: start just after the last delimiter if any basic code\n    // points were copied; start at the beginning otherwise.\n\n    for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n      // `index` is the index of the next character to be consumed.\n      // Decode a generalized variable-length integer into `delta`,\n      // which gets added to `i`. The overflow checking is easier\n      // if we increase `i` as we go, then subtract off its starting\n      // value at the end to obtain `delta`.\n      var oldi = i;\n      for (var w = 1, k = base;; /* no condition */k += base) {\n        if (index >= inputLength) {\n          error$1('invalid-input');\n        }\n        var digit = basicToDigit(input.charCodeAt(index++));\n        if (digit >= base || digit > floor((maxInt - i) / w)) {\n          error$1('overflow');\n        }\n        i += digit * w;\n        var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n        if (digit < t) {\n          break;\n        }\n        var baseMinusT = base - t;\n        if (w > floor(maxInt / baseMinusT)) {\n          error$1('overflow');\n        }\n        w *= baseMinusT;\n      }\n      var out = output.length + 1;\n      bias = adapt(i - oldi, out, oldi == 0);\n\n      // `i` was supposed to wrap around from `out` to `0`,\n      // incrementing `n` each time, so we'll fix that now:\n      if (floor(i / out) > maxInt - n) {\n        error$1('overflow');\n      }\n      n += floor(i / out);\n      i %= out;\n\n      // Insert `n` at position `i` of the output.\n      output.splice(i++, 0, n);\n    }\n    return String.fromCodePoint.apply(String, output);\n  };\n\n  /**\n   * Converts a string of Unicode symbols (e.g. a domain name label) to a\n   * Punycode string of ASCII-only symbols.\n   * @memberOf punycode\n   * @param {String} input The string of Unicode symbols.\n   * @returns {String} The resulting Punycode string of ASCII-only symbols.\n   */\n  var encode = function encode(input) {\n    var output = [];\n\n    // Convert the input in UCS-2 to an array of Unicode code points.\n    input = ucs2decode(input);\n\n    // Cache the length.\n    var inputLength = input.length;\n\n    // Initialize the state.\n    var n = initialN;\n    var delta = 0;\n    var bias = initialBias;\n\n    // Handle the basic code points.\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n    try {\n      for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _currentValue2 = _step.value;\n        if (_currentValue2 < 0x80) {\n          output.push(stringFromCharCode(_currentValue2));\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    var basicLength = output.length;\n    var handledCPCount = basicLength;\n\n    // `handledCPCount` is the number of code points that have been handled;\n    // `basicLength` is the number of basic code points.\n\n    // Finish the basic string with a delimiter unless it's empty.\n    if (basicLength) {\n      output.push(delimiter);\n    }\n\n    // Main encoding loop:\n    while (handledCPCount < inputLength) {\n      // All non-basic code points < n have been handled already. Find the next\n      // larger one:\n      var m = maxInt;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n      try {\n        for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var currentValue = _step2.value;\n          if (currentValue >= n && currentValue < m) {\n            m = currentValue;\n          }\n        }\n\n        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n        // but guard against overflow.\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n      var handledCPCountPlusOne = handledCPCount + 1;\n      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n        error$1('overflow');\n      }\n      delta += (m - n) * handledCPCountPlusOne;\n      n = m;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n      try {\n        for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _currentValue = _step3.value;\n          if (_currentValue < n && ++delta > maxInt) {\n            error$1('overflow');\n          }\n          if (_currentValue == n) {\n            // Represent delta as a generalized variable-length integer.\n            var q = delta;\n            for (var k = base;; /* no condition */k += base) {\n              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n              if (q < t) {\n                break;\n              }\n              var qMinusT = q - t;\n              var baseMinusT = base - t;\n              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n              q = floor(qMinusT / baseMinusT);\n            }\n            output.push(stringFromCharCode(digitToBasic(q, 0)));\n            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n            delta = 0;\n            ++handledCPCount;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n      ++delta;\n      ++n;\n    }\n    return output.join('');\n  };\n\n  /**\n   * Converts a Punycode string representing a domain name or an email address\n   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n   * it doesn't matter if you call it on a string that has already been\n   * converted to Unicode.\n   * @memberOf punycode\n   * @param {String} input The Punycoded domain name or email address to\n   * convert to Unicode.\n   * @returns {String} The Unicode representation of the given Punycode\n   * string.\n   */\n  var toUnicode = function toUnicode(input) {\n    return mapDomain(input, function (string) {\n      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n    });\n  };\n\n  /**\n   * Converts a Unicode string representing a domain name or an email address to\n   * Punycode. Only the non-ASCII parts of the domain name will be converted,\n   * i.e. it doesn't matter if you call it with a domain that's already in\n   * ASCII.\n   * @memberOf punycode\n   * @param {String} input The domain name or email address to convert, as a\n   * Unicode string.\n   * @returns {String} The Punycode representation of the given domain name or\n   * email address.\n   */\n  var toASCII = function toASCII(input) {\n    return mapDomain(input, function (string) {\n      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n    });\n  };\n\n  /*--------------------------------------------------------------------------*/\n\n  /** Define the public API */\n  var punycode = {\n    /**\n     * A string representing the current Punycode.js version number.\n     * @memberOf punycode\n     * @type String\n     */\n    'version': '2.1.0',\n    /**\n     * An object of methods to convert from JavaScript's internal character\n     * representation (UCS-2) to Unicode code points, and back.\n     * @see <https://mathiasbynens.be/notes/javascript-encoding>\n     * @memberOf punycode\n     * @type Object\n     */\n    'ucs2': {\n      'decode': ucs2decode,\n      'encode': ucs2encode\n    },\n    'decode': decode,\n    'encode': encode,\n    'toASCII': toASCII,\n    'toUnicode': toUnicode\n  };\n\n  /**\n   * URI.js\n   *\n   * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n   * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n   * @see http://github.com/garycourt/uri-js\n   */\n  /**\n   * Copyright 2011 Gary Court. All rights reserved.\n   *\n   * Redistribution and use in source and binary forms, with or without modification, are\n   * permitted provided that the following conditions are met:\n   *\n   *    1. Redistributions of source code must retain the above copyright notice, this list of\n   *       conditions and the following disclaimer.\n   *\n   *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n   *       of conditions and the following disclaimer in the documentation and/or other materials\n   *       provided with the distribution.\n   *\n   * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n   * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n   * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n   * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n   *\n   * The views and conclusions contained in the software and documentation are those of the\n   * authors and should not be interpreted as representing official policies, either expressed\n   * or implied, of Gary Court.\n   */\n  var SCHEMES = {};\n  function pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n  }\n  function pctDecChars(str) {\n    var newStr = \"\";\n    var i = 0;\n    var il = str.length;\n    while (i < il) {\n      var c = parseInt(str.substr(i + 1, 2), 16);\n      if (c < 128) {\n        newStr += String.fromCharCode(c);\n        i += 3;\n      } else if (c >= 194 && c < 224) {\n        if (il - i >= 6) {\n          var c2 = parseInt(str.substr(i + 4, 2), 16);\n          newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n        } else {\n          newStr += str.substr(i, 6);\n        }\n        i += 6;\n      } else if (c >= 224) {\n        if (il - i >= 9) {\n          var _c = parseInt(str.substr(i + 4, 2), 16);\n          var c3 = parseInt(str.substr(i + 7, 2), 16);\n          newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n        } else {\n          newStr += str.substr(i, 9);\n        }\n        i += 9;\n      } else {\n        newStr += str.substr(i, 3);\n        i += 3;\n      }\n    }\n    return newStr;\n  }\n  function _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n      var decStr = pctDecChars(str);\n      return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n  }\n  function _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n  }\n  function _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n    var _matches = slicedToArray(matches, 2),\n      address = _matches[1];\n    if (address) {\n      return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    } else {\n      return host;\n    }\n  }\n  function _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n    var _matches2 = slicedToArray(matches, 3),\n      address = _matches2[1],\n      zone = _matches2[2];\n    if (address) {\n      var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n        _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n        last = _address$toLowerCase$2[0],\n        first = _address$toLowerCase$2[1];\n      var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n      var lastFields = last.split(\":\").map(_stripLeadingZeros);\n      var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n      var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n      var lastFieldsStart = lastFields.length - fieldCount;\n      var fields = Array(fieldCount);\n      for (var x = 0; x < fieldCount; ++x) {\n        fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n      }\n      if (isLastFieldIPv4Address) {\n        fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n      }\n      var allZeroFields = fields.reduce(function (acc, field, index) {\n        if (!field || field === \"0\") {\n          var lastLongest = acc[acc.length - 1];\n          if (lastLongest && lastLongest.index + lastLongest.length === index) {\n            lastLongest.length++;\n          } else {\n            acc.push({\n              index: index,\n              length: 1\n            });\n          }\n        }\n        return acc;\n      }, []);\n      var longestZeroFields = allZeroFields.sort(function (a, b) {\n        return b.length - a.length;\n      })[0];\n      var newHost = void 0;\n      if (longestZeroFields && longestZeroFields.length > 1) {\n        var newFirst = fields.slice(0, longestZeroFields.index);\n        var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n        newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n      } else {\n        newHost = fields.join(\":\");\n      }\n      if (zone) {\n        newHost += \"%\" + zone;\n      }\n      return newHost;\n    } else {\n      return host;\n    }\n  }\n  var URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\n  var NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\n  function parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    var matches = uriString.match(URI_PARSE);\n    if (matches) {\n      if (NO_MATCH_IS_UNDEFINED) {\n        //store each component\n        components.scheme = matches[1];\n        components.userinfo = matches[3];\n        components.host = matches[4];\n        components.port = parseInt(matches[5], 10);\n        components.path = matches[6] || \"\";\n        components.query = matches[7];\n        components.fragment = matches[8];\n        //fix port number\n        if (isNaN(components.port)) {\n          components.port = matches[5];\n        }\n      } else {\n        //IE FIX for improper RegExp matching\n        //store each component\n        components.scheme = matches[1] || undefined;\n        components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n        components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n        components.port = parseInt(matches[5], 10);\n        components.path = matches[6] || \"\";\n        components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n        components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n        //fix port number\n        if (isNaN(components.port)) {\n          components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n        }\n      }\n      if (components.host) {\n        //normalize IP hosts\n        components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n      }\n      //determine reference type\n      if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n        components.reference = \"same-document\";\n      } else if (components.scheme === undefined) {\n        components.reference = \"relative\";\n      } else if (components.fragment === undefined) {\n        components.reference = \"absolute\";\n      } else {\n        components.reference = \"uri\";\n      }\n      //check for reference errors\n      if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n        components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n      }\n      //find scheme handler\n      var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n      //check if scheme can't handle IRIs\n      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n        //if host component is a domain name\n        if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n          //convert Unicode IDN -> ASCII IDN\n          try {\n            components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n          } catch (e) {\n            components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n          }\n        }\n        //convert IRI -> URI\n        _normalizeComponentEncoding(components, URI_PROTOCOL);\n      } else {\n        //normalize encodings\n        _normalizeComponentEncoding(components, protocol);\n      }\n      //perform scheme specific parsing\n      if (schemeHandler && schemeHandler.parse) {\n        schemeHandler.parse(components, options);\n      }\n    } else {\n      components.error = components.error || \"URI can not be parsed.\";\n    }\n    return components;\n  }\n  function _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    if (components.userinfo !== undefined) {\n      uriTokens.push(components.userinfo);\n      uriTokens.push(\"@\");\n    }\n    if (components.host !== undefined) {\n      //normalize IP hosts, add brackets and escape zone separator for IPv6\n      uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n        return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n      }));\n    }\n    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n      uriTokens.push(\":\");\n      uriTokens.push(String(components.port));\n    }\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n  }\n  var RDS1 = /^\\.\\.?\\//;\n  var RDS2 = /^\\/\\.(\\/|$)/;\n  var RDS3 = /^\\/\\.\\.(\\/|$)/;\n  var RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n  function removeDotSegments(input) {\n    var output = [];\n    while (input.length) {\n      if (input.match(RDS1)) {\n        input = input.replace(RDS1, \"\");\n      } else if (input.match(RDS2)) {\n        input = input.replace(RDS2, \"/\");\n      } else if (input.match(RDS3)) {\n        input = input.replace(RDS3, \"/\");\n        output.pop();\n      } else if (input === \".\" || input === \"..\") {\n        input = \"\";\n      } else {\n        var im = input.match(RDS5);\n        if (im) {\n          var s = im[0];\n          input = input.slice(s.length);\n          output.push(s);\n        } else {\n          throw new Error(\"Unexpected dot segment condition\");\n        }\n      }\n    }\n    return output.join(\"\");\n  }\n  function serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    //find scheme handler\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n    if (components.host) {\n      //if host component is an IPv6 address\n      if (protocol.IPV6ADDRESS.test(components.host)) {}\n      //TODO: normalize IPv6 address as per RFC 5952\n\n      //if host component is a domain name\n      else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n        //convert IDN via punycode\n        try {\n          components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n        } catch (e) {\n          components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n        }\n      }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== \"suffix\" && components.scheme) {\n      uriTokens.push(components.scheme);\n      uriTokens.push(\":\");\n    }\n    var authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n      if (options.reference !== \"suffix\") {\n        uriTokens.push(\"//\");\n      }\n      uriTokens.push(authority);\n      if (components.path && components.path.charAt(0) !== \"/\") {\n        uriTokens.push(\"/\");\n      }\n    }\n    if (components.path !== undefined) {\n      var s = components.path;\n      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n        s = removeDotSegments(s);\n      }\n      if (authority === undefined) {\n        s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n      }\n\n      uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n      uriTokens.push(\"?\");\n      uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n      uriTokens.push(\"#\");\n      uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(\"\"); //merge tokens into a string\n  }\n\n  function resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n    var target = {};\n    if (!skipNormalization) {\n      base = parse(serialize(base, options), options); //normalize base components\n      relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n      target.scheme = relative.scheme;\n      //target.authority = relative.authority;\n      target.userinfo = relative.userinfo;\n      target.host = relative.host;\n      target.port = relative.port;\n      target.path = removeDotSegments(relative.path || \"\");\n      target.query = relative.query;\n    } else {\n      if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n      } else {\n        if (!relative.path) {\n          target.path = base.path;\n          if (relative.query !== undefined) {\n            target.query = relative.query;\n          } else {\n            target.query = base.query;\n          }\n        } else {\n          if (relative.path.charAt(0) === \"/\") {\n            target.path = removeDotSegments(relative.path);\n          } else {\n            if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n              target.path = \"/\" + relative.path;\n            } else if (!base.path) {\n              target.path = relative.path;\n            } else {\n              target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n            }\n            target.path = removeDotSegments(target.path);\n          }\n          target.query = relative.query;\n        }\n        //target.authority = base.authority;\n        target.userinfo = base.userinfo;\n        target.host = base.host;\n        target.port = base.port;\n      }\n      target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n  }\n  function resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({\n      scheme: 'null'\n    }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n  }\n  function normalize(uri, options) {\n    if (typeof uri === \"string\") {\n      uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === \"object\") {\n      uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n  }\n  function equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n      uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === \"object\") {\n      uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === \"string\") {\n      uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === \"object\") {\n      uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n  }\n  function escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n  }\n  function unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n  }\n  var handler = {\n    scheme: \"http\",\n    domainHost: true,\n    parse: function parse(components, options) {\n      //report missing host\n      if (!components.host) {\n        components.error = components.error || \"HTTP URIs must have a host.\";\n      }\n      return components;\n    },\n    serialize: function serialize(components, options) {\n      var secure = String(components.scheme).toLowerCase() === \"https\";\n      //normalize the default port\n      if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n        components.port = undefined;\n      }\n      //normalize the empty path\n      if (!components.path) {\n        components.path = \"/\";\n      }\n      //NOTE: We do not parse query strings for HTTP URIs\n      //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n      //and not the HTTP spec.\n      return components;\n    }\n  };\n  var handler$1 = {\n    scheme: \"https\",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n  };\n  function isSecure(wsComponents) {\n    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n  }\n  //RFC 6455\n  var handler$2 = {\n    scheme: \"ws\",\n    domainHost: true,\n    parse: function parse(components, options) {\n      var wsComponents = components;\n      //indicate if the secure flag is set\n      wsComponents.secure = isSecure(wsComponents);\n      //construct resouce name\n      wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n      wsComponents.path = undefined;\n      wsComponents.query = undefined;\n      return wsComponents;\n    },\n    serialize: function serialize(wsComponents, options) {\n      //normalize the default port\n      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n        wsComponents.port = undefined;\n      }\n      //ensure scheme matches secure flag\n      if (typeof wsComponents.secure === 'boolean') {\n        wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\n        wsComponents.secure = undefined;\n      }\n      //reconstruct path from resource name\n      if (wsComponents.resourceName) {\n        var _wsComponents$resourc = wsComponents.resourceName.split('?'),\n          _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n          path = _wsComponents$resourc2[0],\n          query = _wsComponents$resourc2[1];\n        wsComponents.path = path && path !== '/' ? path : undefined;\n        wsComponents.query = query;\n        wsComponents.resourceName = undefined;\n      }\n      //forbid fragment component\n      wsComponents.fragment = undefined;\n      return wsComponents;\n    }\n  };\n  var handler$3 = {\n    scheme: \"wss\",\n    domainHost: handler$2.domainHost,\n    parse: handler$2.parse,\n    serialize: handler$2.serialize\n  };\n  var O = {};\n  var isIRI = true;\n  //RFC 3986\n  var UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\n  var HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\n  var PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n  //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n  //const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n  //const WSP$$ = \"[\\\\x20\\\\x09]\";\n  //const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n  //const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n  //const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n  //const WSP$$ = \"[\\\\x20\\\\x09]\";\n  //const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n  //const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n  //const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n  //const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\n  var ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n  var QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\n  var VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\n  var SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\n  var UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\n  var PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\n  var NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\n  var NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\n  var NOT_HFVALUE = NOT_HFNAME;\n  function decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n  }\n  var handler$4 = {\n    scheme: \"mailto\",\n    parse: function parse$$1(components, options) {\n      var mailtoComponents = components;\n      var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n      mailtoComponents.path = undefined;\n      if (mailtoComponents.query) {\n        var unknownHeaders = false;\n        var headers = {};\n        var hfields = mailtoComponents.query.split(\"&\");\n        for (var x = 0, xl = hfields.length; x < xl; ++x) {\n          var hfield = hfields[x].split(\"=\");\n          switch (hfield[0]) {\n            case \"to\":\n              var toAddrs = hfield[1].split(\",\");\n              for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                to.push(toAddrs[_x]);\n              }\n              break;\n            case \"subject\":\n              mailtoComponents.subject = unescapeComponent(hfield[1], options);\n              break;\n            case \"body\":\n              mailtoComponents.body = unescapeComponent(hfield[1], options);\n              break;\n            default:\n              unknownHeaders = true;\n              headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n              break;\n          }\n        }\n        if (unknownHeaders) mailtoComponents.headers = headers;\n      }\n      mailtoComponents.query = undefined;\n      for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n        var addr = to[_x2].split(\"@\");\n        addr[0] = unescapeComponent(addr[0]);\n        if (!options.unicodeSupport) {\n          //convert Unicode IDN -> ASCII IDN\n          try {\n            addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n          } catch (e) {\n            mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n          }\n        } else {\n          addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n        }\n        to[_x2] = addr.join(\"@\");\n      }\n      return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n      var components = mailtoComponents;\n      var to = toArray(mailtoComponents.to);\n      if (to) {\n        for (var x = 0, xl = to.length; x < xl; ++x) {\n          var toAddr = String(to[x]);\n          var atIdx = toAddr.lastIndexOf(\"@\");\n          var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n          var domain = toAddr.slice(atIdx + 1);\n          //convert IDN via punycode\n          try {\n            domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n          } catch (e) {\n            components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n          }\n          to[x] = localPart + \"@\" + domain;\n        }\n        components.path = to.join(\",\");\n      }\n      var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n      if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n      if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n      var fields = [];\n      for (var name in headers) {\n        if (headers[name] !== O[name]) {\n          fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n        }\n      }\n      if (fields.length) {\n        components.query = fields.join(\"&\");\n      }\n      return components;\n    }\n  };\n  var URN_PARSE = /^([^\\:]+)\\:(.*)/;\n  //RFC 2141\n  var handler$5 = {\n    scheme: \"urn\",\n    parse: function parse$$1(components, options) {\n      var matches = components.path && components.path.match(URN_PARSE);\n      var urnComponents = components;\n      if (matches) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = matches[1].toLowerCase();\n        var nss = matches[2];\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        urnComponents.nid = nid;\n        urnComponents.nss = nss;\n        urnComponents.path = undefined;\n        if (schemeHandler) {\n          urnComponents = schemeHandler.parse(urnComponents, options);\n        }\n      } else {\n        urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n      }\n      return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n      var scheme = options.scheme || urnComponents.scheme || \"urn\";\n      var nid = urnComponents.nid;\n      var urnScheme = scheme + \":\" + (options.nid || nid);\n      var schemeHandler = SCHEMES[urnScheme];\n      if (schemeHandler) {\n        urnComponents = schemeHandler.serialize(urnComponents, options);\n      }\n      var uriComponents = urnComponents;\n      var nss = urnComponents.nss;\n      uriComponents.path = (nid || options.nid) + \":\" + nss;\n      return uriComponents;\n    }\n  };\n  var UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n  //RFC 4122\n  var handler$6 = {\n    scheme: \"urn:uuid\",\n    parse: function parse(urnComponents, options) {\n      var uuidComponents = urnComponents;\n      uuidComponents.uuid = uuidComponents.nss;\n      uuidComponents.nss = undefined;\n      if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n        uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n      }\n      return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n      var urnComponents = uuidComponents;\n      //normalize UUID\n      urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n      return urnComponents;\n    }\n  };\n  SCHEMES[handler.scheme] = handler;\n  SCHEMES[handler$1.scheme] = handler$1;\n  SCHEMES[handler$2.scheme] = handler$2;\n  SCHEMES[handler$3.scheme] = handler$3;\n  SCHEMES[handler$4.scheme] = handler$4;\n  SCHEMES[handler$5.scheme] = handler$5;\n  SCHEMES[handler$6.scheme] = handler$6;\n  exports.SCHEMES = SCHEMES;\n  exports.pctEncChar = pctEncChar;\n  exports.pctDecChars = pctDecChars;\n  exports.parse = parse;\n  exports.removeDotSegments = removeDotSegments;\n  exports.serialize = serialize;\n  exports.resolveComponents = resolveComponents;\n  exports.resolve = resolve;\n  exports.normalize = normalize;\n  exports.equal = equal;\n  exports.escapeComponent = escapeComponent;\n  exports.unescapeComponent = unescapeComponent;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","URI","merge","_len","arguments","length","sets","Array","_key","slice","xl","x","join","subexp","str","typeOf","o","undefined","Object","prototype","toString","call","split","pop","shift","toLowerCase","toUpperCase","toArray","obj","setInterval","assign","target","source","key","buildExps","isIRI","ALPHA$$","CR$","DIGIT$$","DQUOTE$$","HEXDIG$$","LF$$","SP$$","PCT_ENCODED$","GEN_DELIMS$$","SUB_DELIMS$$","RESERVED$$","UCSCHAR$$","IPRIVATE$$","UNRESERVED$$","SCHEME$","USERINFO$","DEC_OCTET$","DEC_OCTET_RELAXED$","IPV4ADDRESS$","H16$","LS32$","IPV6ADDRESS1$","IPV6ADDRESS2$","IPV6ADDRESS3$","IPV6ADDRESS4$","IPV6ADDRESS5$","IPV6ADDRESS6$","IPV6ADDRESS7$","IPV6ADDRESS8$","IPV6ADDRESS9$","IPV6ADDRESS$","ZONEID$","IPV6ADDRZ$","IPV6ADDRZ_RELAXED$","IPVFUTURE$","IP_LITERAL$","REG_NAME$","HOST$","PORT$","AUTHORITY$","PCHAR$","SEGMENT$","SEGMENT_NZ$","SEGMENT_NZ_NC$","PATH_ABEMPTY$","PATH_ABSOLUTE$","PATH_NOSCHEME$","PATH_ROOTLESS$","PATH_EMPTY$","PATH$","QUERY$","FRAGMENT$","HIER_PART$","URI$","RELATIVE_PART$","RELATIVE$","URI_REFERENCE$","ABSOLUTE_URI$","GENERIC_REF$","RELATIVE_REF$","ABSOLUTE_REF$","SAMEDOC_REF$","AUTHORITY_REF$","NOT_SCHEME","RegExp","NOT_USERINFO","NOT_HOST","NOT_PATH","NOT_PATH_NOSCHEME","NOT_QUERY","NOT_FRAGMENT","ESCAPE","UNRESERVED","OTHER_CHARS","PCT_ENCODED","IPV4ADDRESS","IPV6ADDRESS","URI_PROTOCOL","IRI_PROTOCOL","slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","_i","Symbol","iterator","_s","next","done","push","value","err","isArray","TypeError","toConsumableArray","arr2","from","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","floor","Math","stringFromCharCode","String","fromCharCode","error$1","type","RangeError","map","array","fn","result","mapDomain","string","parts","replace","labels","encoded","ucs2decode","output","counter","charCodeAt","extra","ucs2encode","fromCodePoint","apply","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","decode","input","inputLength","n","bias","basic","lastIndexOf","j","index","oldi","w","t","baseMinusT","out","splice","encode","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","_currentValue2","return","basicLength","handledCPCount","m","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","currentValue","handledCPCountPlusOne","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","_currentValue","q","qMinusT","toUnicode","test","toASCII","punycode","SCHEMES","pctEncChar","chr","c","e","pctDecChars","newStr","il","parseInt","substr","c2","_c","c3","_normalizeComponentEncoding","components","protocol","decodeUnreserved","decStr","match","scheme","userinfo","host","path","query","fragment","_stripLeadingZeros","_normalizeIPv4","matches","_matches","address","_normalizeIPv6","_matches2","zone","_address$toLowerCase$","reverse","_address$toLowerCase$2","last","first","firstFields","lastFields","isLastFieldIPv4Address","fieldCount","lastFieldsStart","fields","allZeroFields","reduce","acc","field","lastLongest","longestZeroFields","sort","a","b","newHost","newFirst","newLast","URI_PARSE","NO_MATCH_IS_UNDEFINED","parse","uriString","options","iri","reference","port","isNaN","indexOf","error","schemeHandler","unicodeSupport","domainHost","_recomposeAuthority","uriTokens","_","$1","$2","RDS1","RDS2","RDS3","RDS5","removeDotSegments","im","s","Error","serialize","authority","charAt","absolutePath","resolveComponents","relative","skipNormalization","tolerant","resolve","baseURI","relativeURI","schemelessOptions","normalize","uri","equal","uriA","uriB","escapeComponent","unescapeComponent","handler","secure","handler$1","isSecure","wsComponents","handler$2","resourceName","_wsComponents$resourc","_wsComponents$resourc2","handler$3","O","ATEXT$$","QTEXT$$","VCHAR$$","SOME_DELIMS$$","NOT_LOCAL_PART","NOT_HFNAME","NOT_HFVALUE","handler$4","parse$$1","mailtoComponents","to","unknownHeaders","headers","hfields","hfield","toAddrs","_x","_xl","subject","body","_x2","_xl2","addr","serialize$$1","toAddr","atIdx","localPart","domain","name","URN_PARSE","handler$5","urnComponents","nid","nss","urnScheme","uriComponents","UUID","handler$6","uuidComponents","uuid","defineProperty"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/uri-js/dist/es5/uri.all.js"],"sourcesContent":["/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.URI = global.URI || {})));\n}(this, (function (exports) { 'use strict';\n\nfunction merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n        sets[_key] = arguments[_key];\n    }\n\n    if (sets.length > 1) {\n        sets[0] = sets[0].slice(0, -1);\n        var xl = sets.length - 1;\n        for (var x = 1; x < xl; ++x) {\n            sets[x] = sets[x].slice(1, -1);\n        }\n        sets[xl] = sets[xl].slice(1);\n        return sets.join('');\n    } else {\n        return sets[0];\n    }\n}\nfunction subexp(str) {\n    return \"(?:\" + str + \")\";\n}\nfunction typeOf(o) {\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n}\nfunction toUpperCase(str) {\n    return str.toUpperCase();\n}\nfunction toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n}\nfunction assign(target, source) {\n    var obj = target;\n    if (source) {\n        for (var key in source) {\n            obj[key] = source[key];\n        }\n    }\n    return obj;\n}\n\nfunction buildExps(isIRI) {\n    var ALPHA$$ = \"[A-Za-z]\",\n        CR$ = \"[\\\\x0D]\",\n        DIGIT$$ = \"[0-9]\",\n        DQUOTE$$ = \"[\\\\x22]\",\n        HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n        //case-insensitive\n    LF$$ = \"[\\\\x0A]\",\n        SP$$ = \"[\\\\x20]\",\n        PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n        //expanded\n    GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n        SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n        UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n        //subset, excludes bidi control characters\n    IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n        //subset\n    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n        USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n        DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n        DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n        //relaxed parsing rules\n    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n        H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n        LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n        IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n        //                           6( h16 \":\" ) ls32\n    IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n        //                      \"::\" 5( h16 \":\" ) ls32\n    IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n        //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n        //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n        //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n        //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n        //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n        //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n        //[ *6( h16 \":\" ) h16 ] \"::\"\n    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n        ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n        //RFC 6874\n    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n        //RFC 6874\n    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n        //RFC 6874, with relaxed parsing rules\n    IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n        IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n        //RFC 6874\n    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n        HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n        PORT$ = subexp(DIGIT$$ + \"*\"),\n        AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n        PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n        SEGMENT$ = subexp(PCHAR$ + \"*\"),\n        SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n        PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n        PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n        //simplified\n    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n        PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n        FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n        HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n        ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n        GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n        SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n    return {\n        NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n        NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n        NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n        ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n        OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n        PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n        IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n        IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n    };\n}\nvar URI_PROTOCOL = buildExps(false);\n\nvar IRI_PROTOCOL = buildExps(true);\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/** Highest positive signed 32-bit float value */\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nvar regexPunycode = /^xn--/;\nvar regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nvar errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error$1(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tvar result = [];\n\tvar length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tvar parts = string.split('@');\n\tvar result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tvar labels = string.split('.');\n\tvar encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t// Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nvar ucs2encode = function ucs2encode(array) {\n\treturn String.fromCodePoint.apply(String, toConsumableArray(array));\n};\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nvar basicToDigit = function basicToDigit(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nvar digitToBasic = function digitToBasic(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nvar adapt = function adapt(delta, numPoints, firstTime) {\n\tvar k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nvar decode = function decode(input) {\n\t// Don't use UCS-2.\n\tvar output = [];\n\tvar inputLength = input.length;\n\tvar i = 0;\n\tvar n = initialN;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tvar basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (var j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror$1('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tvar oldi = i;\n\t\tfor (var w = 1, k = base;; /* no condition */k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror$1('invalid-input');\n\t\t\t}\n\n\t\t\tvar digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\t\t}\n\n\t\tvar out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\t}\n\n\treturn String.fromCodePoint.apply(String, output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nvar encode = function encode(input) {\n\tvar output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tvar inputLength = input.length;\n\n\t// Initialize the state.\n\tvar n = initialN;\n\tvar delta = 0;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points.\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar _currentValue2 = _step.value;\n\n\t\t\tif (_currentValue2 < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(_currentValue2));\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar basicLength = output.length;\n\tvar handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tvar m = maxInt;\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar currentValue = _step2.value;\n\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow.\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tvar _iteratorNormalCompletion3 = true;\n\t\tvar _didIteratorError3 = false;\n\t\tvar _iteratorError3 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\tvar _currentValue = _step3.value;\n\n\t\t\t\tif (_currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror$1('overflow');\n\t\t\t\t}\n\t\t\t\tif (_currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\t\tvar q = delta;\n\t\t\t\t\tfor (var k = base;; /* no condition */k += base) {\n\t\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar qMinusT = q - t;\n\t\t\t\t\t\tvar baseMinusT = base - t;\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError3 = true;\n\t\t\t_iteratorError3 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t_iterator3.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nvar toUnicode = function toUnicode(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nvar toASCII = function toASCII(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nvar punycode = {\n\t/**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */\n\t'version': '2.1.0',\n\t/**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\nvar SCHEMES = {};\nfunction pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n}\nfunction pctDecChars(str) {\n    var newStr = \"\";\n    var i = 0;\n    var il = str.length;\n    while (i < il) {\n        var c = parseInt(str.substr(i + 1, 2), 16);\n        if (c < 128) {\n            newStr += String.fromCharCode(c);\n            i += 3;\n        } else if (c >= 194 && c < 224) {\n            if (il - i >= 6) {\n                var c2 = parseInt(str.substr(i + 4, 2), 16);\n                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n            } else {\n                newStr += str.substr(i, 6);\n            }\n            i += 6;\n        } else if (c >= 224) {\n            if (il - i >= 9) {\n                var _c = parseInt(str.substr(i + 4, 2), 16);\n                var c3 = parseInt(str.substr(i + 7, 2), 16);\n                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n            } else {\n                newStr += str.substr(i, 9);\n            }\n            i += 9;\n        } else {\n            newStr += str.substr(i, 3);\n            i += 3;\n        }\n    }\n    return newStr;\n}\nfunction _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n}\n\nfunction _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\nfunction _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n\n    var _matches = slicedToArray(matches, 2),\n        address = _matches[1];\n\n    if (address) {\n        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    } else {\n        return host;\n    }\n}\nfunction _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n\n    var _matches2 = slicedToArray(matches, 3),\n        address = _matches2[1],\n        zone = _matches2[2];\n\n    if (address) {\n        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n            last = _address$toLowerCase$2[0],\n            first = _address$toLowerCase$2[1];\n\n        var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n        var lastFields = last.split(\":\").map(_stripLeadingZeros);\n        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n        var lastFieldsStart = lastFields.length - fieldCount;\n        var fields = Array(fieldCount);\n        for (var x = 0; x < fieldCount; ++x) {\n            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n        }\n        if (isLastFieldIPv4Address) {\n            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n        }\n        var allZeroFields = fields.reduce(function (acc, field, index) {\n            if (!field || field === \"0\") {\n                var lastLongest = acc[acc.length - 1];\n                if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                    lastLongest.length++;\n                } else {\n                    acc.push({ index: index, length: 1 });\n                }\n            }\n            return acc;\n        }, []);\n        var longestZeroFields = allZeroFields.sort(function (a, b) {\n            return b.length - a.length;\n        })[0];\n        var newHost = void 0;\n        if (longestZeroFields && longestZeroFields.length > 1) {\n            var newFirst = fields.slice(0, longestZeroFields.index);\n            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n            newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n        } else {\n            newHost = fields.join(\":\");\n        }\n        if (zone) {\n            newHost += \"%\" + zone;\n        }\n        return newHost;\n    } else {\n        return host;\n    }\n}\nvar URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nvar NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\nfunction parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    var matches = uriString.match(URI_PARSE);\n    if (matches) {\n        if (NO_MATCH_IS_UNDEFINED) {\n            //store each component\n            components.scheme = matches[1];\n            components.userinfo = matches[3];\n            components.host = matches[4];\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = matches[7];\n            components.fragment = matches[8];\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = matches[5];\n            }\n        } else {\n            //IE FIX for improper RegExp matching\n            //store each component\n            components.scheme = matches[1] || undefined;\n            components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n            components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n            components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n            }\n        }\n        if (components.host) {\n            //normalize IP hosts\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n        }\n        //determine reference type\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n            components.reference = \"same-document\";\n        } else if (components.scheme === undefined) {\n            components.reference = \"relative\";\n        } else if (components.fragment === undefined) {\n            components.reference = \"absolute\";\n        } else {\n            components.reference = \"uri\";\n        }\n        //check for reference errors\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n            components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n        }\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //check if scheme can't handle IRIs\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n            //if host component is a domain name\n            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            }\n            //convert IRI -> URI\n            _normalizeComponentEncoding(components, URI_PROTOCOL);\n        } else {\n            //normalize encodings\n            _normalizeComponentEncoding(components, protocol);\n        }\n        //perform scheme specific parsing\n        if (schemeHandler && schemeHandler.parse) {\n            schemeHandler.parse(components, options);\n        }\n    } else {\n        components.error = components.error || \"URI can not be parsed.\";\n    }\n    return components;\n}\n\nfunction _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    if (components.userinfo !== undefined) {\n        uriTokens.push(components.userinfo);\n        uriTokens.push(\"@\");\n    }\n    if (components.host !== undefined) {\n        //normalize IP hosts, add brackets and escape zone separator for IPv6\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n            return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n        }));\n    }\n    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n        uriTokens.push(\":\");\n        uriTokens.push(String(components.port));\n    }\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n}\n\nvar RDS1 = /^\\.\\.?\\//;\nvar RDS2 = /^\\/\\.(\\/|$)/;\nvar RDS3 = /^\\/\\.\\.(\\/|$)/;\nvar RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nfunction removeDotSegments(input) {\n    var output = [];\n    while (input.length) {\n        if (input.match(RDS1)) {\n            input = input.replace(RDS1, \"\");\n        } else if (input.match(RDS2)) {\n            input = input.replace(RDS2, \"/\");\n        } else if (input.match(RDS3)) {\n            input = input.replace(RDS3, \"/\");\n            output.pop();\n        } else if (input === \".\" || input === \"..\") {\n            input = \"\";\n        } else {\n            var im = input.match(RDS5);\n            if (im) {\n                var s = im[0];\n                input = input.slice(s.length);\n                output.push(s);\n            } else {\n                throw new Error(\"Unexpected dot segment condition\");\n            }\n        }\n    }\n    return output.join(\"\");\n}\n\nfunction serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    //find scheme handler\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n    if (components.host) {\n        //if host component is an IPv6 address\n        if (protocol.IPV6ADDRESS.test(components.host)) {}\n        //TODO: normalize IPv6 address as per RFC 5952\n\n        //if host component is a domain name\n        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== \"suffix\" && components.scheme) {\n        uriTokens.push(components.scheme);\n        uriTokens.push(\":\");\n    }\n    var authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n        if (options.reference !== \"suffix\") {\n            uriTokens.push(\"//\");\n        }\n        uriTokens.push(authority);\n        if (components.path && components.path.charAt(0) !== \"/\") {\n            uriTokens.push(\"/\");\n        }\n    }\n    if (components.path !== undefined) {\n        var s = components.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n            s = removeDotSegments(s);\n        }\n        if (authority === undefined) {\n            s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n        }\n        uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n        uriTokens.push(\"?\");\n        uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n        uriTokens.push(\"#\");\n        uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(\"\"); //merge tokens into a string\n}\n\nfunction resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n\n    var target = {};\n    if (!skipNormalization) {\n        base = parse(serialize(base, options), options); //normalize base components\n        relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n    } else {\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (!relative.path) {\n                target.path = base.path;\n                if (relative.query !== undefined) {\n                    target.query = relative.query;\n                } else {\n                    target.query = base.query;\n                }\n            } else {\n                if (relative.path.charAt(0) === \"/\") {\n                    target.path = removeDotSegments(relative.path);\n                } else {\n                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                        target.path = \"/\" + relative.path;\n                    } else if (!base.path) {\n                        target.path = relative.path;\n                    } else {\n                        target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                    }\n                    target.path = removeDotSegments(target.path);\n                }\n                target.query = relative.query;\n            }\n            //target.authority = base.authority;\n            target.userinfo = base.userinfo;\n            target.host = base.host;\n            target.port = base.port;\n        }\n        target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n}\n\nfunction resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({ scheme: 'null' }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n}\n\nfunction normalize(uri, options) {\n    if (typeof uri === \"string\") {\n        uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === \"object\") {\n        uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n}\n\nfunction equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n        uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === \"object\") {\n        uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === \"string\") {\n        uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === \"object\") {\n        uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n}\n\nfunction escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n}\n\nfunction unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n}\n\nvar handler = {\n    scheme: \"http\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        //report missing host\n        if (!components.host) {\n            components.error = components.error || \"HTTP URIs must have a host.\";\n        }\n        return components;\n    },\n    serialize: function serialize(components, options) {\n        var secure = String(components.scheme).toLowerCase() === \"https\";\n        //normalize the default port\n        if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n            components.port = undefined;\n        }\n        //normalize the empty path\n        if (!components.path) {\n            components.path = \"/\";\n        }\n        //NOTE: We do not parse query strings for HTTP URIs\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n        //and not the HTTP spec.\n        return components;\n    }\n};\n\nvar handler$1 = {\n    scheme: \"https\",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n};\n\nfunction isSecure(wsComponents) {\n    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n//RFC 6455\nvar handler$2 = {\n    scheme: \"ws\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        var wsComponents = components;\n        //indicate if the secure flag is set\n        wsComponents.secure = isSecure(wsComponents);\n        //construct resouce name\n        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n        wsComponents.path = undefined;\n        wsComponents.query = undefined;\n        return wsComponents;\n    },\n    serialize: function serialize(wsComponents, options) {\n        //normalize the default port\n        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n            wsComponents.port = undefined;\n        }\n        //ensure scheme matches secure flag\n        if (typeof wsComponents.secure === 'boolean') {\n            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\n            wsComponents.secure = undefined;\n        }\n        //reconstruct path from resource name\n        if (wsComponents.resourceName) {\n            var _wsComponents$resourc = wsComponents.resourceName.split('?'),\n                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n                path = _wsComponents$resourc2[0],\n                query = _wsComponents$resourc2[1];\n\n            wsComponents.path = path && path !== '/' ? path : undefined;\n            wsComponents.query = query;\n            wsComponents.resourceName = undefined;\n        }\n        //forbid fragment component\n        wsComponents.fragment = undefined;\n        return wsComponents;\n    }\n};\n\nvar handler$3 = {\n    scheme: \"wss\",\n    domainHost: handler$2.domainHost,\n    parse: handler$2.parse,\n    serialize: handler$2.serialize\n};\n\nvar O = {};\nvar isIRI = true;\n//RFC 3986\nvar UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nvar HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\nvar PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nvar ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nvar QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nvar VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nvar SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nvar UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nvar PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nvar NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nvar NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nvar NOT_HFVALUE = NOT_HFNAME;\nfunction decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n}\nvar handler$4 = {\n    scheme: \"mailto\",\n    parse: function parse$$1(components, options) {\n        var mailtoComponents = components;\n        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n        mailtoComponents.path = undefined;\n        if (mailtoComponents.query) {\n            var unknownHeaders = false;\n            var headers = {};\n            var hfields = mailtoComponents.query.split(\"&\");\n            for (var x = 0, xl = hfields.length; x < xl; ++x) {\n                var hfield = hfields[x].split(\"=\");\n                switch (hfield[0]) {\n                    case \"to\":\n                        var toAddrs = hfield[1].split(\",\");\n                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                            to.push(toAddrs[_x]);\n                        }\n                        break;\n                    case \"subject\":\n                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                        break;\n                    case \"body\":\n                        mailtoComponents.body = unescapeComponent(hfield[1], options);\n                        break;\n                    default:\n                        unknownHeaders = true;\n                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                        break;\n                }\n            }\n            if (unknownHeaders) mailtoComponents.headers = headers;\n        }\n        mailtoComponents.query = undefined;\n        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n            var addr = to[_x2].split(\"@\");\n            addr[0] = unescapeComponent(addr[0]);\n            if (!options.unicodeSupport) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                } catch (e) {\n                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            } else {\n                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n            }\n            to[_x2] = addr.join(\"@\");\n        }\n        return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n        var components = mailtoComponents;\n        var to = toArray(mailtoComponents.to);\n        if (to) {\n            for (var x = 0, xl = to.length; x < xl; ++x) {\n                var toAddr = String(to[x]);\n                var atIdx = toAddr.lastIndexOf(\"@\");\n                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                var domain = toAddr.slice(atIdx + 1);\n                //convert IDN via punycode\n                try {\n                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                } catch (e) {\n                    components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n                to[x] = localPart + \"@\" + domain;\n            }\n            components.path = to.join(\",\");\n        }\n        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n        if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n        if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n        var fields = [];\n        for (var name in headers) {\n            if (headers[name] !== O[name]) {\n                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n            }\n        }\n        if (fields.length) {\n            components.query = fields.join(\"&\");\n        }\n        return components;\n    }\n};\n\nvar URN_PARSE = /^([^\\:]+)\\:(.*)/;\n//RFC 2141\nvar handler$5 = {\n    scheme: \"urn\",\n    parse: function parse$$1(components, options) {\n        var matches = components.path && components.path.match(URN_PARSE);\n        var urnComponents = components;\n        if (matches) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = matches[1].toLowerCase();\n            var nss = matches[2];\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            urnComponents.nid = nid;\n            urnComponents.nss = nss;\n            urnComponents.path = undefined;\n            if (schemeHandler) {\n                urnComponents = schemeHandler.parse(urnComponents, options);\n            }\n        } else {\n            urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n        }\n        return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = urnComponents.nid;\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        if (schemeHandler) {\n            urnComponents = schemeHandler.serialize(urnComponents, options);\n        }\n        var uriComponents = urnComponents;\n        var nss = urnComponents.nss;\n        uriComponents.path = (nid || options.nid) + \":\" + nss;\n        return uriComponents;\n    }\n};\n\nvar UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n//RFC 4122\nvar handler$6 = {\n    scheme: \"urn:uuid\",\n    parse: function parse(urnComponents, options) {\n        var uuidComponents = urnComponents;\n        uuidComponents.uuid = uuidComponents.nss;\n        uuidComponents.nss = undefined;\n        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n            uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n        }\n        return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n        var urnComponents = uuidComponents;\n        //normalize UUID\n        urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n        return urnComponents;\n    }\n};\n\nSCHEMES[handler.scheme] = handler;\nSCHEMES[handler$1.scheme] = handler$1;\nSCHEMES[handler$2.scheme] = handler$2;\nSCHEMES[handler$3.scheme] = handler$3;\nSCHEMES[handler$4.scheme] = handler$4;\nSCHEMES[handler$5.scheme] = handler$5;\nSCHEMES[handler$6.scheme] = handler$6;\n\nexports.SCHEMES = SCHEMES;\nexports.pctEncChar = pctEncChar;\nexports.pctDecChars = pctDecChars;\nexports.parse = parse;\nexports.removeDotSegments = removeDotSegments;\nexports.serialize = serialize;\nexports.resolveComponents = resolveComponents;\nexports.resolve = resolve;\nexports.normalize = normalize;\nexports.equal = equal;\nexports.escapeComponent = escapeComponent;\nexports.unescapeComponent = unescapeComponent;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}