{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.strategy = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst api_1 = require(\"./api\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar strategy;\n(function (strategy) {\n  /**\n   * Creates a JobStrategy that serializes every call. This strategy can be mixed between jobs.\n   */\n  function serialize() {\n    let latest = (0, rxjs_1.of)();\n    return (handler, options) => {\n      const newHandler = (argument, context) => {\n        const previous = latest;\n        latest = (0, rxjs_1.concat)(previous.pipe((0, operators_1.ignoreElements)()), new rxjs_1.Observable(o => handler(argument, context).subscribe(o))).pipe((0, operators_1.shareReplay)(0));\n        return latest;\n      };\n      return Object.assign(newHandler, {\n        jobDescription: Object.assign({}, handler.jobDescription, options)\n      });\n    };\n  }\n  strategy.serialize = serialize;\n  /**\n   * Creates a JobStrategy that will always reuse a running job, and restart it if the job ended.\n   * @param replayMessages Replay ALL messages if a job is reused, otherwise just hook up where it\n   * is.\n   */\n  function reuse(replayMessages = false) {\n    let inboundBus = new rxjs_1.Subject();\n    let run = null;\n    let state = null;\n    return (handler, options) => {\n      const newHandler = (argument, context) => {\n        // Forward inputs.\n        const subscription = context.inboundBus.subscribe(inboundBus);\n        if (run) {\n          return (0, rxjs_1.concat)(\n          // Update state.\n          (0, rxjs_1.of)(state), run).pipe((0, operators_1.finalize)(() => subscription.unsubscribe()));\n        }\n        run = handler(argument, {\n          ...context,\n          inboundBus: inboundBus.asObservable()\n        }).pipe((0, operators_1.tap)(message => {\n          if (message.kind == api_1.JobOutboundMessageKind.Start || message.kind == api_1.JobOutboundMessageKind.OnReady || message.kind == api_1.JobOutboundMessageKind.End) {\n            state = message;\n          }\n        }, undefined, () => {\n          subscription.unsubscribe();\n          inboundBus = new rxjs_1.Subject();\n          run = null;\n        }), replayMessages ? (0, operators_1.shareReplay)() : (0, operators_1.share)());\n        return run;\n      };\n      return Object.assign(newHandler, handler, options || {});\n    };\n  }\n  strategy.reuse = reuse;\n  /**\n   * Creates a JobStrategy that will reuse a running job if the argument matches.\n   * @param replayMessages Replay ALL messages if a job is reused, otherwise just hook up where it\n   * is.\n   */\n  function memoize(replayMessages = false) {\n    const runs = new Map();\n    return (handler, options) => {\n      const newHandler = (argument, context) => {\n        const argumentJson = JSON.stringify((0, core_1.isJsonObject)(argument) ? Object.keys(argument).sort().reduce((result, key) => {\n          result[key] = argument[key];\n          return result;\n        }, {}) : argument);\n        const maybeJob = runs.get(argumentJson);\n        if (maybeJob) {\n          return maybeJob;\n        }\n        const run = handler(argument, context).pipe(replayMessages ? (0, operators_1.shareReplay)() : (0, operators_1.share)());\n        runs.set(argumentJson, run);\n        return run;\n      };\n      return Object.assign(newHandler, handler, options || {});\n    };\n  }\n  strategy.memoize = memoize;\n})(strategy = exports.strategy || (exports.strategy = {}));","map":{"version":3,"names":["Object","defineProperty","exports","value","strategy","core_1","require","rxjs_1","operators_1","api_1","serialize","latest","of","handler","options","newHandler","argument","context","previous","concat","pipe","ignoreElements","Observable","o","subscribe","shareReplay","assign","jobDescription","reuse","replayMessages","inboundBus","Subject","run","state","subscription","finalize","unsubscribe","asObservable","tap","message","kind","JobOutboundMessageKind","Start","OnReady","End","undefined","share","memoize","runs","Map","argumentJson","JSON","stringify","isJsonObject","keys","sort","reduce","result","key","maybeJob","get","set"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/node_modules/@angular-devkit/architect/src/jobs/strategy.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.strategy = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst api_1 = require(\"./api\");\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar strategy;\n(function (strategy) {\n    /**\n     * Creates a JobStrategy that serializes every call. This strategy can be mixed between jobs.\n     */\n    function serialize() {\n        let latest = (0, rxjs_1.of)();\n        return (handler, options) => {\n            const newHandler = (argument, context) => {\n                const previous = latest;\n                latest = (0, rxjs_1.concat)(previous.pipe((0, operators_1.ignoreElements)()), new rxjs_1.Observable((o) => handler(argument, context).subscribe(o))).pipe((0, operators_1.shareReplay)(0));\n                return latest;\n            };\n            return Object.assign(newHandler, {\n                jobDescription: Object.assign({}, handler.jobDescription, options),\n            });\n        };\n    }\n    strategy.serialize = serialize;\n    /**\n     * Creates a JobStrategy that will always reuse a running job, and restart it if the job ended.\n     * @param replayMessages Replay ALL messages if a job is reused, otherwise just hook up where it\n     * is.\n     */\n    function reuse(replayMessages = false) {\n        let inboundBus = new rxjs_1.Subject();\n        let run = null;\n        let state = null;\n        return (handler, options) => {\n            const newHandler = (argument, context) => {\n                // Forward inputs.\n                const subscription = context.inboundBus.subscribe(inboundBus);\n                if (run) {\n                    return (0, rxjs_1.concat)(\n                    // Update state.\n                    (0, rxjs_1.of)(state), run).pipe((0, operators_1.finalize)(() => subscription.unsubscribe()));\n                }\n                run = handler(argument, { ...context, inboundBus: inboundBus.asObservable() }).pipe((0, operators_1.tap)((message) => {\n                    if (message.kind == api_1.JobOutboundMessageKind.Start ||\n                        message.kind == api_1.JobOutboundMessageKind.OnReady ||\n                        message.kind == api_1.JobOutboundMessageKind.End) {\n                        state = message;\n                    }\n                }, undefined, () => {\n                    subscription.unsubscribe();\n                    inboundBus = new rxjs_1.Subject();\n                    run = null;\n                }), replayMessages ? (0, operators_1.shareReplay)() : (0, operators_1.share)());\n                return run;\n            };\n            return Object.assign(newHandler, handler, options || {});\n        };\n    }\n    strategy.reuse = reuse;\n    /**\n     * Creates a JobStrategy that will reuse a running job if the argument matches.\n     * @param replayMessages Replay ALL messages if a job is reused, otherwise just hook up where it\n     * is.\n     */\n    function memoize(replayMessages = false) {\n        const runs = new Map();\n        return (handler, options) => {\n            const newHandler = (argument, context) => {\n                const argumentJson = JSON.stringify((0, core_1.isJsonObject)(argument)\n                    ? Object.keys(argument)\n                        .sort()\n                        .reduce((result, key) => {\n                        result[key] = argument[key];\n                        return result;\n                    }, {})\n                    : argument);\n                const maybeJob = runs.get(argumentJson);\n                if (maybeJob) {\n                    return maybeJob;\n                }\n                const run = handler(argument, context).pipe(replayMessages ? (0, operators_1.shareReplay)() : (0, operators_1.share)());\n                runs.set(argumentJson, run);\n                return run;\n            };\n            return Object.assign(newHandler, handler, options || {});\n        };\n    }\n    strategy.memoize = memoize;\n})(strategy = exports.strategy || (exports.strategy = {}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}