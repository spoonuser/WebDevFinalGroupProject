{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n  message: ({\n    params: {\n      min,\n      max\n    }\n  }) => max === undefined ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({\n    params: {\n      min,\n      max\n    }\n  }) => max === undefined ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`\n};\nconst def = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      it\n    } = cxt;\n    let min;\n    let max;\n    const {\n      minContains,\n      maxContains\n    } = parentSchema;\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains;\n      max = maxContains;\n    } else {\n      min = 1;\n    }\n    const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n    cxt.setParams({\n      min,\n      max\n    });\n    if (max === undefined && min === 0) {\n      (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n      return;\n    }\n    if (max !== undefined && min > max) {\n      (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n      cxt.fail();\n      return;\n    }\n    if ((0, util_1.alwaysValidSchema)(it, schema)) {\n      let cond = (0, codegen_1._)`${len} >= ${min}`;\n      if (max !== undefined) cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;\n      cxt.pass(cond);\n      return;\n    }\n    it.items = true;\n    const valid = gen.name(\"valid\");\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()));\n    } else if (min === 0) {\n      gen.let(valid, true);\n      if (max !== undefined) gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);\n    } else {\n      gen.let(valid, false);\n      validateItemsWithCount();\n    }\n    cxt.result(valid, () => cxt.reset());\n    function validateItemsWithCount() {\n      const schValid = gen.name(\"_valid\");\n      const count = gen.let(\"count\", 0);\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n    }\n    function validateItems(_valid, block) {\n      gen.forRange(\"i\", 0, len, i => {\n        cxt.subschema({\n          keyword: \"contains\",\n          dataProp: i,\n          dataPropType: util_1.Type.Num,\n          compositeRule: true\n        }, _valid);\n        block();\n      });\n    }\n    function checkLimits(count) {\n      gen.code((0, codegen_1._)`${count}++`);\n      if (max === undefined) {\n        gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());\n      } else {\n        gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());\n        if (min === 1) gen.assign(valid, true);else gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));\n      }\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["Object","defineProperty","exports","value","codegen_1","require","util_1","error","message","params","min","max","undefined","str","_","def","keyword","type","schemaType","before","trackErrors","code","cxt","gen","schema","parentSchema","data","it","minContains","maxContains","opts","next","len","const","setParams","checkStrictMode","fail","alwaysValidSchema","cond","pass","items","valid","name","validateItems","if","break","let","validateItemsWithCount","result","reset","schValid","count","checkLimits","_valid","block","forRange","i","subschema","dataProp","dataPropType","Type","Num","compositeRule","assign","default"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/ajv/dist/vocabularies/applicator/contains.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { min, max } }) => max === undefined\n        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`\n        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,\n};\nconst def = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        }\n        else {\n            min = 1;\n        }\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === undefined && min === 0) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            let cond = (0, codegen_1._) `${len} >= ${min}`;\n            if (max !== undefined)\n                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === undefined && min === 1) {\n            validateItems(valid, () => gen.if(valid, () => gen.break()));\n        }\n        else if (min === 0) {\n            gen.let(valid, true);\n            if (max !== undefined)\n                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);\n        }\n        else {\n            gen.let(valid, false);\n            validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n            const schValid = gen.name(\"_valid\");\n            const count = gen.let(\"count\", 0);\n            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n            gen.forRange(\"i\", 0, len, (i) => {\n                cxt.subschema({\n                    keyword: \"contains\",\n                    dataProp: i,\n                    dataPropType: util_1.Type.Num,\n                    compositeRule: true,\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code((0, codegen_1._) `${count}++`);\n            if (max === undefined) {\n                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());\n            }\n            else {\n                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());\n                if (min === 1)\n                    gen.assign(valid, true);\n                else\n                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));\n            }\n        }\n    },\n};\nexports.default = def;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}