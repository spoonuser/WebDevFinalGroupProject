{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scheduleByTarget = exports.scheduleByName = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst api_1 = require(\"./api\");\nconst jobs_1 = require(\"./jobs\");\nconst progressSchema = require('./progress-schema.json');\nlet _uniqueId = 0;\nfunction scheduleByName(_x, _x2, _x3) {\n  return _scheduleByName.apply(this, arguments);\n}\nfunction _scheduleByName() {\n  _scheduleByName = _asyncToGenerator(function* (name, buildOptions, options) {\n    const childLoggerName = options.target ? `{${(0, api_1.targetStringFromTarget)(options.target)}}` : name;\n    const logger = options.logger.createChild(childLoggerName);\n    const job = options.scheduler.schedule(name, {});\n    let stateSubscription;\n    const workspaceRoot = yield options.workspaceRoot;\n    const currentDirectory = yield options.currentDirectory;\n    const description = yield job.description.toPromise();\n    const info = description.info;\n    const id = ++_uniqueId;\n    const message = {\n      id,\n      currentDirectory,\n      workspaceRoot,\n      info: info,\n      options: buildOptions,\n      ...(options.target ? {\n        target: options.target\n      } : {})\n    };\n    // Wait for the job to be ready.\n    if (job.state !== jobs_1.JobState.Started) {\n      stateSubscription = job.outboundBus.subscribe(event => {\n        if (event.kind === jobs_1.JobOutboundMessageKind.Start) {\n          job.input.next(message);\n        }\n      }, () => {});\n    } else {\n      job.input.next(message);\n    }\n    const logChannelSub = job.getChannel('log').subscribe(entry => {\n      logger.next(entry);\n    }, () => {});\n    const s = job.outboundBus.subscribe({\n      error() {},\n      complete() {\n        s.unsubscribe();\n        logChannelSub.unsubscribe();\n        if (stateSubscription) {\n          stateSubscription.unsubscribe();\n        }\n      }\n    });\n    const output = job.output.pipe((0, operators_1.map)(output => ({\n      ...output,\n      ...(options.target ? {\n        target: options.target\n      } : 0),\n      info\n    })), (0, operators_1.shareReplay)());\n    // Start the builder.\n    output.pipe((0, operators_1.first)()).subscribe({\n      error() {}\n    });\n    return {\n      id,\n      info,\n      // This is a getter so that it always returns the next output, and not the same one.\n      get result() {\n        return output.pipe((0, operators_1.first)()).toPromise();\n      },\n      output,\n      progress: job.getChannel('progress', progressSchema).pipe((0, operators_1.shareReplay)(1)),\n      stop() {\n        job.stop();\n        return job.outboundBus.pipe((0, operators_1.ignoreElements)(), (0, operators_1.catchError)(() => rxjs_1.EMPTY)).toPromise();\n      }\n    };\n  });\n  return _scheduleByName.apply(this, arguments);\n}\nexports.scheduleByName = scheduleByName;\nfunction scheduleByTarget(_x4, _x5, _x6) {\n  return _scheduleByTarget.apply(this, arguments);\n}\nfunction _scheduleByTarget() {\n  _scheduleByTarget = _asyncToGenerator(function* (target, overrides, options) {\n    return scheduleByName(`{${(0, api_1.targetStringFromTarget)(target)}}`, overrides, {\n      ...options,\n      target,\n      logger: options.logger\n    });\n  });\n  return _scheduleByTarget.apply(this, arguments);\n}\nexports.scheduleByTarget = scheduleByTarget;","map":{"version":3,"names":["Object","defineProperty","exports","value","scheduleByTarget","scheduleByName","rxjs_1","require","operators_1","api_1","jobs_1","progressSchema","_uniqueId","name","buildOptions","options","childLoggerName","target","targetStringFromTarget","logger","createChild","job","scheduler","schedule","stateSubscription","workspaceRoot","currentDirectory","description","toPromise","info","id","message","state","JobState","Started","outboundBus","subscribe","event","kind","JobOutboundMessageKind","Start","input","next","logChannelSub","getChannel","entry","s","error","complete","unsubscribe","output","pipe","map","shareReplay","first","result","progress","stop","ignoreElements","catchError","EMPTY","overrides"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/node_modules/@angular-devkit/architect/src/schedule-by-name.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scheduleByTarget = exports.scheduleByName = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst api_1 = require(\"./api\");\nconst jobs_1 = require(\"./jobs\");\nconst progressSchema = require('./progress-schema.json');\nlet _uniqueId = 0;\nasync function scheduleByName(name, buildOptions, options) {\n    const childLoggerName = options.target ? `{${(0, api_1.targetStringFromTarget)(options.target)}}` : name;\n    const logger = options.logger.createChild(childLoggerName);\n    const job = options.scheduler.schedule(name, {});\n    let stateSubscription;\n    const workspaceRoot = await options.workspaceRoot;\n    const currentDirectory = await options.currentDirectory;\n    const description = await job.description.toPromise();\n    const info = description.info;\n    const id = ++_uniqueId;\n    const message = {\n        id,\n        currentDirectory,\n        workspaceRoot,\n        info: info,\n        options: buildOptions,\n        ...(options.target ? { target: options.target } : {}),\n    };\n    // Wait for the job to be ready.\n    if (job.state !== jobs_1.JobState.Started) {\n        stateSubscription = job.outboundBus.subscribe((event) => {\n            if (event.kind === jobs_1.JobOutboundMessageKind.Start) {\n                job.input.next(message);\n            }\n        }, () => { });\n    }\n    else {\n        job.input.next(message);\n    }\n    const logChannelSub = job.getChannel('log').subscribe((entry) => {\n        logger.next(entry);\n    }, () => { });\n    const s = job.outboundBus.subscribe({\n        error() { },\n        complete() {\n            s.unsubscribe();\n            logChannelSub.unsubscribe();\n            if (stateSubscription) {\n                stateSubscription.unsubscribe();\n            }\n        },\n    });\n    const output = job.output.pipe((0, operators_1.map)((output) => ({\n        ...output,\n        ...(options.target ? { target: options.target } : 0),\n        info,\n    })), (0, operators_1.shareReplay)());\n    // Start the builder.\n    output.pipe((0, operators_1.first)()).subscribe({\n        error() { },\n    });\n    return {\n        id,\n        info,\n        // This is a getter so that it always returns the next output, and not the same one.\n        get result() {\n            return output.pipe((0, operators_1.first)()).toPromise();\n        },\n        output,\n        progress: job\n            .getChannel('progress', progressSchema)\n            .pipe((0, operators_1.shareReplay)(1)),\n        stop() {\n            job.stop();\n            return job.outboundBus\n                .pipe((0, operators_1.ignoreElements)(), (0, operators_1.catchError)(() => rxjs_1.EMPTY))\n                .toPromise();\n        },\n    };\n}\nexports.scheduleByName = scheduleByName;\nasync function scheduleByTarget(target, overrides, options) {\n    return scheduleByName(`{${(0, api_1.targetStringFromTarget)(target)}}`, overrides, {\n        ...options,\n        target,\n        logger: options.logger,\n    });\n}\nexports.scheduleByTarget = scheduleByTarget;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}