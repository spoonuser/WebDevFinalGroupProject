{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndentLogger = void 0;\nconst operators_1 = require(\"rxjs/operators\");\nconst logger_1 = require(\"./logger\");\n/**\n * Keep an map of indentation => array of indentations based on the level.\n * This is to optimize calculating the prefix based on the indentation itself. Since most logs\n * come from similar levels, and with similar indentation strings, this will be shared by all\n * loggers. Also, string concatenation is expensive so performing concats for every log entries\n * is expensive; this alleviates it.\n */\nconst indentationMap = {};\nclass IndentLogger extends logger_1.Logger {\n  constructor(name, parent = null, indentation = '  ') {\n    super(name, parent);\n    indentationMap[indentation] = indentationMap[indentation] || [''];\n    const indentMap = indentationMap[indentation];\n    this._observable = this._observable.pipe((0, operators_1.map)(entry => {\n      const l = entry.path.filter(x => !!x).length;\n      if (l >= indentMap.length) {\n        let current = indentMap[indentMap.length - 1];\n        while (l >= indentMap.length) {\n          current += indentation;\n          indentMap.push(current);\n        }\n      }\n      entry.message = indentMap[l] + entry.message.split(/\\n/).join('\\n' + indentMap[l]);\n      return entry;\n    }));\n  }\n}\nexports.IndentLogger = IndentLogger;","map":{"version":3,"names":["Object","defineProperty","exports","value","IndentLogger","operators_1","require","logger_1","indentationMap","Logger","constructor","name","parent","indentation","indentMap","_observable","pipe","map","entry","l","path","filter","x","length","current","push","message","split","join"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/node_modules/@angular-devkit/core/src/logger/indent.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IndentLogger = void 0;\nconst operators_1 = require(\"rxjs/operators\");\nconst logger_1 = require(\"./logger\");\n/**\n * Keep an map of indentation => array of indentations based on the level.\n * This is to optimize calculating the prefix based on the indentation itself. Since most logs\n * come from similar levels, and with similar indentation strings, this will be shared by all\n * loggers. Also, string concatenation is expensive so performing concats for every log entries\n * is expensive; this alleviates it.\n */\nconst indentationMap = {};\nclass IndentLogger extends logger_1.Logger {\n    constructor(name, parent = null, indentation = '  ') {\n        super(name, parent);\n        indentationMap[indentation] = indentationMap[indentation] || [''];\n        const indentMap = indentationMap[indentation];\n        this._observable = this._observable.pipe((0, operators_1.map)((entry) => {\n            const l = entry.path.filter((x) => !!x).length;\n            if (l >= indentMap.length) {\n                let current = indentMap[indentMap.length - 1];\n                while (l >= indentMap.length) {\n                    current += indentation;\n                    indentMap.push(current);\n                }\n            }\n            entry.message = indentMap[l] + entry.message.split(/\\n/).join('\\n' + indentMap[l]);\n            return entry;\n        }));\n    }\n}\nexports.IndentLogger = IndentLogger;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,YAAY,GAAG,KAAK,CAAC;AAC7B,MAAMC,WAAW,GAAGC,OAAO,CAAC,gBAAgB,CAAC;AAC7C,MAAMC,QAAQ,GAAGD,OAAO,CAAC,UAAU,CAAC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,cAAc,GAAG,CAAC,CAAC;AACzB,MAAMJ,YAAY,SAASG,QAAQ,CAACE,MAAM,CAAC;EACvCC,WAAW,CAACC,IAAI,EAAEC,MAAM,GAAG,IAAI,EAAEC,WAAW,GAAG,IAAI,EAAE;IACjD,KAAK,CAACF,IAAI,EAAEC,MAAM,CAAC;IACnBJ,cAAc,CAACK,WAAW,CAAC,GAAGL,cAAc,CAACK,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC;IACjE,MAAMC,SAAS,GAAGN,cAAc,CAACK,WAAW,CAAC;IAC7C,IAAI,CAACE,WAAW,GAAG,IAAI,CAACA,WAAW,CAACC,IAAI,CAAC,CAAC,CAAC,EAAEX,WAAW,CAACY,GAAG,EAAGC,KAAK,IAAK;MACrE,MAAMC,CAAC,GAAGD,KAAK,CAACE,IAAI,CAACC,MAAM,CAAEC,CAAC,IAAK,CAAC,CAACA,CAAC,CAAC,CAACC,MAAM;MAC9C,IAAIJ,CAAC,IAAIL,SAAS,CAACS,MAAM,EAAE;QACvB,IAAIC,OAAO,GAAGV,SAAS,CAACA,SAAS,CAACS,MAAM,GAAG,CAAC,CAAC;QAC7C,OAAOJ,CAAC,IAAIL,SAAS,CAACS,MAAM,EAAE;UAC1BC,OAAO,IAAIX,WAAW;UACtBC,SAAS,CAACW,IAAI,CAACD,OAAO,CAAC;QAC3B;MACJ;MACAN,KAAK,CAACQ,OAAO,GAAGZ,SAAS,CAACK,CAAC,CAAC,GAAGD,KAAK,CAACQ,OAAO,CAACC,KAAK,CAAC,IAAI,CAAC,CAACC,IAAI,CAAC,IAAI,GAAGd,SAAS,CAACK,CAAC,CAAC,CAAC;MAClF,OAAOD,KAAK;IAChB,CAAC,CAAC,CAAC;EACP;AACJ;AACAhB,OAAO,CAACE,YAAY,GAAGA,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}