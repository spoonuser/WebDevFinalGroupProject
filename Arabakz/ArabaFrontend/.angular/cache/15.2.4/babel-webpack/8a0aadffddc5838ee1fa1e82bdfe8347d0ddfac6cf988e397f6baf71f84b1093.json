{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visitJsonSchema = exports.visitJson = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst pointer_1 = require(\"./pointer\");\nfunction _getObjectSubSchema(schema, key) {\n  if (typeof schema !== 'object' || schema === null) {\n    return undefined;\n  }\n  // Is it an object schema?\n  if (typeof schema.properties == 'object' || schema.type == 'object') {\n    if (typeof schema.properties == 'object' && typeof schema.properties[key] == 'object') {\n      return schema.properties[key];\n    }\n    if (typeof schema.additionalProperties == 'object') {\n      return schema.additionalProperties;\n    }\n    return undefined;\n  }\n  // Is it an array schema?\n  if (typeof schema.items == 'object' || schema.type == 'array') {\n    return typeof schema.items == 'object' ? schema.items : undefined;\n  }\n  return undefined;\n}\nfunction _visitJsonRecursive(json, visitor, ptr, schema, refResolver, context, root) {\n  if (schema === true || schema === false) {\n    // There's no schema definition, so just visit the JSON recursively.\n    schema = undefined;\n  }\n  // eslint-disable-next-line no-prototype-builtins\n  if (schema && schema.hasOwnProperty('$ref') && typeof schema['$ref'] == 'string') {\n    if (refResolver) {\n      const resolved = refResolver(schema['$ref'], context);\n      schema = resolved.schema;\n      context = resolved.context;\n    }\n  }\n  const value = visitor(json, ptr, schema, root);\n  return ((0, rxjs_1.isObservable)(value) ? value : (0, rxjs_1.of)(value)).pipe((0, operators_1.concatMap)(value => {\n    if (Array.isArray(value)) {\n      return (0, rxjs_1.concat)((0, rxjs_1.from)(value).pipe((0, operators_1.mergeMap)((item, i) => {\n        return _visitJsonRecursive(item, visitor, (0, pointer_1.joinJsonPointer)(ptr, '' + i), _getObjectSubSchema(schema, '' + i), refResolver, context, root || value).pipe((0, operators_1.tap)(x => value[i] = x));\n      }), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(value));\n    } else if (typeof value == 'object' && value !== null) {\n      return (0, rxjs_1.concat)((0, rxjs_1.from)(Object.getOwnPropertyNames(value)).pipe((0, operators_1.mergeMap)(key => {\n        return _visitJsonRecursive(value[key], visitor, (0, pointer_1.joinJsonPointer)(ptr, key), _getObjectSubSchema(schema, key), refResolver, context, root || value).pipe((0, operators_1.tap)(x => {\n          const descriptor = Object.getOwnPropertyDescriptor(value, key);\n          if (descriptor && descriptor.writable && value[key] !== x) {\n            value[key] = x;\n          }\n        }));\n      }), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(value));\n    } else {\n      return (0, rxjs_1.of)(value);\n    }\n  }));\n}\n/**\n * Visit all the properties in a JSON object, allowing to transform them. It supports calling\n * properties synchronously or asynchronously (through Observables).\n * The original object can be mutated or replaced entirely. In case where it's replaced, the new\n * value is returned. When it's mutated though the original object will be changed.\n *\n * Please note it is possible to have an infinite loop here (which will result in a stack overflow)\n * if you return 2 objects that references each others (or the same object all the time).\n *\n * @param {JsonValue} json The Json value to visit.\n * @param {JsonVisitor} visitor A function that will be called on every items.\n * @param {JsonObject} schema A JSON schema to pass through to the visitor (where possible).\n * @param refResolver a function to resolve references in the schema.\n * @returns {Observable< | undefined>} The observable of the new root, if the root changed.\n */\nfunction visitJson(json, visitor, schema, refResolver, context) {\n  return _visitJsonRecursive(json, visitor, (0, pointer_1.buildJsonPointer)([]), schema, refResolver, context);\n}\nexports.visitJson = visitJson;\nfunction visitJsonSchema(schema, visitor) {\n  if (schema === false || schema === true) {\n    // Nothing to visit.\n    return;\n  }\n  const keywords = {\n    additionalItems: true,\n    items: true,\n    contains: true,\n    additionalProperties: true,\n    propertyNames: true,\n    not: true\n  };\n  const arrayKeywords = {\n    items: true,\n    allOf: true,\n    anyOf: true,\n    oneOf: true\n  };\n  const propsKeywords = {\n    definitions: true,\n    properties: true,\n    patternProperties: true,\n    additionalProperties: true,\n    dependencies: true,\n    items: true\n  };\n  function _traverse(schema, jsonPtr, rootSchema, parentSchema, keyIndex) {\n    if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n      visitor(schema, jsonPtr, parentSchema, keyIndex);\n      for (const key of Object.keys(schema)) {\n        const sch = schema[key];\n        if (key in propsKeywords) {\n          if (sch && typeof sch == 'object') {\n            for (const prop of Object.keys(sch)) {\n              _traverse(sch[prop], (0, pointer_1.joinJsonPointer)(jsonPtr, key, prop), rootSchema, schema, prop);\n            }\n          }\n        } else if (key in keywords) {\n          _traverse(sch, (0, pointer_1.joinJsonPointer)(jsonPtr, key), rootSchema, schema, key);\n        } else if (key in arrayKeywords) {\n          if (Array.isArray(sch)) {\n            for (let i = 0; i < sch.length; i++) {\n              _traverse(sch[i], (0, pointer_1.joinJsonPointer)(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n            }\n          }\n        } else if (Array.isArray(sch)) {\n          for (let i = 0; i < sch.length; i++) {\n            _traverse(sch[i], (0, pointer_1.joinJsonPointer)(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n          }\n        }\n      }\n    }\n  }\n  _traverse(schema, (0, pointer_1.buildJsonPointer)([]), schema);\n}\nexports.visitJsonSchema = visitJsonSchema;","map":{"version":3,"names":["Object","defineProperty","exports","value","visitJsonSchema","visitJson","rxjs_1","require","operators_1","pointer_1","_getObjectSubSchema","schema","key","undefined","properties","type","additionalProperties","items","_visitJsonRecursive","json","visitor","ptr","refResolver","context","root","hasOwnProperty","resolved","isObservable","of","pipe","concatMap","Array","isArray","concat","from","mergeMap","item","i","joinJsonPointer","tap","x","ignoreElements","getOwnPropertyNames","descriptor","getOwnPropertyDescriptor","writable","buildJsonPointer","keywords","additionalItems","contains","propertyNames","not","arrayKeywords","allOf","anyOf","oneOf","propsKeywords","definitions","patternProperties","dependencies","_traverse","jsonPtr","rootSchema","parentSchema","keyIndex","keys","sch","prop","length"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/node_modules/@angular-devkit/core/src/json/schema/visitor.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.visitJsonSchema = exports.visitJson = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst pointer_1 = require(\"./pointer\");\nfunction _getObjectSubSchema(schema, key) {\n    if (typeof schema !== 'object' || schema === null) {\n        return undefined;\n    }\n    // Is it an object schema?\n    if (typeof schema.properties == 'object' || schema.type == 'object') {\n        if (typeof schema.properties == 'object' &&\n            typeof schema.properties[key] == 'object') {\n            return schema.properties[key];\n        }\n        if (typeof schema.additionalProperties == 'object') {\n            return schema.additionalProperties;\n        }\n        return undefined;\n    }\n    // Is it an array schema?\n    if (typeof schema.items == 'object' || schema.type == 'array') {\n        return typeof schema.items == 'object' ? schema.items : undefined;\n    }\n    return undefined;\n}\nfunction _visitJsonRecursive(json, visitor, ptr, schema, refResolver, context, root) {\n    if (schema === true || schema === false) {\n        // There's no schema definition, so just visit the JSON recursively.\n        schema = undefined;\n    }\n    // eslint-disable-next-line no-prototype-builtins\n    if (schema && schema.hasOwnProperty('$ref') && typeof schema['$ref'] == 'string') {\n        if (refResolver) {\n            const resolved = refResolver(schema['$ref'], context);\n            schema = resolved.schema;\n            context = resolved.context;\n        }\n    }\n    const value = visitor(json, ptr, schema, root);\n    return ((0, rxjs_1.isObservable)(value) ? value : (0, rxjs_1.of)(value)).pipe((0, operators_1.concatMap)((value) => {\n        if (Array.isArray(value)) {\n            return (0, rxjs_1.concat)((0, rxjs_1.from)(value).pipe((0, operators_1.mergeMap)((item, i) => {\n                return _visitJsonRecursive(item, visitor, (0, pointer_1.joinJsonPointer)(ptr, '' + i), _getObjectSubSchema(schema, '' + i), refResolver, context, root || value).pipe((0, operators_1.tap)((x) => (value[i] = x)));\n            }), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(value));\n        }\n        else if (typeof value == 'object' && value !== null) {\n            return (0, rxjs_1.concat)((0, rxjs_1.from)(Object.getOwnPropertyNames(value)).pipe((0, operators_1.mergeMap)((key) => {\n                return _visitJsonRecursive(value[key], visitor, (0, pointer_1.joinJsonPointer)(ptr, key), _getObjectSubSchema(schema, key), refResolver, context, root || value).pipe((0, operators_1.tap)((x) => {\n                    const descriptor = Object.getOwnPropertyDescriptor(value, key);\n                    if (descriptor && descriptor.writable && value[key] !== x) {\n                        value[key] = x;\n                    }\n                }));\n            }), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(value));\n        }\n        else {\n            return (0, rxjs_1.of)(value);\n        }\n    }));\n}\n/**\n * Visit all the properties in a JSON object, allowing to transform them. It supports calling\n * properties synchronously or asynchronously (through Observables).\n * The original object can be mutated or replaced entirely. In case where it's replaced, the new\n * value is returned. When it's mutated though the original object will be changed.\n *\n * Please note it is possible to have an infinite loop here (which will result in a stack overflow)\n * if you return 2 objects that references each others (or the same object all the time).\n *\n * @param {JsonValue} json The Json value to visit.\n * @param {JsonVisitor} visitor A function that will be called on every items.\n * @param {JsonObject} schema A JSON schema to pass through to the visitor (where possible).\n * @param refResolver a function to resolve references in the schema.\n * @returns {Observable< | undefined>} The observable of the new root, if the root changed.\n */\nfunction visitJson(json, visitor, schema, refResolver, context) {\n    return _visitJsonRecursive(json, visitor, (0, pointer_1.buildJsonPointer)([]), schema, refResolver, context);\n}\nexports.visitJson = visitJson;\nfunction visitJsonSchema(schema, visitor) {\n    if (schema === false || schema === true) {\n        // Nothing to visit.\n        return;\n    }\n    const keywords = {\n        additionalItems: true,\n        items: true,\n        contains: true,\n        additionalProperties: true,\n        propertyNames: true,\n        not: true,\n    };\n    const arrayKeywords = {\n        items: true,\n        allOf: true,\n        anyOf: true,\n        oneOf: true,\n    };\n    const propsKeywords = {\n        definitions: true,\n        properties: true,\n        patternProperties: true,\n        additionalProperties: true,\n        dependencies: true,\n        items: true,\n    };\n    function _traverse(schema, jsonPtr, rootSchema, parentSchema, keyIndex) {\n        if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n            visitor(schema, jsonPtr, parentSchema, keyIndex);\n            for (const key of Object.keys(schema)) {\n                const sch = schema[key];\n                if (key in propsKeywords) {\n                    if (sch && typeof sch == 'object') {\n                        for (const prop of Object.keys(sch)) {\n                            _traverse(sch[prop], (0, pointer_1.joinJsonPointer)(jsonPtr, key, prop), rootSchema, schema, prop);\n                        }\n                    }\n                }\n                else if (key in keywords) {\n                    _traverse(sch, (0, pointer_1.joinJsonPointer)(jsonPtr, key), rootSchema, schema, key);\n                }\n                else if (key in arrayKeywords) {\n                    if (Array.isArray(sch)) {\n                        for (let i = 0; i < sch.length; i++) {\n                            _traverse(sch[i], (0, pointer_1.joinJsonPointer)(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n                        }\n                    }\n                }\n                else if (Array.isArray(sch)) {\n                    for (let i = 0; i < sch.length; i++) {\n                        _traverse(sch[i], (0, pointer_1.joinJsonPointer)(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n                    }\n                }\n            }\n        }\n    }\n    _traverse(schema, (0, pointer_1.buildJsonPointer)([]), schema);\n}\nexports.visitJsonSchema = visitJsonSchema;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}