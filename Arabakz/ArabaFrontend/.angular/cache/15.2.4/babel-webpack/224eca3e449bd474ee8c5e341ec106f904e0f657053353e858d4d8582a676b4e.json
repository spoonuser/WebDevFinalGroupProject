{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleMemoryHost = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst exception_1 = require(\"../../exception\");\nconst path_1 = require(\"../path\");\nclass SimpleMemoryHost {\n  _newDirStats() {\n    return {\n      inspect() {\n        return '<Directory>';\n      },\n      isFile() {\n        return false;\n      },\n      isDirectory() {\n        return true;\n      },\n      size: 0,\n      atime: new Date(),\n      ctime: new Date(),\n      mtime: new Date(),\n      birthtime: new Date(),\n      content: null\n    };\n  }\n  _newFileStats(content, oldStats) {\n    return {\n      inspect() {\n        return `<File size(${content.byteLength})>`;\n      },\n      isFile() {\n        return true;\n      },\n      isDirectory() {\n        return false;\n      },\n      size: content.byteLength,\n      atime: oldStats ? oldStats.atime : new Date(),\n      ctime: new Date(),\n      mtime: new Date(),\n      birthtime: oldStats ? oldStats.birthtime : new Date(),\n      content\n    };\n  }\n  constructor() {\n    this._cache = new Map();\n    this._watchers = new Map();\n    this._cache.set((0, path_1.normalize)('/'), this._newDirStats());\n  }\n  _toAbsolute(path) {\n    return (0, path_1.isAbsolute)(path) ? path : (0, path_1.normalize)('/' + path);\n  }\n  _updateWatchers(path, type) {\n    const time = new Date();\n    let currentPath = path;\n    let parent = null;\n    if (this._watchers.size == 0) {\n      // Nothing to do if there's no watchers.\n      return;\n    }\n    const maybeWatcher = this._watchers.get(currentPath);\n    if (maybeWatcher) {\n      maybeWatcher.forEach(watcher => {\n        const [options, subject] = watcher;\n        subject.next({\n          path,\n          time,\n          type\n        });\n        if (!options.persistent && type == 2 /* HostWatchEventType.Deleted */) {\n          subject.complete();\n          this._watchers.delete(currentPath);\n        }\n      });\n    }\n    do {\n      currentPath = parent !== null ? parent : currentPath;\n      parent = (0, path_1.dirname)(currentPath);\n      const maybeWatcher = this._watchers.get(currentPath);\n      if (maybeWatcher) {\n        maybeWatcher.forEach(watcher => {\n          const [options, subject] = watcher;\n          if (!options.recursive) {\n            return;\n          }\n          subject.next({\n            path,\n            time,\n            type\n          });\n          if (!options.persistent && type == 2 /* HostWatchEventType.Deleted */) {\n            subject.complete();\n            this._watchers.delete(currentPath);\n          }\n        });\n      }\n    } while (parent != currentPath);\n  }\n  get capabilities() {\n    return {\n      synchronous: true\n    };\n  }\n  /**\n   * List of protected methods that give direct access outside the observables to the cache\n   * and internal states.\n   */\n  _write(path, content) {\n    path = this._toAbsolute(path);\n    const old = this._cache.get(path);\n    if (old && old.isDirectory()) {\n      throw new exception_1.PathIsDirectoryException(path);\n    }\n    // Update all directories. If we find a file we know it's an invalid write.\n    const fragments = (0, path_1.split)(path);\n    let curr = (0, path_1.normalize)('/');\n    for (const fr of fragments) {\n      curr = (0, path_1.join)(curr, fr);\n      const maybeStats = this._cache.get(fr);\n      if (maybeStats) {\n        if (maybeStats.isFile()) {\n          throw new exception_1.PathIsFileException(curr);\n        }\n      } else {\n        this._cache.set(curr, this._newDirStats());\n      }\n    }\n    // Create the stats.\n    const stats = this._newFileStats(content, old);\n    this._cache.set(path, stats);\n    this._updateWatchers(path, old ? 0 /* HostWatchEventType.Changed */ : 1 /* HostWatchEventType.Created */);\n  }\n\n  _read(path) {\n    path = this._toAbsolute(path);\n    const maybeStats = this._cache.get(path);\n    if (!maybeStats) {\n      throw new exception_1.FileDoesNotExistException(path);\n    } else if (maybeStats.isDirectory()) {\n      throw new exception_1.PathIsDirectoryException(path);\n    } else if (!maybeStats.content) {\n      throw new exception_1.PathIsDirectoryException(path);\n    } else {\n      return maybeStats.content;\n    }\n  }\n  _delete(path) {\n    path = this._toAbsolute(path);\n    if (this._isDirectory(path)) {\n      for (const [cachePath] of this._cache.entries()) {\n        if (cachePath.startsWith(path + path_1.NormalizedSep) || cachePath === path) {\n          this._cache.delete(cachePath);\n        }\n      }\n    } else {\n      this._cache.delete(path);\n    }\n    this._updateWatchers(path, 2 /* HostWatchEventType.Deleted */);\n  }\n\n  _rename(from, to) {\n    from = this._toAbsolute(from);\n    to = this._toAbsolute(to);\n    if (!this._cache.has(from)) {\n      throw new exception_1.FileDoesNotExistException(from);\n    } else if (this._cache.has(to)) {\n      throw new exception_1.FileAlreadyExistException(to);\n    }\n    if (this._isDirectory(from)) {\n      for (const path of this._cache.keys()) {\n        if (path.startsWith(from + path_1.NormalizedSep)) {\n          const content = this._cache.get(path);\n          if (content) {\n            // We don't need to clone or extract the content, since we're moving files.\n            this._cache.set((0, path_1.join)(to, path_1.NormalizedSep, path.slice(from.length)), content);\n          }\n        }\n      }\n    } else {\n      const content = this._cache.get(from);\n      if (content) {\n        const fragments = (0, path_1.split)(to);\n        const newDirectories = [];\n        let curr = (0, path_1.normalize)('/');\n        for (const fr of fragments) {\n          curr = (0, path_1.join)(curr, fr);\n          const maybeStats = this._cache.get(fr);\n          if (maybeStats) {\n            if (maybeStats.isFile()) {\n              throw new exception_1.PathIsFileException(curr);\n            }\n          } else {\n            newDirectories.push(curr);\n          }\n        }\n        for (const newDirectory of newDirectories) {\n          this._cache.set(newDirectory, this._newDirStats());\n        }\n        this._cache.delete(from);\n        this._cache.set(to, content);\n      }\n    }\n    this._updateWatchers(from, 3 /* HostWatchEventType.Renamed */);\n  }\n\n  _list(path) {\n    path = this._toAbsolute(path);\n    if (this._isFile(path)) {\n      throw new exception_1.PathIsFileException(path);\n    }\n    const fragments = (0, path_1.split)(path);\n    const result = new Set();\n    if (path !== path_1.NormalizedRoot) {\n      for (const p of this._cache.keys()) {\n        if (p.startsWith(path + path_1.NormalizedSep)) {\n          result.add((0, path_1.split)(p)[fragments.length]);\n        }\n      }\n    } else {\n      for (const p of this._cache.keys()) {\n        if (p.startsWith(path_1.NormalizedSep) && p !== path_1.NormalizedRoot) {\n          result.add((0, path_1.split)(p)[1]);\n        }\n      }\n    }\n    return [...result];\n  }\n  _exists(path) {\n    return !!this._cache.get(this._toAbsolute(path));\n  }\n  _isDirectory(path) {\n    const maybeStats = this._cache.get(this._toAbsolute(path));\n    return maybeStats ? maybeStats.isDirectory() : false;\n  }\n  _isFile(path) {\n    const maybeStats = this._cache.get(this._toAbsolute(path));\n    return maybeStats ? maybeStats.isFile() : false;\n  }\n  _stat(path) {\n    const maybeStats = this._cache.get(this._toAbsolute(path));\n    if (!maybeStats) {\n      return null;\n    } else {\n      return maybeStats;\n    }\n  }\n  _watch(path, options) {\n    path = this._toAbsolute(path);\n    const subject = new rxjs_1.Subject();\n    let maybeWatcherArray = this._watchers.get(path);\n    if (!maybeWatcherArray) {\n      maybeWatcherArray = [];\n      this._watchers.set(path, maybeWatcherArray);\n    }\n    maybeWatcherArray.push([options || {}, subject]);\n    return subject.asObservable();\n  }\n  write(path, content) {\n    return new rxjs_1.Observable(obs => {\n      this._write(path, content);\n      obs.next();\n      obs.complete();\n    });\n  }\n  read(path) {\n    return new rxjs_1.Observable(obs => {\n      const content = this._read(path);\n      obs.next(content);\n      obs.complete();\n    });\n  }\n  delete(path) {\n    return new rxjs_1.Observable(obs => {\n      this._delete(path);\n      obs.next();\n      obs.complete();\n    });\n  }\n  rename(from, to) {\n    return new rxjs_1.Observable(obs => {\n      this._rename(from, to);\n      obs.next();\n      obs.complete();\n    });\n  }\n  list(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._list(path));\n      obs.complete();\n    });\n  }\n  exists(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._exists(path));\n      obs.complete();\n    });\n  }\n  isDirectory(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._isDirectory(path));\n      obs.complete();\n    });\n  }\n  isFile(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._isFile(path));\n      obs.complete();\n    });\n  }\n  // Some hosts may not support stat.\n  stat(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._stat(path));\n      obs.complete();\n    });\n  }\n  watch(path, options) {\n    return this._watch(path, options);\n  }\n  reset() {\n    this._cache.clear();\n    this._watchers.clear();\n  }\n}\nexports.SimpleMemoryHost = SimpleMemoryHost;","map":{"version":3,"names":["Object","defineProperty","exports","value","SimpleMemoryHost","rxjs_1","require","exception_1","path_1","_newDirStats","inspect","isFile","isDirectory","size","atime","Date","ctime","mtime","birthtime","content","_newFileStats","oldStats","byteLength","constructor","_cache","Map","_watchers","set","normalize","_toAbsolute","path","isAbsolute","_updateWatchers","type","time","currentPath","parent","maybeWatcher","get","forEach","watcher","options","subject","next","persistent","complete","delete","dirname","recursive","capabilities","synchronous","_write","old","PathIsDirectoryException","fragments","split","curr","fr","join","maybeStats","PathIsFileException","stats","_read","FileDoesNotExistException","_delete","_isDirectory","cachePath","entries","startsWith","NormalizedSep","_rename","from","to","has","FileAlreadyExistException","keys","slice","length","newDirectories","push","newDirectory","_list","_isFile","result","Set","NormalizedRoot","p","add","_exists","_stat","_watch","Subject","maybeWatcherArray","asObservable","write","Observable","obs","read","rename","list","exists","stat","watch","reset","clear"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/@angular/cli/node_modules/@angular-devkit/core/src/virtual-fs/host/memory.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleMemoryHost = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst exception_1 = require(\"../../exception\");\nconst path_1 = require(\"../path\");\nclass SimpleMemoryHost {\n    _newDirStats() {\n        return {\n            inspect() {\n                return '<Directory>';\n            },\n            isFile() {\n                return false;\n            },\n            isDirectory() {\n                return true;\n            },\n            size: 0,\n            atime: new Date(),\n            ctime: new Date(),\n            mtime: new Date(),\n            birthtime: new Date(),\n            content: null,\n        };\n    }\n    _newFileStats(content, oldStats) {\n        return {\n            inspect() {\n                return `<File size(${content.byteLength})>`;\n            },\n            isFile() {\n                return true;\n            },\n            isDirectory() {\n                return false;\n            },\n            size: content.byteLength,\n            atime: oldStats ? oldStats.atime : new Date(),\n            ctime: new Date(),\n            mtime: new Date(),\n            birthtime: oldStats ? oldStats.birthtime : new Date(),\n            content,\n        };\n    }\n    constructor() {\n        this._cache = new Map();\n        this._watchers = new Map();\n        this._cache.set((0, path_1.normalize)('/'), this._newDirStats());\n    }\n    _toAbsolute(path) {\n        return (0, path_1.isAbsolute)(path) ? path : (0, path_1.normalize)('/' + path);\n    }\n    _updateWatchers(path, type) {\n        const time = new Date();\n        let currentPath = path;\n        let parent = null;\n        if (this._watchers.size == 0) {\n            // Nothing to do if there's no watchers.\n            return;\n        }\n        const maybeWatcher = this._watchers.get(currentPath);\n        if (maybeWatcher) {\n            maybeWatcher.forEach((watcher) => {\n                const [options, subject] = watcher;\n                subject.next({ path, time, type });\n                if (!options.persistent && type == 2 /* HostWatchEventType.Deleted */) {\n                    subject.complete();\n                    this._watchers.delete(currentPath);\n                }\n            });\n        }\n        do {\n            currentPath = parent !== null ? parent : currentPath;\n            parent = (0, path_1.dirname)(currentPath);\n            const maybeWatcher = this._watchers.get(currentPath);\n            if (maybeWatcher) {\n                maybeWatcher.forEach((watcher) => {\n                    const [options, subject] = watcher;\n                    if (!options.recursive) {\n                        return;\n                    }\n                    subject.next({ path, time, type });\n                    if (!options.persistent && type == 2 /* HostWatchEventType.Deleted */) {\n                        subject.complete();\n                        this._watchers.delete(currentPath);\n                    }\n                });\n            }\n        } while (parent != currentPath);\n    }\n    get capabilities() {\n        return { synchronous: true };\n    }\n    /**\n     * List of protected methods that give direct access outside the observables to the cache\n     * and internal states.\n     */\n    _write(path, content) {\n        path = this._toAbsolute(path);\n        const old = this._cache.get(path);\n        if (old && old.isDirectory()) {\n            throw new exception_1.PathIsDirectoryException(path);\n        }\n        // Update all directories. If we find a file we know it's an invalid write.\n        const fragments = (0, path_1.split)(path);\n        let curr = (0, path_1.normalize)('/');\n        for (const fr of fragments) {\n            curr = (0, path_1.join)(curr, fr);\n            const maybeStats = this._cache.get(fr);\n            if (maybeStats) {\n                if (maybeStats.isFile()) {\n                    throw new exception_1.PathIsFileException(curr);\n                }\n            }\n            else {\n                this._cache.set(curr, this._newDirStats());\n            }\n        }\n        // Create the stats.\n        const stats = this._newFileStats(content, old);\n        this._cache.set(path, stats);\n        this._updateWatchers(path, old ? 0 /* HostWatchEventType.Changed */ : 1 /* HostWatchEventType.Created */);\n    }\n    _read(path) {\n        path = this._toAbsolute(path);\n        const maybeStats = this._cache.get(path);\n        if (!maybeStats) {\n            throw new exception_1.FileDoesNotExistException(path);\n        }\n        else if (maybeStats.isDirectory()) {\n            throw new exception_1.PathIsDirectoryException(path);\n        }\n        else if (!maybeStats.content) {\n            throw new exception_1.PathIsDirectoryException(path);\n        }\n        else {\n            return maybeStats.content;\n        }\n    }\n    _delete(path) {\n        path = this._toAbsolute(path);\n        if (this._isDirectory(path)) {\n            for (const [cachePath] of this._cache.entries()) {\n                if (cachePath.startsWith(path + path_1.NormalizedSep) || cachePath === path) {\n                    this._cache.delete(cachePath);\n                }\n            }\n        }\n        else {\n            this._cache.delete(path);\n        }\n        this._updateWatchers(path, 2 /* HostWatchEventType.Deleted */);\n    }\n    _rename(from, to) {\n        from = this._toAbsolute(from);\n        to = this._toAbsolute(to);\n        if (!this._cache.has(from)) {\n            throw new exception_1.FileDoesNotExistException(from);\n        }\n        else if (this._cache.has(to)) {\n            throw new exception_1.FileAlreadyExistException(to);\n        }\n        if (this._isDirectory(from)) {\n            for (const path of this._cache.keys()) {\n                if (path.startsWith(from + path_1.NormalizedSep)) {\n                    const content = this._cache.get(path);\n                    if (content) {\n                        // We don't need to clone or extract the content, since we're moving files.\n                        this._cache.set((0, path_1.join)(to, path_1.NormalizedSep, path.slice(from.length)), content);\n                    }\n                }\n            }\n        }\n        else {\n            const content = this._cache.get(from);\n            if (content) {\n                const fragments = (0, path_1.split)(to);\n                const newDirectories = [];\n                let curr = (0, path_1.normalize)('/');\n                for (const fr of fragments) {\n                    curr = (0, path_1.join)(curr, fr);\n                    const maybeStats = this._cache.get(fr);\n                    if (maybeStats) {\n                        if (maybeStats.isFile()) {\n                            throw new exception_1.PathIsFileException(curr);\n                        }\n                    }\n                    else {\n                        newDirectories.push(curr);\n                    }\n                }\n                for (const newDirectory of newDirectories) {\n                    this._cache.set(newDirectory, this._newDirStats());\n                }\n                this._cache.delete(from);\n                this._cache.set(to, content);\n            }\n        }\n        this._updateWatchers(from, 3 /* HostWatchEventType.Renamed */);\n    }\n    _list(path) {\n        path = this._toAbsolute(path);\n        if (this._isFile(path)) {\n            throw new exception_1.PathIsFileException(path);\n        }\n        const fragments = (0, path_1.split)(path);\n        const result = new Set();\n        if (path !== path_1.NormalizedRoot) {\n            for (const p of this._cache.keys()) {\n                if (p.startsWith(path + path_1.NormalizedSep)) {\n                    result.add((0, path_1.split)(p)[fragments.length]);\n                }\n            }\n        }\n        else {\n            for (const p of this._cache.keys()) {\n                if (p.startsWith(path_1.NormalizedSep) && p !== path_1.NormalizedRoot) {\n                    result.add((0, path_1.split)(p)[1]);\n                }\n            }\n        }\n        return [...result];\n    }\n    _exists(path) {\n        return !!this._cache.get(this._toAbsolute(path));\n    }\n    _isDirectory(path) {\n        const maybeStats = this._cache.get(this._toAbsolute(path));\n        return maybeStats ? maybeStats.isDirectory() : false;\n    }\n    _isFile(path) {\n        const maybeStats = this._cache.get(this._toAbsolute(path));\n        return maybeStats ? maybeStats.isFile() : false;\n    }\n    _stat(path) {\n        const maybeStats = this._cache.get(this._toAbsolute(path));\n        if (!maybeStats) {\n            return null;\n        }\n        else {\n            return maybeStats;\n        }\n    }\n    _watch(path, options) {\n        path = this._toAbsolute(path);\n        const subject = new rxjs_1.Subject();\n        let maybeWatcherArray = this._watchers.get(path);\n        if (!maybeWatcherArray) {\n            maybeWatcherArray = [];\n            this._watchers.set(path, maybeWatcherArray);\n        }\n        maybeWatcherArray.push([options || {}, subject]);\n        return subject.asObservable();\n    }\n    write(path, content) {\n        return new rxjs_1.Observable((obs) => {\n            this._write(path, content);\n            obs.next();\n            obs.complete();\n        });\n    }\n    read(path) {\n        return new rxjs_1.Observable((obs) => {\n            const content = this._read(path);\n            obs.next(content);\n            obs.complete();\n        });\n    }\n    delete(path) {\n        return new rxjs_1.Observable((obs) => {\n            this._delete(path);\n            obs.next();\n            obs.complete();\n        });\n    }\n    rename(from, to) {\n        return new rxjs_1.Observable((obs) => {\n            this._rename(from, to);\n            obs.next();\n            obs.complete();\n        });\n    }\n    list(path) {\n        return new rxjs_1.Observable((obs) => {\n            obs.next(this._list(path));\n            obs.complete();\n        });\n    }\n    exists(path) {\n        return new rxjs_1.Observable((obs) => {\n            obs.next(this._exists(path));\n            obs.complete();\n        });\n    }\n    isDirectory(path) {\n        return new rxjs_1.Observable((obs) => {\n            obs.next(this._isDirectory(path));\n            obs.complete();\n        });\n    }\n    isFile(path) {\n        return new rxjs_1.Observable((obs) => {\n            obs.next(this._isFile(path));\n            obs.complete();\n        });\n    }\n    // Some hosts may not support stat.\n    stat(path) {\n        return new rxjs_1.Observable((obs) => {\n            obs.next(this._stat(path));\n            obs.complete();\n        });\n    }\n    watch(path, options) {\n        return this._watch(path, options);\n    }\n    reset() {\n        this._cache.clear();\n        this._watchers.clear();\n    }\n}\nexports.SimpleMemoryHost = SimpleMemoryHost;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}