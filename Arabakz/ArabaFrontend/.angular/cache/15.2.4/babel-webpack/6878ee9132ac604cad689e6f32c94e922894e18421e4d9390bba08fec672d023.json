{"ast":null,"code":"'use strict';\n\nconst chalk = require('chalk');\n\n/**\n * The paginator returns a subset of the choices if the list is too long.\n */\n\nclass Paginator {\n  /**\n   * @param {import(\"./screen-manager\")} [screen]\n   * @param {{isInfinite?: boolean}} [options]\n   */\n  constructor(screen, options = {}) {\n    const {\n      isInfinite = true\n    } = options;\n    this.lastIndex = 0;\n    this.screen = screen;\n    this.isInfinite = isInfinite;\n  }\n  paginate(output, active, pageSize) {\n    pageSize = pageSize || 7;\n    let lines = output.split('\\n');\n    if (this.screen) {\n      lines = this.screen.breakLines(lines);\n      active = lines.map(lineParts => lineParts.length).splice(0, active).reduce((a, b) => a + b, 0);\n      lines = lines.flat();\n    }\n\n    // Make sure there's enough lines to paginate\n    if (lines.length <= pageSize) {\n      return output;\n    }\n    const visibleLines = this.isInfinite ? this.getInfiniteLines(lines, active, pageSize) : this.getFiniteLines(lines, active, pageSize);\n    this.lastIndex = active;\n    return visibleLines.join('\\n') + '\\n' + chalk.dim('(Move up and down to reveal more choices)');\n  }\n  getInfiniteLines(lines, active, pageSize) {\n    if (this.pointer === undefined) {\n      this.pointer = 0;\n    }\n    const middleOfList = Math.floor(pageSize / 2);\n    // Move the pointer only when the user go down and limit it to the middle of the list\n    if (this.pointer < middleOfList && this.lastIndex < active && active - this.lastIndex < pageSize) {\n      this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);\n    }\n\n    // Duplicate the lines so it give an infinite list look\n    const infinite = [lines, lines, lines].flat();\n    const topIndex = Math.max(0, active + lines.length - this.pointer);\n    return infinite.splice(topIndex, pageSize);\n  }\n  getFiniteLines(lines, active, pageSize) {\n    let topIndex = active - pageSize / 2;\n    if (topIndex < 0) {\n      topIndex = 0;\n    } else if (topIndex + pageSize > lines.length) {\n      topIndex = lines.length - pageSize;\n    }\n    return lines.splice(topIndex, pageSize);\n  }\n}\nmodule.exports = Paginator;","map":{"version":3,"names":["chalk","require","Paginator","constructor","screen","options","isInfinite","lastIndex","paginate","output","active","pageSize","lines","split","breakLines","map","lineParts","length","splice","reduce","a","b","flat","visibleLines","getInfiniteLines","getFiniteLines","join","dim","pointer","undefined","middleOfList","Math","floor","min","infinite","topIndex","max","module","exports"],"sources":["/Users/sabyrzhanolzhabay/Web-Dev/Arabakz/ArabaFrontend/node_modules/inquirer/lib/utils/paginator.js"],"sourcesContent":["'use strict';\n\nconst chalk = require('chalk');\n\n/**\n * The paginator returns a subset of the choices if the list is too long.\n */\n\nclass Paginator {\n  /**\n   * @param {import(\"./screen-manager\")} [screen]\n   * @param {{isInfinite?: boolean}} [options]\n   */\n  constructor(screen, options = {}) {\n    const { isInfinite = true } = options;\n    this.lastIndex = 0;\n    this.screen = screen;\n    this.isInfinite = isInfinite;\n  }\n\n  paginate(output, active, pageSize) {\n    pageSize = pageSize || 7;\n    let lines = output.split('\\n');\n\n    if (this.screen) {\n      lines = this.screen.breakLines(lines);\n      active = lines\n        .map((lineParts) => lineParts.length)\n        .splice(0, active)\n        .reduce((a, b) => a + b, 0);\n      lines = lines.flat();\n    }\n\n    // Make sure there's enough lines to paginate\n    if (lines.length <= pageSize) {\n      return output;\n    }\n    const visibleLines = this.isInfinite\n      ? this.getInfiniteLines(lines, active, pageSize)\n      : this.getFiniteLines(lines, active, pageSize);\n    this.lastIndex = active;\n    return (\n      visibleLines.join('\\n') +\n      '\\n' +\n      chalk.dim('(Move up and down to reveal more choices)')\n    );\n  }\n\n  getInfiniteLines(lines, active, pageSize) {\n    if (this.pointer === undefined) {\n      this.pointer = 0;\n    }\n    const middleOfList = Math.floor(pageSize / 2);\n    // Move the pointer only when the user go down and limit it to the middle of the list\n    if (\n      this.pointer < middleOfList &&\n      this.lastIndex < active &&\n      active - this.lastIndex < pageSize\n    ) {\n      this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);\n    }\n\n    // Duplicate the lines so it give an infinite list look\n    const infinite = [lines, lines, lines].flat();\n    const topIndex = Math.max(0, active + lines.length - this.pointer);\n\n    return infinite.splice(topIndex, pageSize);\n  }\n\n  getFiniteLines(lines, active, pageSize) {\n    let topIndex = active - pageSize / 2;\n    if (topIndex < 0) {\n      topIndex = 0;\n    } else if (topIndex + pageSize > lines.length) {\n      topIndex = lines.length - pageSize;\n    }\n    return lines.splice(topIndex, pageSize);\n  }\n}\n\nmodule.exports = Paginator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}